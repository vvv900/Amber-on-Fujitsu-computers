*******> Amber22 + AmberTools22 patch

 Authors: Mr. Hirosuke Hotta and Dr. V. Vassiliev
 E-mails: hotta.hirosuke@fujitsu.com
          vvv900@nci.org.au

 Date: December 8, 2023

 Description: A cumulative patch for the original Amber22 + AmberTools22 for the A64FX platform
              Targets Fujitsu compilers tcsds-1.2.38 and cp-1.0.21.04

 Apply patch in amber22_src directory as 
	patch -p0 -N -r patch_rejects < amber22-a64fx-final.patch

1) Building Amber Using CMake
	a) Use the latest Fujitsu-aware CMake (cmake-3.25.1, 3.26.3 or later)

	b) Building the serial and parallel versions in one step

mkdir build-mpi	
CD build-mpi

AMBER_PREFIX=$(dirname $(dirname `pwd`))
rm -rf *

BASE_DIR=/opt/FJSVxtclanga/tcsds-1.2.37
export PATH=$BASE_DIR/bin:$PATH
export LD_LIBRARY_PATH=$BASE_DIR/lib64:$LD_LIBRARY_PATH

cmake $AMBER_PREFIX/amber22_src \
  -DFortranCInterface_GLOBAL__SUFFIX=TRUE \
  -DFortranCInterface_GLOBAL__CASE=TRUE \
  -DCMAKE_INSTALL_PREFIX=$AMBER_PREFIX/amber22 \
  -DCOMPILER=FUJITSU -DUSE_FFT=TRUE -DBUILD_GUI=FALSE \
  -DMPI=TRUE -DCUDA=FALSE -DINSTALL_TESTS=TRUE \
  -DCMAKE_C_COMPILER=fcc \
  -DCMAKE_CXX_COMPILER=FCC \ 
  -DCMAKE_Fortran_COMPILER=frt \
  -DMPI_C_COMPILER=mpifcc \
  -DMPI_CXX_COMPILER=mpiFCC \
  -DMPI_Fortran_COMPILER=mpifrt \
  -DCMAKE_CXX_FLAGS_RELEASE="-Kfast" \
  -DDOWNLOAD_MINICONDA=FALSE -DBUILD_PYTHON=FALSE \
  -DCMAKE_VERBOSE_MAKEFILE=TRUE -DBUILD_QUICK=TRUE \
  -DCMAKE_C_FLAGS="-Nclang -fsigned-char -fpic" \
  -DCMAKE_CXX_FLAGS="-Nclang -fsigned-char -fpic" \ 
  -DCMAKE_Fortran_FLAGS="-Kfast -Ksimd_nouse_multiple_structures -Kpic -Nalloc_assign -fw" \
  -DSTATIC=TRUE --trace-expand \
  2>&1 | tee cmake.log

	run modify.sh script:

/path/to/modify.sh

make install -j8

--------------------------------------------------------------------------------

--- Makefile	2022-04-10 21:11:15.000000000 +0900
+++ ./Makefile	2022-05-12 17:39:23.000000000 +0900
@@ -3,26 +3,29 @@
 CONFIG_FILE=config.h
 # It was a bad idea to have this dependent on config.h;
 # this starts undoing that dependency.
-#include $(CONFIG_FILE)
+
+include $(CONFIG_FILE)
 
 install: ambertools amber
 
 amber:
-	@(if [ -n "$(BUILDAMBER)" ] ; then \
+	(if [ -n "$(BUILDAMBER)" ] ; then \
 	    cd src && $(MAKE) install; \
 	  else \
 		echo "==============================================================" ;\
-		echo "$(AMBER_SOURCE)/src/Makefile not found, or -noamber was set." ;\
+		echo "$(AMBERHOME)/src/Makefile not found, or -noamber was set." ;\
 		echo "This is expected if you do not have Amber22." ;\
 		echo "==============================================================" ;\
 	fi ;\
 	)
 
 ambertools:
-	cd $(AMBER_SOURCE)/AmberTools/src && $(MAKE) install
+	cd $(AMBERHOME)/AmberTools/src && $(MAKE) install
+#	cd $(AMBER_SOURCE)/AmberTools/src && $(MAKE) install
 
 pmemd:
-	cd $(AMBER_SOURCE)/src && $(MAKE) pmemd_only
+	cd $(AMBERHOME)/src && $(MAKE) pmemd_only
+#	cd $(AMBER_SOURCE)/src && $(MAKE) pmemd_only
 
 python:
 	cd $(AMBER_SOURCE)/AmberTools/src && $(MAKE) packmol-memgen parmed mmpbsa_py pymsmt $(PYTRAJ)
diff -u /home/users/isv02/isv0203/amber22-orig/configure ./configure
--- configure	2022-04-09 10:11:46.000000000 +0900
+++ ./configure	2022-05-05 14:55:37.000000000 +0900
@@ -7,7 +7,7 @@
 echo "   statment at the top of this file, but don't expect everything to work,"
 echo "   and you will probably need to make further changes.)"
 echo ""
-exit 1
+#exit 1
 
 error() {
    echo "Configure failed due to the errors above!"
diff -ruN /home/users/isv02/isv0203/amber22-orig/cmake/AmberCompilerConfig.cmake ./cmake/AmberCompilerConfig.cmake
--- cmake/AmberCompilerConfig.cmake	2022-08-29 08:45:14.000000000 +0900
+++ ./cmake/AmberCompilerConfig.cmake	2022-08-30 11:43:16.000000000 +0900
@@ -2,7 +2,7 @@
 
 # Handle the COMPILER option
 # --------------------------------------------------------------------
-set(ALL_COMPILER_VALUES GNU INTEL PGI CRAY CLANG MSVC AUTO MANUAL)
+set(ALL_COMPILER_VALUES GNU INTEL PGI CRAY CLANG MSVC FUJITSU AUTO MANUAL)
 
 # help message displayed when COMPILER is unset or invalid
 set(COMPILER_HELP "
@@ -15,6 +15,7 @@
       PGI        |     pgcc     |      pgc++     |     pgf90          | 14.9, 15.4, 16.5
       CLANG      |     clang    |      clang++   |     gfortran       | 
       CRAY       |     cc       |      CC        |     ftn            | 8.4.6*
+      FUJITSU    |     fcc      |      FCC       |     frt            | 
   --------------------------------------------------------------------------------------
       AUTO       |   <uses the default CMake-chosen compilers>
       MANUAL     |   <uses the CC, CXX, and FC environment variables, or the 
@@ -23,7 +24,7 @@
 
 
 #create actual option
-set(COMPILER "" CACHE STRING "Compiler to build Amber with.  Valid values: GNU, INTEL, PGI, CRAY, CLANG, MSVC, AUTO, MANUAL.  If 'auto', autodetect the host compiler, or use the CC,CXX,and FC variables if they are set.
+set(COMPILER "" CACHE STRING "Compiler to build Amber with.  Valid values: GNU, INTEL, FUJITSU, PGI, CRAY, CLANG, MSVC, AUTO, MANUAL.  If 'auto', autodetect the host compiler, or use the CC,CXX,and FC variables if they are set.
  This option can ONLY be set the first time CMake is run.  If you want to change it, delete the build directory and start over.")
  
 set(COMPILER_VALID FALSE)
diff -ru src/pmemd/src/Makefile ./src/pmemd/src/Makefile
--- src/pmemd/src/Makefile	2022-04-15 03:06:37.000000000 +0900
+++ ./src/pmemd/src/Makefile	2022-05-25 11:39:08.000000000 +0900
@@ -35,6 +35,41 @@
 
 .NOTPARALLEL: cuda_SPFP cuda_DPFP pmemd.cuda_SPFP$(SFX) pmemd.cuda_DPFP$(SFX)
 
+KMMD=	kmmd_externFortran.o kmmd_context.o kmmd_forcecalc.o kmmd_parseJSON.o pdb_io.o \
+	     	scanDB.o DB_vs_forcefield.o hash.o
+
+hash.o: $(AMBERHOME)/AmberTools/src/kmmd/hash.c
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/hash.c
+
+DB_vs_forcefield.o:     $(AMBERHOME)/AmberTools/src/kmmd/DB_vs_forcefield.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/DB_vs_forcefield.C
+
+kmmd_externFortran.o:   $(AMBERHOME)/AmberTools/src/kmmd/kmmd_externFortran.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/kmmd_externFortran.C
+
+kmmd_context.o: $(AMBERHOME)/AmberTools/src/kmmd/kmmd_context.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/kmmd_context.C
+
+kmmd_forcecalc.o:       $(AMBERHOME)/AmberTools/src/kmmd/kmmd_forcecalc.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/kmmd_forcecalc.C
+
+kmmd_parseJSON.o:       $(AMBERHOME)/AmberTools/src/kmmd/kmmd_parseJSON.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/kmmd_parseJSON.C
+
+pdb_io.o:       $(AMBERHOME)/AmberTools/src/kmmd/pdb_io.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/pdb_io.C
+
+scanDB.o:       $(AMBERHOME)/AmberTools/src/kmmd/scanDB.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/scanDB.C
+
 OBJS=   random$(OSFX) resamplekin$(OSFX) gbl_constants$(OSFX) \
         gbl_datatypes$(OSFX) state_info$(OSFX) file_io_dat$(OSFX) \
         boost-gamma-distribution$(OSFX) external_dat$(OSFX) \
@@ -62,12 +97,191 @@
         ensure_alloc$(OSFX) reservoir${OSFX} sams${OSFX} ramd${OSFX} runreweight${OSFX} hybridsolvent_remd$(OSFX) \
 		md_scheme$(OSFX)
 
+runmd.o:	md_scheme.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c md_scheme.F90
+
+pmemd.o:	runmd.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c runmd.F90
+				$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c pmemd.F90
+
+
 NFE_OBJECTS = \
         nfe_lib.o nfe_setup.o nfe_colvar.o nfe_smd.o nfe_abmd.o nfe_pmd.o nfe_bbmd.o nfe_stsm.o
 
 XRAY_OBJECTS = \
-   xray_fourier.o xray_globals.o xray_interface.o xray_utils.o \
-   xray_reciprocal_space.o assert.o wallclock.o bulk_solvent.o
+	xray_globals.o xray_interface.o \
+ 	assert.o wallclock.o \
+	xray_contracts.o xray_pure_utils.o xray_unit_cell.o xray_bulk_mask_data.o \
+	xray_interface_impl_cpu.o xray_interface2.o xray_interface2_data.o \
+	xray_target.o xray_target_least_squares.o xray_target_vector_least_squares.o \
+        xray_target_vector_least_squares_impl_cpu.o xray_target_vector_least_squares_data.o \
+	xray_target_max_likelihood.o xray_target_max_likelihood_impl_cpu.o \
+	xray_target_max_likelihood_data.o xray_non_bulk.o xray_non_bulk_impl_cpu.o \
+	xray_non_bulk_data.o xray_atomic_scatter_factor.o xray_atomic_scatter_factor_impl_cpu.o \
+	xray_bulk_model.o xray_bulk_model_afonine_2013.o xray_bulk_mask.o xray_bulk_mask_impl_cpu.o \
+        xray_fft_interface.o xray_fft_interface_impl_fftw.o xray_scaling.o xray_scaling_impl_cpu.o \
+	xray_scaling_data.o xray_bulk_model_none.o xray_bulk_model_simple.o xray_dpartial.o \
+      xray_dpartial_impl_cpu.o xray_dpartial_data.o xray_debug_dump.o xray_interface_pre_init_data.o \
+	xray_fft_interface_impl_none.o
+
+xray_fft_interface_impl_none.o: xray/src/xray_fft_interface_impl_none.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_fft_interface_impl_none.F90
+
+xray_fourier.o: xray/src/unused/xray_fourier.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/unused/xray_fourier.F90
+
+xray_interface_pre_init_data.o:	xray_interface_pre_init_data.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray_interface_pre_init_data.F90
+
+xray_debug_dump.o:	xray/src/xray_debug_dump.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_debug_dump.F90
+
+xray_dpartial_data.o:	xray/src/xray_dpartial_data.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_dpartial_data.F90
+
+xray_dpartial_impl_cpu.o:	xray/src/xray_dpartial_impl_cpu.F90 xray_dpartial_data.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_dpartial_impl_cpu.F90
+
+xray_dpartial.o:	xray/src/xray_dpartial.F90 xray_dpartial_impl_cpu.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_dpartial.F90
+
+xray_bulk_model_simple.o:	xray/src/xray_bulk_model_simple.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_bulk_model_simple.F90
+
+xray_bulk_model_none.o:	xray/src/xray_bulk_model_none.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_bulk_model_none.F90
+
+xray_scaling_data.o:	xray/src/xray_scaling_data.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_scaling_data.F90
+
+xray_scaling_impl_cpu.o:	xray/src/xray_scaling_impl_cpu.F90 xray_scaling_data.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_scaling_impl_cpu.F90
+
+xray_scaling.o:	xray/src/xray_scaling.F90 xray_scaling_impl_cpu.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_scaling.F90
+
+xray_fft_interface_impl_fftw.o:	xray/src/xray_fft_interface_impl_fftw.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_fft_interface_impl_fftw.F90
+
+xray_fft_interface.o:	xray/src/xray_fft_interface.F90 xray_fft_interface_impl_fftw.o xray_fft_interface_impl_none.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) -DPMEMD_XRAY_FFT_BACKEND_IS_NONE $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_fft_interface.F90
+
+xray_bulk_mask_impl_cpu.o:	xray/src/xray_bulk_mask_impl_cpu.F90 xray_fft_interface.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_bulk_mask_impl_cpu.F90
+
+xray_bulk_mask.o:	xray/src/xray_bulk_mask.F90 xray_bulk_mask_impl_cpu.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_bulk_mask.F90
+
+xray_bulk_model_afonine_2013.o:	xray/src/xray_bulk_model_afonine_2013.F90 xray_bulk_mask.o xray_scaling.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_bulk_model_afonine_2013.F90
+
+xray_bulk_model.o:	xray/src/xray_bulk_model.F90 xray_bulk_model_afonine_2013.o xray_bulk_model_none.o xray_bulk_model_simple.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_bulk_model.F90
+
+xray_atomic_scatter_factor_impl_cpu.o:	xray/src/xray_atomic_scatter_factor_impl_cpu.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_atomic_scatter_factor_impl_cpu.F90
+
+xray_atomic_scatter_factor.o:	xray/src/xray_atomic_scatter_factor.F90 xray_atomic_scatter_factor_impl_cpu.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_atomic_scatter_factor.F90
+
+xray_non_bulk_data.o:	xray/src/xray_non_bulk_data.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_non_bulk_data.F90
+
+xray_non_bulk_impl_cpu.o:	xray/src/xray_non_bulk_impl_cpu.F90 xray_non_bulk_data.o xray_atomic_scatter_factor.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_non_bulk_impl_cpu.F90
+
+xray_non_bulk.o:	xray/src/xray_non_bulk.F90 xray_non_bulk_impl_cpu.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_non_bulk.F90
+
+xray_target_max_likelihood_data.o:	xray/src/xray_target_max_likelihood_data.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_target_max_likelihood_data.F90
+
+xray_target_max_likelihood_impl_cpu.o:	xray/src/xray_target_max_likelihood_impl_cpu.F90 xray_target_max_likelihood_data.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_target_max_likelihood_impl_cpu.F90
+
+xray_target_max_likelihood.o:	xray/src/xray_target_max_likelihood.F90 xray_target_max_likelihood_impl_cpu.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_target_max_likelihood.F90
+
+xray_target_vector_least_squares_data.o:	xray/src/xray_target_vector_least_squares_data.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_target_vector_least_squares_data.F90
+
+xray_target_vector_least_squares_impl_cpu.o:	xray/src/xray_target_vector_least_squares_impl_cpu.F90 \
+			xray_target_vector_least_squares_data.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_target_vector_least_squares_impl_cpu.F90
+
+xray_target_vector_least_squares.o:	xray/src/xray_target_vector_least_squares.F90 xray_target_vector_least_squares_impl_cpu.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_target_vector_least_squares.F90
+
+xray_target_least_squares.o:	xray/src/xray_target_least_squares.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_target_least_squares.F90
+
+xray_target.o:	xray/src/xray_target.F90 xray_target_least_squares.o xray_target_vector_least_squares.o \
+			xray_target_max_likelihood.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_target.F90
+
+xray_interface2_data.o:	xray/src/xray_interface2_data.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_interface2_data.F90
+
+xray_interface2.o:	xray/src/xray_interface2.F90 xray_interface2_data.o xray_target.o \
+				xray_target_least_squares.o xray_non_bulk.o xray_bulk_model.o \
+							xray_dpartial.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_interface2.F90
+
+xray_interface_impl_cpu.o:	xray_interface_impl_cpu.F90 xray_debug_dump.o xray_interface_pre_init_data.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray_interface_impl_cpu.F90
+
+xray_bulk_mask_data.o:	xray/src/xray_bulk_mask_data.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_bulk_mask_data.F90
+
+xray_contracts.o:	xray/src/xray_contracts.F90
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_contracts.F90
+
+xray_pure_utils.o:	xray/src/xray_pure_utils.F90 xray_contracts.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_pure_utils.F90
+
+xray_unit_cell.o:	xray/src/xray_unit_cell.F90 xray_pure_utils.o
+		@echo "[PMEMD]  FC $<"
+			$(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -c xray/src/xray_unit_cell.F90
+
 
 ifneq ("$(wildcard ~/.amber_extra_flags.inc)", "")
   include ~/.amber_extra_flags.inc
@@ -103,14 +317,24 @@
 	$(MAKE) $(BINDIR)/pmemd.cuda_DPFP.MPI$(SFX)
 
 $(BINDIR)/pmemd$(SFX): $(OBJS) $(EMIL) $(NFE_OBJECTS) $(PLUMED_DEPENDENCIES) \
-    $(XRAY_OBJECTS)
+    $(XRAY_OBJECTS) $(KMMD)
+	$(VB)if [[ "$(PMEMD_F90)" = *"frt"* ]] ; then \
+	  echo "[PMEMD]  FC $<" ;\
+	  $(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -Nsetvalue -c mcres.F90 ;\
+        fi
 	$(PMEMD_LD) $(PMEMD_FOPTFLAGS) $(LDOUT)$@ $(OBJS) $(XRAY_OBJECTS) -L$(LIBDIR) \
-    $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD)
+    $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD) $(KMMD) \
+    $(FFTW3)
 
 $(BINDIR)/pmemd.MPI$(SFX): $(OBJS) $(EMIL) $(NFE_OBJECTS) \
-    $(PLUMED_DEPENDENCIES) $(XRAY_OBJECTS)
+    $(PLUMED_DEPENDENCIES) $(XRAY_OBJECTS) $(KMMD)
+	if [[ "$(PMEMD_F90)" = *"frt"* ]] ; then \
+	  echo "[PMEMD]  FC $<" ;\
+	  $(PMEMD_F90) $(PMEMD_FOPTFLAGS) $(PMEMD_CU_DEFINES) $(NETCDFINC) -Nsetvalue -c mcres.F90 ;\
+	fi
 	$(PMEMD_LD) $(PMEMD_FOPTFLAGS) $(LDOUT)$@ $(OBJS) $(XRAY_OBJECTS) -L$(LIBDIR) \
-    $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD)
+	$(KMMD)  $(FFTW3) \
+    $(NETCDFLIBF) $(LDFLAGS) $(PMEMD_FLIBSF) $(NFE_OBJECTS) $(PLUMED_LOAD) --linkstl=libc++
 
 $(BINDIR)/pmemd.cuda_SPFP$(SFX): $(OBJS) cuda_spfp_libs $(EMIL) \
     $(NFE_OBJECTS) $(PLUMED_DEPENDENCIES) $(XRAY_OBJECTS)
diff -ru src/pmemd/src/bonds.F90 ./src/pmemd/src/bonds.F90
--- src/pmemd/src/bonds.F90	2019-08-01 21:29:54.000000000 +0900
+++ ./src/pmemd/src/bonds.F90	2022-05-05 14:56:44.000000000 +0900
@@ -93,8 +93,13 @@
     cit_h_bond(1:cit_nbonh) = bonds_copy(1:cit_nbonh)
   end if
 
-  call find_my_bonds(nbona, gbl_bond(bonda_idx), cit_nbona, bonds_copy, &
-                         use_atm_map)
+  if ( size(gbl_bond) .ge. bonda_idx) then
+    call find_my_bonds(nbona, gbl_bond(bonda_idx), cit_nbona, bonds_copy, &
+                       use_atm_map)
+  else
+    call find_my_bonds(nbona, gbl_bond(bonda_idx-1), cit_nbona, bonds_copy, &
+                       use_atm_map)
+  endif
 
   if (cit_nbona .gt. 0) then
     if (allocated(cit_a_bond)) then
diff -ru src/pmemd/src/charmm.F90 ./src/pmemd/src/charmm.F90
--- src/pmemd/src/charmm.F90	2018-08-15 20:33:59.000000000 +0900
+++ ./src/pmemd/src/charmm.F90	2022-05-05 14:56:44.000000000 +0900
@@ -48,7 +48,7 @@
 ! VARIABLES AND DERIVED DATA TYPES
 !------------------------------------------------------------
   ! Do we have reason to be?
-  logical,save :: charmm_active
+  logical,save :: charmm_active = .false.
 
 
 !------------------------------------------------------------
diff -ru src/pmemd/src/cmap.F90 ./src/pmemd/src/cmap.F90
--- src/pmemd/src/cmap.F90	2022-01-29 01:49:00.000000000 +0900
+++ ./src/pmemd/src/cmap.F90	2022-05-05 14:56:44.000000000 +0900
@@ -16,7 +16,7 @@
 
 ! The following are derived from prmtop dihedral info:
 
-  integer, save                             :: cit_cmap_term_count
+  integer, save                             :: cit_cmap_term_count=0
   type(cmap_rec), allocatable, save         :: cit_cmap(:)
 
   !Local
diff -ru src/pmemd/src/constante.F90 ./src/pmemd/src/constante.F90
--- src/pmemd/src/constante.F90	2022-01-29 01:49:00.000000000 +0900
+++ ./src/pmemd/src/constante.F90	2022-05-05 14:56:44.000000000 +0900
@@ -59,7 +59,7 @@
 integer, save, allocatable :: iselres(:)
 integer, save, allocatable :: iselstat(:)
 
-integer, save, public :: ce_igb
+integer, save, public :: ce_igb=0
 
 double precision, save :: ce_intdiel ! not implemented
 
@@ -1030,7 +1030,7 @@
   if (.not. master) return
 
   chrgdat(:) = gbl_chrgdat(:) * ONE_AMBER_ELECTROSTATIC
-  statene(:) = gbl_statene(:)
+  statene(0:MAX_TITR_RES-1) = gbl_statene(0:MAX_TITR_RES-1)
   eo_corr(:) = gbl_eo_corr(:)
   stateinf(:) = gbl_stateinf(:)
   eleccnt(:) = gbl_eleccnt(:)
diff -ru src/pmemd/src/constantph.F90 ./src/pmemd/src/constantph.F90
--- src/pmemd/src/constantph.F90	2022-04-09 10:11:46.000000000 +0900
+++ ./src/pmemd/src/constantph.F90	2022-05-05 14:56:44.000000000 +0900
@@ -63,7 +63,7 @@
 integer, save, allocatable :: iselres(:)
 integer, save, allocatable :: iselstat(:)
 
-integer, save, public :: cph_igb, cphe_igb
+integer, save, public :: cph_igb=0, cphe_igb
 
 double precision, save :: cph_intdiel, cphe_intdiel ! not implemented
 
@@ -1392,7 +1392,7 @@
   if (.not. master) return
 
   chrgdat(:) = gbl_chrgdat(:) * ONE_AMBER_ELECTROSTATIC
-  statene(:) = gbl_statene(:)
+  statene(0:MAX_TITR_RES-1) = gbl_statene(0:MAX_TITR_RES-1)
   pka_corr(:) = gbl_pka_corr(:)
   eo_corr(:) = gbl_eo_corr(:)
   stateinf(:) = gbl_stateinf(:)
diff -ru src/pmemd/src/dihedrals_imp.F90 ./src/pmemd/src/dihedrals_imp.F90
--- src/pmemd/src/dihedrals_imp.F90	2022-01-29 01:49:01.000000000 +0900
+++ ./src/pmemd/src/dihedrals_imp.F90	2022-05-05 14:56:44.000000000 +0900
@@ -43,7 +43,7 @@
 
 ! The following are derived from prmtop dihedral info:
 
-  integer, save                             :: cit_nimphi
+  integer, save                             :: cit_nimphi=0
 
   type(dihed_imp_rec), allocatable, save    :: cit_dihed_imp(:)
 
diff -ru src/pmemd/src/extra_pnts_nb14.F90 ./src/pmemd/src/extra_pnts_nb14.F90
--- src/pmemd/src/extra_pnts_nb14.F90	2022-04-09 10:11:46.000000000 +0900
+++ ./src/pmemd/src/extra_pnts_nb14.F90	2022-05-12 21:04:14.000000000 +0900
@@ -3410,8 +3410,8 @@
                 (lcl_crd(2,1,frame_id)*rja(2) + rm(3)*rt(1))*cfz
         fd(2) = -(lcl_crd(2,1,frame_id)*rja(3) + rm(1)*rt(2))*cfx - rm(2)*rt(2)*cfy + &
                 (lcl_crd(2,1,frame_id)*rja(1) - rm(3)*rt(2))*cfz
-        fd(3) = (lcl_crd(2,1,frame_id)*rja(2) - rm(1)*rt(3))*cfx + &
-                -(lcl_crd(2,1,frame_id)*rja(1) + rm(2)*rt(3))*cfy - rm(3)*rt(3)*cfz
+        fd(3) = (lcl_crd(2,1,frame_id)*rja(2) - rm(1)*rt(3))*cfx - &
+                (lcl_crd(2,1,frame_id)*rja(1) + rm(2)*rt(3))*cfy - rm(3)*rt(3)*cfz
         do m = 1, 3
           frc(m, j1) = frc(m, j1) + frc(m, j) - fb(m) - fc(m) - fd(m)
           frc(m, j2) = frc(m, j2) + fb(m)
diff -ru src/pmemd/src/gb_ene.F90 ./src/pmemd/src/gb_ene.F90
--- src/pmemd/src/gb_ene.F90	2022-04-15 03:06:37.000000000 +0900
+++ ./src/pmemd/src/gb_ene.F90	2022-05-05 14:56:44.000000000 +0900
@@ -241,6 +241,19 @@
 
 contains
 
+ integer function toInteger(a)
+  logical               :: a
+
+  if ( a ) then
+    toInteger = 1
+  else
+    toInteger = 0
+  endif
+
+  end function toInteger
+
+
+
 !*******************************************************************************
 !
 ! Subroutine:  final_gb_setup
@@ -1976,7 +1989,7 @@
         call vdinv(kk1, vectmp2, vectmp2)
         call vdinv(kk1, vectmp3, vectmp3)
         vectmp4(1:kk1) = vectmp4(1:kk1) * vectmp3(1:kk1)
-        call vdln(kk1, vectmp4, vectmp4)
+        call vdln1(kk1, vectmp4 )
 
         kk1 = 0
         do k = 1, icount
@@ -2610,7 +2623,8 @@
                 end do
               end if
             end if
-          else if (XOR(i_is_sc, j_is_sc)) then !sc-c
+!          else if (XOR(i_is_sc, j_is_sc)) then !sc-c
+          else if (XOR( toInteger(i_is_sc), toInteger(j_is_sc)).ne.0) then !sc-c
             eel = qiqj *intdiel_inv * sc_eel_denom_sqrt
             eelt = eelt + eel
             scdvdl = scdvdl + (eel * scbeta * ti_sign * sceeorderinv * &
@@ -2667,7 +2681,8 @@
                   end do
                 end if
               end if
-            else if (XOR(i_is_sc, j_is_sc)) then !sc-c
+!            else if (XOR(i_is_sc, j_is_sc)) then !sc-c
+             else if (XOR( toInteger(i_is_sc), toInteger(j_is_sc)).ne.0) then !sc-c
               f6 = 1.0d0/(sc_vdw + r6 * ti_sigma6(ic))
               f12 = f6 * f6
               evdw = evdw + ti_foureps(ic) * ( f12 - f6)
@@ -2947,8 +2962,8 @@
     call vdinv(kk2, vectmp3, vectmp3)
     vectmp4(1:kk1) = vectmp2(1:kk1) * vectmp4(1:kk1)
     vectmp5(1:kk2) = vectmp3(1:kk2) * vectmp5(1:kk2)
-    call vdln(kk1, vectmp4, vectmp4)
-    call vdln(kk2, vectmp5, vectmp5)
+    call vdln1(kk1, vectmp4)
+    call vdln1(kk2, vectmp5)
 
     kk1 = 0
     kk2 = 0
diff -ru src/pmemd/src/mcres.F90 ./src/pmemd/src/mcres.F90
--- src/pmemd/src/mcres.F90	2022-04-09 10:11:46.000000000 +0900
+++ ./src/pmemd/src/mcres.F90	2022-05-05 14:56:44.000000000 +0900
@@ -947,6 +947,9 @@
     use timers_mod
     use state_info_mod
     use bintraj_mod
+#ifdef __FUJITSU
+    use, intrinsic :: ieee_arithmetic
+#endif
 
     implicit none
 
@@ -1077,16 +1080,16 @@
 #ifdef CUDA
     call gpu_steric_grid(atm_cnt, mxXVxl, mxYVxl, mxZVxl, GSP, steric_radius, nmEmpVxls, voxelOffset)
     allocate(listEmptyVoxels(int(nmEmpVxls*1.2)),stat=error)
-    if (stat.ne.0) then
-        write(0,*)"error: couldnt allocate memory for array, listEmptyVoxels=",stat
+    if (error.ne.0) then
+        write(0,*)"error: couldnt allocate memory for array, listEmptyVoxels=",error
         stop 1
     endif
     call gpu_steric_grid_empty_voxels(nmEmpVxls,listEmptyVoxels)
 #else
     allocate(stericGrid(mxXVxl, mxYVxl, mxZVxl),stat=error)
 
-    if (stat.ne.0) then
-        write(0,*)"error: couldnt allocate memory for array, g=",stat
+    if (error.ne.0) then
+        write(0,*)"error: couldnt allocate memory for array, g=",error
         stop 1
     endif
     stericGrid(:,:,:)=0
@@ -1095,8 +1098,8 @@
     call determineNumberOfEmptyVoxels(stericGrid,mxXVxl,mxYVxl,mxZVxl,nmEmpVxls,voxelOffset)
     allocate(listEmptyVoxels(int(nmEmpVxls*1.2),3),stat=error)
 
-    if (stat.ne.0) then
-        write(0,*)"error: couldnt allocate memory for array, listEmptyVoxels=",stat
+    if (error.ne.0) then
+        write(0,*)"error: couldnt allocate memory for array, listEmptyVoxels=",error
         stop 1
     endif
 
@@ -1108,8 +1111,8 @@
 
     allocate(coarseGrid(maxCoarseXVxl+3, maxCoarseYVxl+3, maxCoarseZVxl+3, nint(coarseGSP*15)),stat=error)
 
-    if (stat.ne.0) then
-        write(0,*)"error: couldnt allocate memory for array, coarseGrid=",stat
+    if (error.ne.0) then
+        write(0,*)"error: couldnt allocate memory for array, coarseGrid=",error
         stop 1
     endif
     coarseGrid(:,:,:,:)=0
@@ -1199,7 +1202,11 @@
                             pot_ene, nstep, virial, ekcmt, pme_err_est)
 #endif
              new_ene = pot_ene%total
+#ifdef __FUJITSU
+             if(ieee_is_nan(new_ene) .or. new_ene > 999999999.0d0 .or. new_ene < -999999999.0d0) then
+#else
              if(isnan(new_ene) .or. new_ene > 999999999.0d0 .or. new_ene < -999999999.0d0) then
+#endif
                  new_ene=999999999.0d0
              end if
              !write(0,*)"Ene:",new_ene-old_ene,acceptance_array(cyc_cnt), pot_ene%vdw_tot,pot_ene%elec_tot
@@ -1255,14 +1262,14 @@
 9999 continue
 
     deallocate(steric_radius,stat=error)
-    if (stat.ne.0) then
-        write(0,*)"error in deallocating array steric_radius",stat
+    if (error.ne.0) then
+        write(0,*)"error in deallocating array steric_radius",error
         stop 1
     endif
 
     deallocate(listEmptyVoxels,stat=error)
-    if (stat.ne.0) then
-        write(0,*)"error in deallocating array listEmptyVoxels=",stat
+    if (error.ne.0) then
+        write(0,*)"error in deallocating array listEmptyVoxels=",error
         stop 1
     endif
 
diff -ru src/pmemd/src/mdin_ctrl_dat.F90 ./src/pmemd/src/mdin_ctrl_dat.F90
--- src/pmemd/src/mdin_ctrl_dat.F90	2022-04-09 10:11:46.000000000 +0900
+++ ./src/pmemd/src/mdin_ctrl_dat.F90	2022-05-05 14:56:44.000000000 +0900
@@ -20,7 +20,7 @@
 
   logical :: usemidpoint
 
-  integer                       imin, nmropt, ntx, irest, ntrx, ntxo, &
+  integer                   ::  imin, nmropt, ntx, irest, ntrx, ntxo, &
                                 ntpr, ntave, ntwr, iwrap, ntwx, ntwv, &
                                 ntwe, ioutfm, ntwprt, ntf, ntb, nsnb, &
                                 ipol, ibelly, ntr, maxcyc, ncyc, ntmin, &
@@ -43,7 +43,7 @@
                                 w_amd, emil_do_calc,isgld,isgsta,isgend,nsgsize, &
                                 tishake, emil_sc,iemap, lj1264, efn,mcwat,mcint,&
                                 nucat, & ! gbneck2nu: check if atom belong to nucleic or not
-                                mcrescyc, nmc, nmd, mcverbosity, &
+                                mcrescyc, nmc=0, nmd, mcverbosity, &
                                 reservoir_exchange_step, &
                                 infe, & ! added by FENG PAN
                                 ineb, skmin, skmax, tmode, vv, nebfreq, &
@@ -149,7 +149,7 @@
   ! not minimization and will also effectively be turned off if ntave is in use
   ! or RESPA is in use.
 
-  double precision              dielc, es_cutoff, vdw_cutoff, fswitch, &
+  double precision ::           dielc, es_cutoff, vdw_cutoff, fswitch, &
                                 dx0, drms, t, dt, temp0, tempi, &
                                 tautp, gamma_ln, vlimit, pres0, comp, taup, &
                                 tol, fcap, pencut, intdiel, extdiel, saltcon, &
diff -ru src/pmemd/src/nfe_abmd.F90 ./src/pmemd/src/nfe_abmd.F90
--- src/pmemd/src/nfe_abmd.F90	2022-01-29 01:49:01.000000000 +0900
+++ ./src/pmemd/src/nfe_abmd.F90	2022-05-05 14:56:45.000000000 +0900
@@ -37,9 +37,12 @@
                        umbrella_t, MAX_NUMBER_OF_COLVARS => UMBRELLA_MAX_NEXTENTS
 use nfe_colvar_mod
 
+use random_mod, only : random_state, amrset_gen
+
 implicit none
 
-#include "random.i"
+!#include "random.i"
+
 
 private
 
diff -ru src/pmemd/src/pbc.F90 ./src/pmemd/src/pbc.F90
--- src/pmemd/src/pbc.F90	2022-04-09 10:11:46.000000000 +0900
+++ ./src/pmemd/src/pbc.F90	2022-05-05 14:56:45.000000000 +0900
@@ -28,8 +28,8 @@
 
   integer, parameter    :: pbc_dbl_cnt = 32
 
-  double precision   recip(3, 3), ucell(3, 3), pbc_box(3), cut_factor(3), &
-                     reclng(3), pbc_alpha, pbc_beta, pbc_gamma, &
+  double precision:: recip(3, 3), ucell(3, 3), pbc_box(3)=(/ 0, 0, 0 /), cut_factor(3), &
+                     reclng(3), pbc_alpha=0, pbc_beta=0, pbc_gamma=0, &
                      uc_volume, uc_sphere, old_pbc(3)
 
   common / pbc_dbl / recip, ucell, pbc_box, cut_factor, &
diff -ru src/pmemd/src/pme_alltasks_setup.F90 ./src/pmemd/src/pme_alltasks_setup.F90
--- src/pmemd/src/pme_alltasks_setup.F90	2022-04-09 10:11:46.000000000 +0900
+++ ./src/pmemd/src/pme_alltasks_setup.F90	2022-05-05 14:56:45.000000000 +0900
@@ -212,9 +212,15 @@
                        (iwrap .ne. 0) .or. &
                 (emil_do_calc .gt. 0) .or. &
                 (mcwat .gt. 0)) then
-    call setup_molecule_lists(num_ints, num_reals, natom, nspm, atm_nsp, &
-                              nbona, gbl_bond(bonda_idx), &
-                              no_intermolecular_bonds)
+    if ( size(gbl_bond).ge.bonda_idx ) then 
+      call setup_molecule_lists(num_ints, num_reals, natom, nspm, atm_nsp, &
+                                nbona, gbl_bond(bonda_idx), &
+                                no_intermolecular_bonds)
+    else
+      call setup_molecule_lists(num_ints, num_reals, natom, nspm, atm_nsp, &
+                                nbona, gbl_bond(size(gbl_bond)), &
+                                no_intermolecular_bonds)
+    endif
   end if
 
   ! Old molecule lists no longer valid...
diff -ru src/pmemd/src/pme_direct.F90 ./src/pmemd/src/pme_direct.F90
--- src/pmemd/src/pme_direct.F90	2022-04-09 10:11:46.000000000 +0900
+++ ./src/pmemd/src/pme_direct.F90	2022-05-05 14:56:45.000000000 +0900
@@ -109,8 +109,7 @@
 
   integer               :: alloc_failed
 
-  allocate(gbl_eed_cub(4 * mxeedtab), &
-           stat = alloc_failed)
+  allocate(gbl_eed_cub(4 * mxeedtab), stat = alloc_failed)
 
   if (alloc_failed .ne. 0) call setup_alloc_error
 
@@ -414,6 +413,7 @@
     if (alloc_failed .ne. 0) then
       call alloc_error('get_nb_list_midpoint', 'ipairs array reallocation failed!')
     end if
+    proc_ipairs(:)=0
 
   end do
 
@@ -683,6 +683,7 @@
     if (alloc_failed .ne. 0) then
       call alloc_error('get_nb_list', 'ipairs array reallocation failed!');
     end if
+    gbl_ipairs(:)=0
 
 ! code that will handle ifail_dev .eq. 0
 
diff -ru src/pmemd/src/pme_force.F90 ./src/pmemd/src/pme_force.F90
--- src/pmemd/src/pme_force.F90	2022-04-09 10:11:46.000000000 +0900
+++ ./src/pmemd/src/pme_force.F90	2022-05-05 14:56:45.000000000 +0900
@@ -4453,6 +4453,7 @@
                              pot_ene%elec_14, pot_ene%vdw_14, &
                              vir%elec_14)
       else
+        if (.not.allocated(cit_nb14) ) allocate(cit_nb14(1,1) )
         call get_nb14_energy(atm_qterm, crd, frc, atm_iac, typ_ico, &
                              gbl_cn1, gbl_cn2, cit_nb14, cit_nb14_cnt, &
                              pot_ene%elec_14, pot_ene%vdw_14)
diff -ru src/pmemd/src/prmtop_dat.F90 ./src/pmemd/src/prmtop_dat.F90
--- src/pmemd/src/prmtop_dat.F90	2022-04-09 10:11:46.000000000 +0900
+++ ./src/pmemd/src/prmtop_dat.F90	2022-05-05 14:56:45.000000000 +0900
@@ -1563,11 +1563,18 @@
   orig_nphih = nphih        ! Saved for reporting later
   orig_nphia = nphia        ! Saved for reporting later
 
+  if ( .not.allocated(gbl_pn) ) allocate(gbl_pn(1) )
   call duplicate_dihedrals(nphih, gbl_dihed, gbl_pn)
   call duplicate_dihedrals(nphia, gbl_dihed(diheda_idx), gbl_pn)
 
 ! Pre-calculate and save some parameters for vector ephi:
 
+  if (.not.allocated(gbl_pk) ) allocate(gbl_pk(1) )
+  if (.not.allocated(gbl_phase) ) allocate(gbl_phase(1) )
+  if (.not.allocated(gbl_gamc) ) allocate(gbl_gamc(1) )
+  if (.not.allocated(gbl_gams) ) allocate(gbl_gams(1) )
+  if (.not.allocated(gbl_ipn) ) allocate(gbl_ipn(1) )
+  if (.not.allocated(gbl_fmn) ) allocate(gbl_fmn(1) )
   call calc_dihedral_parms(nptra, gbl_pk, gbl_pn, gbl_phase, gbl_gamc, &
                            gbl_gams, gbl_ipn, gbl_fmn)
 
diff -ru src/pmemd/src/runmd.F90 ./src/pmemd/src/runmd.F90
--- src/pmemd/src/runmd.F90	2022-04-15 10:12:46.000000000 +0900
+++ ./src/pmemd/src/runmd.F90	2022-05-05 14:56:45.000000000 +0900
@@ -372,8 +372,13 @@
 #endif /*MPI*/
   else
     if (.not. allocated(atm_igroup)) allocate(atm_igroup(atm_cnt))
-    call degcnt(ibelly, natom, atm_igroup, natom, gbl_bond, gbl_bond(bonda_idx), &
-                ntc, rndfp, rndfs)
+    if ( size(gbl_bond) .ge. bonda_idx) then
+      call degcnt(ibelly, natom, atm_igroup, natom, gbl_bond, gbl_bond(bonda_idx), &
+                  ntc, rndfp, rndfs)
+    else
+      call degcnt(ibelly, natom, atm_igroup, natom, gbl_bond, gbl_bond(bonda_idx-1), &
+                  ntc, rndfp, rndfs)
+    endif
   end if
 
 
diff -ru src/pmemd/src/shake.F90 ./src/pmemd/src/shake.F90
--- src/pmemd/src/shake.F90	2022-04-09 10:11:46.000000000 +0900
+++ ./src/pmemd/src/shake.F90	2022-05-05 14:56:45.000000000 +0900
@@ -47,9 +47,9 @@
 
   integer, save, private                           :: atm_cnt, res_cnt
 
-  integer, save, private                           :: iorwat
+  integer, save, private                           :: iorwat=0
 
-  double precision, save, private                  :: rbtarg(8)
+  double precision, save, private                  :: rbtarg(8)=(/0,0,0,0,0,0,0,0/)
   double precision, save, private                  :: box_half(3)
 
   integer, save                                    :: noshakemask_cnt
@@ -1575,7 +1575,7 @@
   integer               :: ihf1, ihf2, iof
   integer               :: nofast
   integer               :: parm_idx
-  double precision      :: rhh, roh, roh1, roh2
+  double precision      :: rhh, roh=0, roh1, roh2
 
   double precision, parameter   :: small = 1.d-4
 
diff -ru src/pmemd/src/ti.F90 ./src/pmemd/src/ti.F90
--- src/pmemd/src/ti.F90	2022-04-09 10:11:46.000000000 +0900
+++ ./src/pmemd/src/ti.F90	2022-05-05 14:56:45.000000000 +0900
@@ -21,7 +21,7 @@
   integer, save                            :: ti_ti_atm_cnt(2) !Just TI atoms
   integer, save                            :: ti_numextra_pts(2) !Extra points
   ! Use ti_latm_cnt/ti_latm_lst for all linear scaling terms
-  integer, save                            :: ti_latm_cnt(2) !Just linear atoms
+  integer, save                            :: ti_latm_cnt(2)=(/0,0/) !Just linear atoms
 
   ! So we can just use this module instead of mdin_ctrl_dat_mod
   integer, save                            :: ifmbar_lcl
diff -ru src/pmemd/src/veclib.F90 ./src/pmemd/src/veclib.F90
--- src/pmemd/src/veclib.F90	2019-08-01 21:29:54.000000000 +0900
+++ ./src/pmemd/src/veclib.F90	2022-05-05 14:56:45.000000000 +0900
@@ -35,6 +35,20 @@
   return
 
 end subroutine vdln 
+
+subroutine vdln1(n, x)
+
+  implicit none
+
+  integer               :: n
+  double precision      :: x(n)
+
+  x(1:n) = log(x(1:n))
+
+  return
+
+end subroutine vdln1
+
 !--------------------------------------------------------------
 
 !+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
diff -ru AmberTools/src/xblas/CMakeLists.txt ./AmberTools/src/xblas/CMakeLists.txt
--- AmberTools/src/xblas/CMakeLists.txt	2022-08-29 08:40:17.000000000 +0900
+++ ./AmberTools/src/xblas/CMakeLists.txt	2022-08-12 11:12:03.000000000 +0900
@@ -32,6 +32,10 @@
 	set(XBLAS_CFLAGS "${XBLAS_CFLAGS} -DCONFIG_FC_DBL_UNDERSCORE")
 endif()
 
+if( "${COMPILER}" STREQUAL "FUJITSU" )
+        add_compile_definitions( _FILE_OFFSET_BITS=64 _LARGEFILE_SOURCE )
+endif()
+
 # check whether FPU control code is needed
 check_all_includes(C fpu_control.h)
 
Only in ./AmberTools/src/xblas: CMakeLists.txt.original
diff -ru AmberTools/src/xblas/config/config.guess ./AmberTools/src/xblas/config/config.guess
--- AmberTools/src/xblas/config/config.guess	2022-08-29 08:40:17.000000000 +0900
+++ ./AmberTools/src/xblas/config/config.guess	2022-05-05 14:56:49.000000000 +0900
@@ -1,14 +1,12 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
-#   2011 Free Software Foundation, Inc.
+#   Copyright 1992-2019 Free Software Foundation, Inc.
 
-timestamp='2011-12-29'
+timestamp='2019-04-28'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -17,26 +15,22 @@
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
+# along with this program; if not, see <https://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Originally written by Per Bothner.  Please send patches (context
-# diff format) to <config-patches@gnu.org> and include a ChangeLog
-# entry.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 #
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
 # You can get the latest version of this script from:
-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+# https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+#
+# Please send patches to <config-patches@gnu.org>.
+
 
 me=`echo "$0" | sed -e 's,.*/,,'`
 
@@ -45,7 +39,7 @@
 
 Output the configuration name of the system \`$me' is run on.
 
-Operation modes:
+Options:
   -h, --help         print this help, then exit
   -t, --time-stamp   print date of last modification, then exit
   -v, --version      print version number, then exit
@@ -56,9 +50,7 @@
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free
-Software Foundation, Inc.
+Copyright 1992-2019 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -92,8 +84,6 @@
   exit 1
 fi
 
-trap 'exit 1' 1 2 15
-
 # CC_FOR_BUILD -- compiler used by this script. Note that the use of a
 # compiler to aid in system detection is discouraged as it requires
 # temporary files to be created and, as you can see below, it is a
@@ -104,34 +94,38 @@
 
 # Portable tmp directory creation inspired by the Autoconf team.
 
-set_cc_for_build='
-trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
-trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
-: ${TMPDIR=/tmp} ;
- { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
- { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
- { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
- { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
-dummy=$tmp/dummy ;
-tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
-case $CC_FOR_BUILD,$HOST_CC,$CC in
- ,,)    echo "int x;" > $dummy.c ;
-	for c in cc gcc c89 c99 ; do
-	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
-	     CC_FOR_BUILD="$c"; break ;
-	  fi ;
-	done ;
-	if test x"$CC_FOR_BUILD" = x ; then
-	  CC_FOR_BUILD=no_compiler_found ;
-	fi
-	;;
- ,,*)   CC_FOR_BUILD=$CC ;;
- ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac ; set_cc_for_build= ;'
+tmp=
+# shellcheck disable=SC2172
+trap 'test -z "$tmp" || rm -fr "$tmp"' 0 1 2 13 15
+
+set_cc_for_build() {
+    : "${TMPDIR=/tmp}"
+    # shellcheck disable=SC2039
+    { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+	{ test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir "$tmp" 2>/dev/null) ; } ||
+	{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir "$tmp" 2>/dev/null) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+	{ echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; }
+    dummy=$tmp/dummy
+    case ${CC_FOR_BUILD-},${HOST_CC-},${CC-} in
+	,,)    echo "int x;" > "$dummy.c"
+	       for driver in cc gcc c89 c99 ; do
+		   if ($driver -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
+		       CC_FOR_BUILD="$driver"
+		       break
+		   fi
+	       done
+	       if test x"$CC_FOR_BUILD" = x ; then
+		   CC_FOR_BUILD=no_compiler_found
+	       fi
+	       ;;
+	,,*)   CC_FOR_BUILD=$CC ;;
+	,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+    esac
+}
 
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
 # (ghazi@noc.rutgers.edu 1994-08-24)
-if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+if test -f /.attbin/uname ; then
 	PATH=$PATH:/.attbin ; export PATH
 fi
 
@@ -140,12 +134,40 @@
 UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
+case "$UNAME_SYSTEM" in
+Linux|GNU|GNU/*)
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	LIBC=gnu
+
+	set_cc_for_build
+	cat <<-EOF > "$dummy.c"
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#else
+	LIBC=gnu
+	#endif
+	EOF
+	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`"
+
+	# If ldd exists, use it to detect musl libc.
+	if command -v ldd >/dev/null && \
+		ldd --version 2>&1 | grep -q ^musl
+	then
+	    LIBC=musl
+	fi
+	;;
+esac
+
 # Note: order is significant - the case branches are not exclusive.
 
-case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
     *:NetBSD:*:*)
 	# NetBSD (nbsd) targets should (where applicable) match one or
-	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
 	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
 	# switched to ELF, *-*-netbsd* would select the old
 	# object file format.  This provides both forward
@@ -155,21 +177,31 @@
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
 	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
-	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
-	case "${UNAME_MACHINE_ARCH}" in
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+	    "/sbin/$sysctl" 2>/dev/null || \
+	    "/usr/sbin/$sysctl" 2>/dev/null || \
+	    echo unknown)`
+	case "$UNAME_MACHINE_ARCH" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
-	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
+	    earmv*)
+		arch=`echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine="${arch}${endian}"-unknown
+		;;
+	    *) machine="$UNAME_MACHINE_ARCH"-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
-	# to ELF recently, or will in the future.
-	case "${UNAME_MACHINE_ARCH}" in
+	# to ELF recently (or will in the future) and ABI.
+	case "$UNAME_MACHINE_ARCH" in
+	    earm*)
+		os=netbsdelf
+		;;
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
-		eval $set_cc_for_build
+		set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
 			| grep -q __ELF__
 		then
@@ -184,40 +216,67 @@
 		os=netbsd
 		;;
 	esac
+	# Determine ABI tags.
+	case "$UNAME_MACHINE_ARCH" in
+	    earm*)
+		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+		abi=`echo "$UNAME_MACHINE_ARCH" | sed -e "$expr"`
+		;;
+	esac
 	# The OS release
 	# Debian GNU/NetBSD machines have a different userland, and
 	# thus, need a distinct triplet. However, they do not need
 	# kernel version information, so it can be replaced with a
 	# suitable tag, in the style of linux-gnu.
-	case "${UNAME_VERSION}" in
+	case "$UNAME_VERSION" in
 	    Debian*)
 		release='-gnu'
 		;;
 	    *)
-		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		release=`echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
+	echo "$machine-${os}${release}${abi-}"
+	exit ;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	echo "$UNAME_MACHINE_ARCH"-unknown-bitrig"$UNAME_RELEASE"
 	exit ;;
     *:OpenBSD:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
-	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+	echo "$UNAME_MACHINE_ARCH"-unknown-openbsd"$UNAME_RELEASE"
+	exit ;;
+    *:LibertyBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	echo "$UNAME_MACHINE_ARCH"-unknown-libertybsd"$UNAME_RELEASE"
+	exit ;;
+    *:MidnightBSD:*:*)
+	echo "$UNAME_MACHINE"-unknown-midnightbsd"$UNAME_RELEASE"
 	exit ;;
     *:ekkoBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-unknown-ekkobsd"$UNAME_RELEASE"
 	exit ;;
     *:SolidBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-unknown-solidbsd"$UNAME_RELEASE"
 	exit ;;
     macppc:MirBSD:*:*)
-	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
+	echo powerpc-unknown-mirbsd"$UNAME_RELEASE"
 	exit ;;
     *:MirBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-unknown-mirbsd"$UNAME_RELEASE"
+	exit ;;
+    *:Sortix:*:*)
+	echo "$UNAME_MACHINE"-unknown-sortix
+	exit ;;
+    *:Redox:*:*)
+	echo "$UNAME_MACHINE"-unknown-redox
 	exit ;;
+    mips:OSF1:*.*)
+        echo mips-dec-osf1
+        exit ;;
     alpha:OSF1:*:*)
 	case $UNAME_RELEASE in
 	*4.0)
@@ -234,63 +293,54 @@
 	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
 	case "$ALPHA_CPU_TYPE" in
 	    "EV4 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV4.5 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "LCA4 (21066/21068)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV5 (21164)")
-		UNAME_MACHINE="alphaev5" ;;
+		UNAME_MACHINE=alphaev5 ;;
 	    "EV5.6 (21164A)")
-		UNAME_MACHINE="alphaev56" ;;
+		UNAME_MACHINE=alphaev56 ;;
 	    "EV5.6 (21164PC)")
-		UNAME_MACHINE="alphapca56" ;;
+		UNAME_MACHINE=alphapca56 ;;
 	    "EV5.7 (21164PC)")
-		UNAME_MACHINE="alphapca57" ;;
+		UNAME_MACHINE=alphapca57 ;;
 	    "EV6 (21264)")
-		UNAME_MACHINE="alphaev6" ;;
+		UNAME_MACHINE=alphaev6 ;;
 	    "EV6.7 (21264A)")
-		UNAME_MACHINE="alphaev67" ;;
+		UNAME_MACHINE=alphaev67 ;;
 	    "EV6.8CB (21264C)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8AL (21264B)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8CX (21264D)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.9A (21264/EV69A)")
-		UNAME_MACHINE="alphaev69" ;;
+		UNAME_MACHINE=alphaev69 ;;
 	    "EV7 (21364)")
-		UNAME_MACHINE="alphaev7" ;;
+		UNAME_MACHINE=alphaev7 ;;
 	    "EV7.9 (21364A)")
-		UNAME_MACHINE="alphaev79" ;;
+		UNAME_MACHINE=alphaev79 ;;
 	esac
 	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	echo "$UNAME_MACHINE"-dec-osf"`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`"
 	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
 	exitcode=$?
 	trap '' 0
 	exit $exitcode ;;
-    Alpha\ *:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# Should we change UNAME_MACHINE based on the output of uname instead
-	# of the specific Alpha model?
-	echo alpha-pc-interix
-	exit ;;
-    21064:Windows_NT:50:3)
-	echo alpha-dec-winnt3.5
-	exit ;;
     Amiga*:UNIX_System_V:4.0:*)
 	echo m68k-unknown-sysv4
 	exit ;;
     *:[Aa]miga[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-amigaos
+	echo "$UNAME_MACHINE"-unknown-amigaos
 	exit ;;
     *:[Mm]orph[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-morphos
+	echo "$UNAME_MACHINE"-unknown-morphos
 	exit ;;
     *:OS/390:*:*)
 	echo i370-ibm-openedition
@@ -302,9 +352,9 @@
 	echo powerpc-ibm-os400
 	exit ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
-	echo arm-acorn-riscix${UNAME_RELEASE}
+	echo arm-acorn-riscix"$UNAME_RELEASE"
 	exit ;;
-    arm:riscos:*:*|arm:RISCOS:*:*)
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
 	echo arm-unknown-riscos
 	exit ;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
@@ -329,38 +379,38 @@
 	    sparc) echo sparc-icl-nx7; exit ;;
 	esac ;;
     s390x:SunOS:*:*)
-	echo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	echo "$UNAME_MACHINE"-ibm-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
 	exit ;;
     sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	echo sparc-hal-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
 	exit ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
-	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	echo sparc-sun-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
 	exit ;;
     i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
-	echo i386-pc-auroraux${UNAME_RELEASE}
+	echo i386-pc-auroraux"$UNAME_RELEASE"
 	exit ;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
-	eval $set_cc_for_build
-	SUN_ARCH="i386"
+	set_cc_for_build
+	SUN_ARCH=i386
 	# If there is a compiler, see if it is configured for 64-bit objects.
 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
 	# This test works for both compilers.
-	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
 	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		grep IS_64BIT_ARCH >/dev/null
 	    then
-		SUN_ARCH="x86_64"
+		SUN_ARCH=x86_64
 	    fi
 	fi
-	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	echo "$SUN_ARCH"-pc-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
 	exit ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
-	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	echo sparc-sun-solaris3"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
 	exit ;;
     sun4*:SunOS:*:*)
 	case "`/usr/bin/arch -k`" in
@@ -369,25 +419,25 @@
 		;;
 	esac
 	# Japanese Language versions have a version number like `4.1.3-JL'.
-	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+	echo sparc-sun-sunos"`echo "$UNAME_RELEASE"|sed -e 's/-/_/'`"
 	exit ;;
     sun3*:SunOS:*:*)
-	echo m68k-sun-sunos${UNAME_RELEASE}
+	echo m68k-sun-sunos"$UNAME_RELEASE"
 	exit ;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
-	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	test "x$UNAME_RELEASE" = x && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
-		echo m68k-sun-sunos${UNAME_RELEASE}
+		echo m68k-sun-sunos"$UNAME_RELEASE"
 		;;
 	    sun4)
-		echo sparc-sun-sunos${UNAME_RELEASE}
+		echo sparc-sun-sunos"$UNAME_RELEASE"
 		;;
 	esac
 	exit ;;
     aushp:SunOS:*:*)
-	echo sparc-auspex-sunos${UNAME_RELEASE}
+	echo sparc-auspex-sunos"$UNAME_RELEASE"
 	exit ;;
     # The situation for MiNT is a little confusing.  The machine name
     # can be virtually everything (everything which is not
@@ -398,44 +448,44 @@
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
+	echo m68k-atari-mint"$UNAME_RELEASE"
 	exit ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
+	echo m68k-atari-mint"$UNAME_RELEASE"
 	exit ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
+	echo m68k-atari-mint"$UNAME_RELEASE"
 	exit ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-	echo m68k-milan-mint${UNAME_RELEASE}
+	echo m68k-milan-mint"$UNAME_RELEASE"
 	exit ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-	echo m68k-hades-mint${UNAME_RELEASE}
+	echo m68k-hades-mint"$UNAME_RELEASE"
 	exit ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-	echo m68k-unknown-mint${UNAME_RELEASE}
+	echo m68k-unknown-mint"$UNAME_RELEASE"
 	exit ;;
     m68k:machten:*:*)
-	echo m68k-apple-machten${UNAME_RELEASE}
+	echo m68k-apple-machten"$UNAME_RELEASE"
 	exit ;;
     powerpc:machten:*:*)
-	echo powerpc-apple-machten${UNAME_RELEASE}
+	echo powerpc-apple-machten"$UNAME_RELEASE"
 	exit ;;
     RISC*:Mach:*:*)
 	echo mips-dec-mach_bsd4.3
 	exit ;;
     RISC*:ULTRIX:*:*)
-	echo mips-dec-ultrix${UNAME_RELEASE}
+	echo mips-dec-ultrix"$UNAME_RELEASE"
 	exit ;;
     VAX*:ULTRIX*:*:*)
-	echo vax-dec-ultrix${UNAME_RELEASE}
+	echo vax-dec-ultrix"$UNAME_RELEASE"
 	exit ;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
-	echo clipper-intergraph-clix${UNAME_RELEASE}
+	echo clipper-intergraph-clix"$UNAME_RELEASE"
 	exit ;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
+	set_cc_for_build
+	sed 's/^	//' << EOF > "$dummy.c"
 #ifdef __cplusplus
 #include <stdio.h>  /* for printf() prototype */
 	int main (int argc, char *argv[]) {
@@ -444,23 +494,23 @@
 #endif
 	#if defined (host_mips) && defined (MIPSEB)
 	#if defined (SYSTYPE_SYSV)
-	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	  printf ("mips-mips-riscos%ssysv\\n", argv[1]); exit (0);
 	#endif
 	#if defined (SYSTYPE_SVR4)
-	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	  printf ("mips-mips-riscos%ssvr4\\n", argv[1]); exit (0);
 	#endif
 	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
-	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	  printf ("mips-mips-riscos%sbsd\\n", argv[1]); exit (0);
 	#endif
 	#endif
 	  exit (-1);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c &&
-	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
-	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" &&
+	  dummyarg=`echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`"$dummy" "$dummyarg"` &&
 	    { echo "$SYSTEM_NAME"; exit; }
-	echo mips-mips-riscos${UNAME_RELEASE}
+	echo mips-mips-riscos"$UNAME_RELEASE"
 	exit ;;
     Motorola:PowerMAX_OS:*:*)
 	echo powerpc-motorola-powermax
@@ -486,17 +536,17 @@
     AViiON:dgux:*:*)
 	# DG/UX returns AViiON for all architectures
 	UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
+	if [ "$UNAME_PROCESSOR" = mc88100 ] || [ "$UNAME_PROCESSOR" = mc88110 ]
 	then
-	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
-	       [ ${TARGET_BINARY_INTERFACE}x = x ]
+	    if [ "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx ] || \
+	       [ "$TARGET_BINARY_INTERFACE"x = x ]
 	    then
-		echo m88k-dg-dgux${UNAME_RELEASE}
+		echo m88k-dg-dgux"$UNAME_RELEASE"
 	    else
-		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+		echo m88k-dg-dguxbcs"$UNAME_RELEASE"
 	    fi
 	else
-	    echo i586-dg-dgux${UNAME_RELEASE}
+	    echo i586-dg-dgux"$UNAME_RELEASE"
 	fi
 	exit ;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
@@ -513,7 +563,7 @@
 	echo m68k-tektronix-bsd
 	exit ;;
     *:IRIX*:*:*)
-	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+	echo mips-sgi-irix"`echo "$UNAME_RELEASE"|sed -e 's/-/_/g'`"
 	exit ;;
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
 	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
@@ -525,14 +575,14 @@
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
 	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
 	fi
-	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
+	echo "$UNAME_MACHINE"-ibm-aix"$IBM_REV"
 	exit ;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
-		eval $set_cc_for_build
-		sed 's/^		//' << EOF >$dummy.c
+		set_cc_for_build
+		sed 's/^		//' << EOF > "$dummy.c"
 		#include <sys/systemcfg.h>
 
 		main()
@@ -543,7 +593,7 @@
 			exit(0);
 			}
 EOF
-		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"`
 		then
 			echo "$SYSTEM_NAME"
 		else
@@ -557,26 +607,27 @@
 	exit ;;
     *:AIX:*:[4567])
 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
-	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
+	if /usr/sbin/lsattr -El "$IBM_CPU_ID" | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
+	if [ -x /usr/bin/lslpp ] ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
 	fi
-	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+	echo "$IBM_ARCH"-ibm-aix"$IBM_REV"
 	exit ;;
     *:AIX:*:*)
 	echo rs6000-ibm-aix
 	exit ;;
-    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+    ibmrt:4.4BSD:*|romp-ibm:4.4BSD:*)
 	echo romp-ibm-bsd4.4
 	exit ;;
     ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
-	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	echo romp-ibm-bsd"$UNAME_RELEASE"   # 4.3 with uname added to
 	exit ;;                             # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
 	echo rs6000-bull-bosx
@@ -591,28 +642,28 @@
 	echo m68k-hp-bsd4.4
 	exit ;;
     9000/[34678]??:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	case "${UNAME_MACHINE}" in
-	    9000/31? )            HP_ARCH=m68000 ;;
-	    9000/[34]?? )         HP_ARCH=m68k ;;
+	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
+	case "$UNAME_MACHINE" in
+	    9000/31?)            HP_ARCH=m68000 ;;
+	    9000/[34]??)         HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
 		if [ -x /usr/bin/getconf ]; then
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
 		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
-		    case "${sc_cpu_version}" in
-		      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-		      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+		    case "$sc_cpu_version" in
+		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
 		      532)                      # CPU_PA_RISC2_0
-			case "${sc_kernel_bits}" in
-			  32) HP_ARCH="hppa2.0n" ;;
-			  64) HP_ARCH="hppa2.0w" ;;
-			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+			case "$sc_kernel_bits" in
+			  32) HP_ARCH=hppa2.0n ;;
+			  64) HP_ARCH=hppa2.0w ;;
+			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
 			esac ;;
 		    esac
 		fi
-		if [ "${HP_ARCH}" = "" ]; then
-		    eval $set_cc_for_build
-		    sed 's/^		//' << EOF >$dummy.c
+		if [ "$HP_ARCH" = "" ]; then
+		    set_cc_for_build
+		    sed 's/^		//' << EOF > "$dummy.c"
 
 		#define _HPUX_SOURCE
 		#include <stdlib.h>
@@ -645,13 +696,13 @@
 		    exit (0);
 		}
 EOF
-		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    (CCOPTS="" $CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null) && HP_ARCH=`"$dummy"`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
-	if [ ${HP_ARCH} = "hppa2.0w" ]
+	if [ "$HP_ARCH" = hppa2.0w ]
 	then
-	    eval $set_cc_for_build
+	    set_cc_for_build
 
 	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
 	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
@@ -662,23 +713,23 @@
 	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
 	    # => hppa64-hp-hpux11.23
 
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+	    if echo __LP64__ | (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) |
 		grep -q __LP64__
 	    then
-		HP_ARCH="hppa2.0w"
+		HP_ARCH=hppa2.0w
 	    else
-		HP_ARCH="hppa64"
+		HP_ARCH=hppa64
 	    fi
 	fi
-	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+	echo "$HP_ARCH"-hp-hpux"$HPUX_REV"
 	exit ;;
     ia64:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	echo ia64-hp-hpux${HPUX_REV}
+	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
+	echo ia64-hp-hpux"$HPUX_REV"
 	exit ;;
     3050*:HI-UX:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
+	set_cc_for_build
+	sed 's/^	//' << EOF > "$dummy.c"
 	#include <unistd.h>
 	int
 	main ()
@@ -703,11 +754,11 @@
 	  exit (0);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"` &&
 		{ echo "$SYSTEM_NAME"; exit; }
 	echo unknown-hitachi-hiuxwe2
 	exit ;;
-    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)
 	echo hppa1.1-hp-bsd
 	exit ;;
     9000/8??:4.3bsd:*:*)
@@ -716,7 +767,7 @@
     *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
 	echo hppa1.0-hp-mpeix
 	exit ;;
-    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)
 	echo hppa1.1-hp-osf
 	exit ;;
     hp8??:OSF1:*:*)
@@ -724,9 +775,9 @@
 	exit ;;
     i*86:OSF1:*:*)
 	if [ -x /usr/sbin/sysversion ] ; then
-	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	    echo "$UNAME_MACHINE"-unknown-osf1mk
 	else
-	    echo ${UNAME_MACHINE}-unknown-osf1
+	    echo "$UNAME_MACHINE"-unknown-osf1
 	fi
 	exit ;;
     parisc*:Lites*:*:*)
@@ -751,117 +802,120 @@
 	echo c4-convex-bsd
 	exit ;;
     CRAY*Y-MP:*:*:*)
-	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo ymp-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*[A-Z]90:*:*:*)
-	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	echo "$UNAME_MACHINE"-cray-unicos"$UNAME_RELEASE" \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
 	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
 	      -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*TS:*:*:*)
-	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo t90-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*T3E:*:*:*)
-	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo alphaev5-cray-unicosmk"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*SV1:*:*:*)
-	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo sv1-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     *:UNICOS/mp:*:*)
-	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo craynv-cray-unicosmp"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | sed -e 's/ /_/'`
 	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     5000:UNIX_System_V:4.*:*)
-	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
 	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
-	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-pc-bsdi"$UNAME_RELEASE"
 	exit ;;
     sparc*:BSD/OS:*:*)
-	echo sparc-unknown-bsdi${UNAME_RELEASE}
+	echo sparc-unknown-bsdi"$UNAME_RELEASE"
 	exit ;;
     *:BSD/OS:*:*)
-	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-unknown-bsdi"$UNAME_RELEASE"
+	exit ;;
+    arm:FreeBSD:*:*)
+	UNAME_PROCESSOR=`uname -p`
+	set_cc_for_build
+	if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_PCS_VFP
+	then
+	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabi
+	else
+	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabihf
+	fi
 	exit ;;
     *:FreeBSD:*:*)
 	UNAME_PROCESSOR=`/usr/bin/uname -p`
-	case ${UNAME_PROCESSOR} in
+	case "$UNAME_PROCESSOR" in
 	    amd64)
-		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
-	    *)
-		echo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+		UNAME_PROCESSOR=x86_64 ;;
+	    i386)
+		UNAME_PROCESSOR=i586 ;;
 	esac
+	echo "$UNAME_PROCESSOR"-unknown-freebsd"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
 	exit ;;
     i*:CYGWIN*:*)
-	echo ${UNAME_MACHINE}-pc-cygwin
+	echo "$UNAME_MACHINE"-pc-cygwin
 	exit ;;
-    *:MINGW*:*)
-	echo ${UNAME_MACHINE}-pc-mingw32
+    *:MINGW64*:*)
+	echo "$UNAME_MACHINE"-pc-mingw64
 	exit ;;
-    i*:MSYS*:*)
-	echo ${UNAME_MACHINE}-pc-msys
+    *:MINGW*:*)
+	echo "$UNAME_MACHINE"-pc-mingw32
 	exit ;;
-    i*:windows32*:*)
-	# uname -m includes "-pc" on this system.
-	echo ${UNAME_MACHINE}-mingw32
+    *:MSYS*:*)
+	echo "$UNAME_MACHINE"-pc-msys
 	exit ;;
     i*:PW*:*)
-	echo ${UNAME_MACHINE}-pc-pw32
+	echo "$UNAME_MACHINE"-pc-pw32
 	exit ;;
     *:Interix*:*)
-	case ${UNAME_MACHINE} in
+	case "$UNAME_MACHINE" in
 	    x86)
-		echo i586-pc-interix${UNAME_RELEASE}
+		echo i586-pc-interix"$UNAME_RELEASE"
 		exit ;;
 	    authenticamd | genuineintel | EM64T)
-		echo x86_64-unknown-interix${UNAME_RELEASE}
+		echo x86_64-unknown-interix"$UNAME_RELEASE"
 		exit ;;
 	    IA64)
-		echo ia64-unknown-interix${UNAME_RELEASE}
+		echo ia64-unknown-interix"$UNAME_RELEASE"
 		exit ;;
 	esac ;;
-    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
-	echo i${UNAME_MACHINE}-pc-mks
-	exit ;;
-    8664:Windows_NT:*)
-	echo x86_64-pc-mks
-	exit ;;
-    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
-	# UNAME_MACHINE based on the output of uname instead of i386?
-	echo i586-pc-interix
-	exit ;;
     i*:UWIN*:*)
-	echo ${UNAME_MACHINE}-pc-uwin
+	echo "$UNAME_MACHINE"-pc-uwin
 	exit ;;
     amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
-	echo x86_64-unknown-cygwin
-	exit ;;
-    p*:CYGWIN*:*)
-	echo powerpcle-unknown-cygwin
+	echo x86_64-pc-cygwin
 	exit ;;
     prep*:SunOS:5.*:*)
-	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	echo powerpcle-unknown-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
 	exit ;;
     *:GNU:*:*)
 	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	echo "`echo "$UNAME_MACHINE"|sed -e 's,[-/].*$,,'`-unknown-$LIBC`echo "$UNAME_RELEASE"|sed -e 's,/.*$,,'`"
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	echo "$UNAME_MACHINE-unknown-`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`-$LIBC"
 	exit ;;
-    i*86:Minix:*:*)
-	echo ${UNAME_MACHINE}-pc-minix
+    *:Minix:*:*)
+	echo "$UNAME_MACHINE"-unknown-minix
+	exit ;;
+    aarch64:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    aarch64_be:Linux:*:*)
+	UNAME_MACHINE=aarch64_be
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
@@ -874,125 +928,169 @@
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
 	esac
 	objdump --private-headers /bin/sh | grep -q ld.so.1
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    arc:Linux:*:* | arceb:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     arm*:Linux:*:*)
-	eval $set_cc_for_build
+	set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
-	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	    echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	else
 	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
 		| grep -q __ARM_PCS_VFP
 	    then
-		echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabi
 	    else
-		echo ${UNAME_MACHINE}-unknown-linux-gnueabihf
+		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabihf
 	    fi
 	fi
 	exit ;;
     avr32*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     cris:Linux:*:*)
-	echo ${UNAME_MACHINE}-axis-linux-gnu
+	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
 	exit ;;
     crisv32:Linux:*:*)
-	echo ${UNAME_MACHINE}-axis-linux-gnu
+	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
+	exit ;;
+    e2k:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     frv:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     hexagon:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     i*86:Linux:*:*)
-	LIBC=gnu
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
-	echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+	echo "$UNAME_MACHINE"-pc-linux-"$LIBC"
 	exit ;;
     ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    k1om:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     mips:Linux:*:* | mips64:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
+	set_cc_for_build
+	IS_GLIBC=0
+	test x"${LIBC}" = xgnu && IS_GLIBC=1
+	sed 's/^	//' << EOF > "$dummy.c"
 	#undef CPU
-	#undef ${UNAME_MACHINE}
-	#undef ${UNAME_MACHINE}el
+	#undef mips
+	#undef mipsel
+	#undef mips64
+	#undef mips64el
+	#if ${IS_GLIBC} && defined(_ABI64)
+	LIBCABI=gnuabi64
+	#else
+	#if ${IS_GLIBC} && defined(_ABIN32)
+	LIBCABI=gnuabin32
+	#else
+	LIBCABI=${LIBC}
+	#endif
+	#endif
+
+	#if ${IS_GLIBC} && defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa64r6
+	#else
+	#if ${IS_GLIBC} && !defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa32r6
+	#else
+	#if defined(__mips64)
+	CPU=mips64
+	#else
+	CPU=mips
+	#endif
+	#endif
+	#endif
+
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=${UNAME_MACHINE}el
+	MIPS_ENDIAN=el
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=${UNAME_MACHINE}
+	MIPS_ENDIAN=
 	#else
-	CPU=
+	MIPS_ENDIAN=
 	#endif
 	#endif
 EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI'`"
+	test "x$CPU" != x && { echo "$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI"; exit; }
 	;;
-    or32:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+    mips64el:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    openrisc*:Linux:*:*)
+	echo or1k-unknown-linux-"$LIBC"
+	exit ;;
+    or32:Linux:*:* | or1k*:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     padre:Linux:*:*)
-	echo sparc-unknown-linux-gnu
+	echo sparc-unknown-linux-"$LIBC"
 	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
+	echo hppa64-unknown-linux-"$LIBC"
 	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
+	  PA7*) echo hppa1.1-unknown-linux-"$LIBC" ;;
+	  PA8*) echo hppa2.0-unknown-linux-"$LIBC" ;;
+	  *)    echo hppa-unknown-linux-"$LIBC" ;;
 	esac
 	exit ;;
     ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
+	echo powerpc64-unknown-linux-"$LIBC"
 	exit ;;
     ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
+	echo powerpc-unknown-linux-"$LIBC"
+	exit ;;
+    ppc64le:Linux:*:*)
+	echo powerpc64le-unknown-linux-"$LIBC"
+	exit ;;
+    ppcle:Linux:*:*)
+	echo powerpcle-unknown-linux-"$LIBC"
+	exit ;;
+    riscv32:Linux:*:* | riscv64:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
+	echo "$UNAME_MACHINE"-ibm-linux-"$LIBC"
 	exit ;;
     sh64*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     tile*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     vax:Linux:*:*)
-	echo ${UNAME_MACHINE}-dec-linux-gnu
+	echo "$UNAME_MACHINE"-dec-linux-"$LIBC"
 	exit ;;
     x86_64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-pc-linux-"$LIBC"
 	exit ;;
     xtensa*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
@@ -1006,34 +1104,34 @@
 	# I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
 	# Use sysv4.2uw... so that sysv4* matches it.
-	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
+	echo "$UNAME_MACHINE"-pc-sysv4.2uw"$UNAME_VERSION"
 	exit ;;
     i*86:OS/2:*:*)
 	# If we were able to find `uname', then EMX Unix compatibility
 	# is probably installed.
-	echo ${UNAME_MACHINE}-pc-os2-emx
+	echo "$UNAME_MACHINE"-pc-os2-emx
 	exit ;;
     i*86:XTS-300:*:STOP)
-	echo ${UNAME_MACHINE}-unknown-stop
+	echo "$UNAME_MACHINE"-unknown-stop
 	exit ;;
     i*86:atheos:*:*)
-	echo ${UNAME_MACHINE}-unknown-atheos
+	echo "$UNAME_MACHINE"-unknown-atheos
 	exit ;;
     i*86:syllable:*:*)
-	echo ${UNAME_MACHINE}-pc-syllable
+	echo "$UNAME_MACHINE"-pc-syllable
 	exit ;;
     i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
-	echo i386-unknown-lynxos${UNAME_RELEASE}
+	echo i386-unknown-lynxos"$UNAME_RELEASE"
 	exit ;;
     i*86:*DOS:*:*)
-	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+	echo "$UNAME_MACHINE"-pc-msdosdjgpp
 	exit ;;
-    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
-	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+    i*86:*:4.*:*)
+	UNAME_REL=`echo "$UNAME_RELEASE" | sed 's/\/MP$//'`
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
-		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
+		echo "$UNAME_MACHINE"-univel-sysv"$UNAME_REL"
 	else
-		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+		echo "$UNAME_MACHINE"-pc-sysv"$UNAME_REL"
 	fi
 	exit ;;
     i*86:*:5:[678]*)
@@ -1043,12 +1141,12 @@
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
 	esac
-	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	echo "$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}"
 	exit ;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
-		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+		echo "$UNAME_MACHINE"-pc-isc"$UNAME_REL"
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
 		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
 		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
@@ -1058,9 +1156,9 @@
 			&& UNAME_MACHINE=i686
 		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
 			&& UNAME_MACHINE=i686
-		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+		echo "$UNAME_MACHINE"-pc-sco"$UNAME_REL"
 	else
-		echo ${UNAME_MACHINE}-pc-sysv32
+		echo "$UNAME_MACHINE"-pc-sysv32
 	fi
 	exit ;;
     pc:*:*:*)
@@ -1068,7 +1166,7 @@
 	# uname -m prints for DJGPP always 'pc', but it prints nothing about
 	# the processor, so we play safe by assuming i586.
 	# Note: whatever this is, it MUST be the same as what config.sub
-	# prints for the "djgpp" host, or else GDB configury will decide that
+	# prints for the "djgpp" host, or else GDB configure will decide that
 	# this is a cross-build.
 	echo i586-pc-msdosdjgpp
 	exit ;;
@@ -1080,9 +1178,9 @@
 	exit ;;
     i860:*:4.*:*) # i860-SVR4
 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
-	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	  echo i860-stardent-sysv"$UNAME_RELEASE" # Stardent Vistra i860-SVR4
 	else # Add other i860-SVR4 vendors below as they are discovered.
-	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	  echo i860-unknown-sysv"$UNAME_RELEASE"  # Unknown i860-SVR4
 	fi
 	exit ;;
     mini*:CTIX:SYS*5:*)
@@ -1102,9 +1200,9 @@
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	  && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+	  && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
 	  && { echo i486-ncr-sysv4; exit; } ;;
@@ -1113,28 +1211,28 @@
 	test -r /etc/.relid \
 	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	    && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }
+	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
-	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
-	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	echo m68k-unknown-lynxos"$UNAME_RELEASE"
 	exit ;;
     mc68030:UNIX_System_V:4.*:*)
 	echo m68k-atari-sysv4
 	exit ;;
     TSUNAMI:LynxOS:2.*:*)
-	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	echo sparc-unknown-lynxos"$UNAME_RELEASE"
 	exit ;;
     rs6000:LynxOS:2.*:*)
-	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	echo rs6000-unknown-lynxos"$UNAME_RELEASE"
 	exit ;;
     PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
-	echo powerpc-unknown-lynxos${UNAME_RELEASE}
+	echo powerpc-unknown-lynxos"$UNAME_RELEASE"
 	exit ;;
     SM[BE]S:UNIX_SV:*:*)
-	echo mips-dde-sysv${UNAME_RELEASE}
+	echo mips-dde-sysv"$UNAME_RELEASE"
 	exit ;;
     RM*:ReliantUNIX-*:*:*)
 	echo mips-sni-sysv4
@@ -1145,7 +1243,7 @@
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
-		echo ${UNAME_MACHINE}-sni-sysv4
+		echo "$UNAME_MACHINE"-sni-sysv4
 	else
 		echo ns32k-sni-sysv
 	fi
@@ -1165,23 +1263,23 @@
 	exit ;;
     i*86:VOS:*:*)
 	# From Paul.Green@stratus.com.
-	echo ${UNAME_MACHINE}-stratus-vos
+	echo "$UNAME_MACHINE"-stratus-vos
 	exit ;;
     *:VOS:*:*)
 	# From Paul.Green@stratus.com.
 	echo hppa1.1-stratus-vos
 	exit ;;
     mc68*:A/UX:*:*)
-	echo m68k-apple-aux${UNAME_RELEASE}
+	echo m68k-apple-aux"$UNAME_RELEASE"
 	exit ;;
     news*:NEWS-OS:6*:*)
 	echo mips-sony-newsos6
 	exit ;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
 	if [ -d /usr/nec ]; then
-		echo mips-nec-sysv${UNAME_RELEASE}
+		echo mips-nec-sysv"$UNAME_RELEASE"
 	else
-		echo mips-unknown-sysv${UNAME_RELEASE}
+		echo mips-unknown-sysv"$UNAME_RELEASE"
 	fi
 	exit ;;
     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
@@ -1196,66 +1294,97 @@
     BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
 	echo i586-pc-haiku
 	exit ;;
+    x86_64:Haiku:*:*)
+	echo x86_64-unknown-haiku
+	exit ;;
     SX-4:SUPER-UX:*:*)
-	echo sx4-nec-superux${UNAME_RELEASE}
+	echo sx4-nec-superux"$UNAME_RELEASE"
 	exit ;;
     SX-5:SUPER-UX:*:*)
-	echo sx5-nec-superux${UNAME_RELEASE}
+	echo sx5-nec-superux"$UNAME_RELEASE"
 	exit ;;
     SX-6:SUPER-UX:*:*)
-	echo sx6-nec-superux${UNAME_RELEASE}
+	echo sx6-nec-superux"$UNAME_RELEASE"
 	exit ;;
     SX-7:SUPER-UX:*:*)
-	echo sx7-nec-superux${UNAME_RELEASE}
+	echo sx7-nec-superux"$UNAME_RELEASE"
 	exit ;;
     SX-8:SUPER-UX:*:*)
-	echo sx8-nec-superux${UNAME_RELEASE}
+	echo sx8-nec-superux"$UNAME_RELEASE"
 	exit ;;
     SX-8R:SUPER-UX:*:*)
-	echo sx8r-nec-superux${UNAME_RELEASE}
+	echo sx8r-nec-superux"$UNAME_RELEASE"
+	exit ;;
+    SX-ACE:SUPER-UX:*:*)
+	echo sxace-nec-superux"$UNAME_RELEASE"
 	exit ;;
     Power*:Rhapsody:*:*)
-	echo powerpc-apple-rhapsody${UNAME_RELEASE}
+	echo powerpc-apple-rhapsody"$UNAME_RELEASE"
 	exit ;;
     *:Rhapsody:*:*)
-	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-apple-rhapsody"$UNAME_RELEASE"
 	exit ;;
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    i386)
-		eval $set_cc_for_build
-		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		      grep IS_64BIT_ARCH >/dev/null
-		  then
-		      UNAME_PROCESSOR="x86_64"
-		  fi
-		fi ;;
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
-	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
+	set_cc_for_build
+	if test "$UNAME_PROCESSOR" = unknown ; then
+	    UNAME_PROCESSOR=powerpc
+	fi
+	if test "`echo "$UNAME_RELEASE" | sed -e 's/\..*//'`" -le 10 ; then
+	    if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		       grep IS_64BIT_ARCH >/dev/null
+		then
+		    case $UNAME_PROCESSOR in
+			i386) UNAME_PROCESSOR=x86_64 ;;
+			powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		    esac
+		fi
+		# On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
+		if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
+		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		       grep IS_PPC >/dev/null
+		then
+		    UNAME_PROCESSOR=powerpc
+		fi
+	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # Avoid executing cc on OS X 10.9, as it ships with a stub
+	    # that puts up a graphical alert prompting to install
+	    # developer tools.  Any system running Mac OS X 10.7 or
+	    # later (Darwin 11 and later) is required to have a 64-bit
+	    # processor. This is not true of the ARM version of Darwin
+	    # that Apple uses in portable devices.
+	    UNAME_PROCESSOR=x86_64
+	fi
+	echo "$UNAME_PROCESSOR"-apple-darwin"$UNAME_RELEASE"
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
-	if test "$UNAME_PROCESSOR" = "x86"; then
+	if test "$UNAME_PROCESSOR" = x86; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
-	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
+	echo "$UNAME_PROCESSOR"-"$UNAME_MACHINE"-nto-qnx"$UNAME_RELEASE"
 	exit ;;
     *:QNX:*:4*)
 	echo i386-pc-qnx
 	exit ;;
-    NEO-?:NONSTOP_KERNEL:*:*)
-	echo neo-tandem-nsk${UNAME_RELEASE}
+    NEO-*:NONSTOP_KERNEL:*:*)
+	echo neo-tandem-nsk"$UNAME_RELEASE"
+	exit ;;
+    NSE-*:NONSTOP_KERNEL:*:*)
+	echo nse-tandem-nsk"$UNAME_RELEASE"
+	exit ;;
+    NSR-*:NONSTOP_KERNEL:*:*)
+	echo nsr-tandem-nsk"$UNAME_RELEASE"
 	exit ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
-	echo nse-tandem-nsk${UNAME_RELEASE}
+    NSV-*:NONSTOP_KERNEL:*:*)
+	echo nsv-tandem-nsk"$UNAME_RELEASE"
 	exit ;;
-    NSR-?:NONSTOP_KERNEL:*:*)
-	echo nsr-tandem-nsk${UNAME_RELEASE}
+    NSX-*:NONSTOP_KERNEL:*:*)
+	echo nsx-tandem-nsk"$UNAME_RELEASE"
 	exit ;;
     *:NonStop-UX:*:*)
 	echo mips-compaq-nonstopux
@@ -1264,18 +1393,19 @@
 	echo bs2000-siemens-sysv
 	exit ;;
     DS/*:UNIX_System_V:*:*)
-	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-"$UNAME_SYSTEM"-"$UNAME_RELEASE"
 	exit ;;
     *:Plan9:*:*)
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
-	if test "$cputype" = "386"; then
+	# shellcheck disable=SC2154
+	if test "$cputype" = 386; then
 	    UNAME_MACHINE=i386
 	else
 	    UNAME_MACHINE="$cputype"
 	fi
-	echo ${UNAME_MACHINE}-unknown-plan9
+	echo "$UNAME_MACHINE"-unknown-plan9
 	exit ;;
     *:TOPS-10:*:*)
 	echo pdp10-unknown-tops10
@@ -1296,14 +1426,14 @@
 	echo pdp10-unknown-its
 	exit ;;
     SEI:*:*:SEIUX)
-	echo mips-sei-seiux${UNAME_RELEASE}
+	echo mips-sei-seiux"$UNAME_RELEASE"
 	exit ;;
     *:DragonFly:*:*)
-	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	echo "$UNAME_MACHINE"-unknown-dragonfly"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
 	exit ;;
     *:*VMS:*:*)
 	UNAME_MACHINE=`(uname -p) 2>/dev/null`
-	case "${UNAME_MACHINE}" in
+	case "$UNAME_MACHINE" in
 	    A*) echo alpha-dec-vms ; exit ;;
 	    I*) echo ia64-dec-vms ; exit ;;
 	    V*) echo vax-dec-vms ; exit ;;
@@ -1312,24 +1442,39 @@
 	echo i386-pc-xenix
 	exit ;;
     i*86:skyos:*:*)
-	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	echo "$UNAME_MACHINE"-pc-skyos"`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`"
 	exit ;;
     i*86:rdos:*:*)
-	echo ${UNAME_MACHINE}-pc-rdos
+	echo "$UNAME_MACHINE"-pc-rdos
 	exit ;;
     i*86:AROS:*:*)
-	echo ${UNAME_MACHINE}-pc-aros
+	echo "$UNAME_MACHINE"-pc-aros
+	exit ;;
+    x86_64:VMkernel:*:*)
+	echo "$UNAME_MACHINE"-unknown-esx
+	exit ;;
+    amd64:Isilon\ OneFS:*:*)
+	echo x86_64-unknown-onefs
+	exit ;;
+    *:Unleashed:*:*)
+	echo "$UNAME_MACHINE"-unknown-unleashed"$UNAME_RELEASE"
 	exit ;;
 esac
 
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
-
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
+# No uname command or uname output not recognized.
+set_cc_for_build
+cat > "$dummy.c" <<EOF
 #ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
+#include <sys/types.h>
+#include <sys/utsname.h>
+#endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined (vax) || defined (__vax) || defined (__vax__) || defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#include <signal.h>
+#if defined(_SIZE_T_) || defined(SIGLOST)
+#include <sys/utsname.h>
+#endif
+#endif
 #endif
 main ()
 {
@@ -1342,20 +1487,12 @@
 #include <sys/param.h>
   printf ("m68k-sony-newsos%s\n",
 #ifdef NEWSOS4
-	"4"
+  "4"
 #else
-	""
-#endif
-	); exit (0);
+  ""
 #endif
+  ); exit (0);
 #endif
-
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
 #endif
 
 #if defined (NeXT)
@@ -1397,39 +1534,54 @@
 #endif
 
 #if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
+  struct utsname un;
 
+  uname(&un);
+  if (strncmp(un.version, "V2", 2) == 0) {
+    printf ("i386-sequent-ptx2\n"); exit (0);
+  }
+  if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+    printf ("i386-sequent-ptx1\n"); exit (0);
+  }
+  printf ("i386-sequent-ptx\n"); exit (0);
 #endif
 
 #if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
+#if !defined (ultrix)
+#include <sys/param.h>
+#if defined (BSD)
+#if BSD == 43
+  printf ("vax-dec-bsd4.3\n"); exit (0);
+#else
+#if BSD == 199006
+  printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#endif
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#else
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname un;
+  uname (&un);
+  printf ("vax-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("vax-dec-ultrix\n"); exit (0);
+#endif
+#endif
+#endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname *un;
+  uname (&un);
+  printf ("mips-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("mips-dec-ultrix\n"); exit (0);
+#endif  
+#endif
 #endif
 
 #if defined (alliant) && defined (i860)
@@ -1440,54 +1592,38 @@
 }
 EOF
 
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=`$dummy` &&
 	{ echo "$SYSTEM_NAME"; exit; }
 
 # Apollos put the system type in the environment.
+test -d /usr/apollo && { echo "$ISP-apollo-$SYSTYPE"; exit; }
 
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
+echo "$0: unable to guess system type" >&2
 
-# Convex versions that predate uname can use getsysinfo(1)
+case "$UNAME_MACHINE:$UNAME_SYSTEM" in
+    mips:Linux | mips64:Linux)
+	# If we got here on MIPS GNU/Linux, output extra information.
+	cat >&2 <<EOF
 
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-	exit ;;
-    c34*)
-	echo c34-convex-bsd
-	exit ;;
-    c38*)
-	echo c38-convex-bsd
-	exit ;;
-    c4*)
-	echo c4-convex-bsd
-	exit ;;
-    esac
-fi
+NOTE: MIPS GNU/Linux systems require a C compiler to fully recognize
+the system type. Please install a C compiler and try again.
+EOF
+	;;
+esac
 
 cat >&2 <<EOF
-$0: unable to guess system type
 
-This script, last modified $timestamp, has failed to recognize
-the operating system you are using. It is advised that you
-download the most up to date version of the config scripts from
+This script (version $timestamp), has failed to recognize the
+operating system you are using. If your script is old, overwrite *all*
+copies of config.guess and config.sub with the latest versions from:
 
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
 and
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
 
-If the version you run ($0) is already up to date, please
-send the following data and any information you think might be
-pertinent to <config-patches@gnu.org> in order to provide the needed
-information to handle your system.
+If $0 has already been updated, send the following data and any
+information you think might be pertinent to config-patches@gnu.org to
+provide the necessary information to handle your system.
 
 config.guess timestamp = $timestamp
 
@@ -1506,16 +1642,16 @@
 /usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
 /usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
 
-UNAME_MACHINE = ${UNAME_MACHINE}
-UNAME_RELEASE = ${UNAME_RELEASE}
-UNAME_SYSTEM  = ${UNAME_SYSTEM}
-UNAME_VERSION = ${UNAME_VERSION}
+UNAME_MACHINE = "$UNAME_MACHINE"
+UNAME_RELEASE = "$UNAME_RELEASE"
+UNAME_SYSTEM  = "$UNAME_SYSTEM"
+UNAME_VERSION = "$UNAME_VERSION"
 EOF
 
 exit 1
 
 # Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
+# eval: (add-hook 'before-save-hook 'time-stamp)
 # time-stamp-start: "timestamp='"
 # time-stamp-format: "%:y-%02m-%02d"
 # time-stamp-end: "'"
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/Makefile ./AmberTools/src/Makefile
--- AmberTools/src/Makefile	2022-08-29 08:33:54.000000000 +0900
+++ ./AmberTools/src/Makefile	2022-05-05 14:56:45.000000000 +0900
@@ -42,7 +42,13 @@
 utils: configured_serial
 	@echo "Starting installation of ${AMBERTOOLS} serial at `date`".
 #	utility routines and libraries:
-	(cd ucpp-1.3 && $(MAKE) $(UCPP) )
+	(if [ "$(CXX)" = "FCC" ]; then \
+          (cd ucpp-1.3 && $(MAKE) AMBERBUILDFLAGS="--linkfortran" $(UCPP) );\
+        else\
+          (cd ucpp-1.3  && $(MAKE) $(UCPP) );\
+        fi;\
+        )
+
 	(cd arpack && $(MAKE) install )
 	(cd lapack && $(MAKE) $(LAPACK) )
 	(cd blas && $(MAKE) $(BLAS) )
@@ -100,7 +106,12 @@
 
 #   rism
 	(if [ "$(RISM)" = 'yes' ]; then \
-		cd rism && $(MAKE) rism3d.snglpnt$(SFX) ;\
+	  (if [[ "$(CC)" == *"fcc"* ]]; then \
+            (cd rism && $(MAKE) AMBERBUILDFLAGS="--linkfortran" rism3d.snglpnt$(SFX) );\
+          else\
+            (cd rism && $(MAKE) rism3d.snglpnt$(SFX) );\
+          fi;\
+          );\
 	fi ;\
 	)
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/ambpdb/CMakeLists.txt ./AmberTools/src/ambpdb/CMakeLists.txt
--- AmberTools/src/ambpdb/CMakeLists.txt	2022-08-29 08:41:27.000000000 +0900
+++ ./AmberTools/src/ambpdb/CMakeLists.txt	2022-08-15 11:24:23.000000000 +0900
@@ -1,3 +1,7 @@
+if( "${COMPILER}" STREQUAL "FUJITSU" )
+        add_link_options("--linkfortran")
+endif()
+
 set(AMBPDB_SOURCES 
 	AmbPDB.cpp 
 	DSL.cpp # dummy DataSetList implementation
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/ambpdb/Makefile ./AmberTools/src/ambpdb/Makefile
--- AmberTools/src/ambpdb/Makefile	2022-08-29 08:41:27.000000000 +0900
+++ ./AmberTools/src/ambpdb/Makefile	2022-05-05 14:56:46.000000000 +0900
@@ -31,8 +31,13 @@
 	mv ambpdb$(SFX) $(BINDIR)
 
 ambpdb: $(AMBPDB_OBJECTS) libcpptraj.static
-	@echo "[AMBPDB]  CXX $@"
-	$(VB)$(CXX) -o ambpdb$(SFX) $(AMBPDB_OBJECTS) $(LIBCPPTRAJ) $(NETCDFLIB) $(ZLIB) $(BZLIB) $(LDFLAGS)
+	$(VB)echo "[AMBPDB]  CXX $@"
+	(if [[ "$(CXX)" = *"-Nclang"* ]] ; then \
+	  $(CXX) -o ambpdb$(SFX) $(AMBPDB_OBJECTS) $(CXXFLAGS) --linkfortran $(LIBCPPTRAJ) $(NETCDFLIB) $(ZLIB) $(BZLIB) $(LDFLAGS);\
+	else\
+	  $(CXX) -o ambpdb$(SFX) $(AMBPDB_OBJECTS) $(LIBCPPTRAJ) $(NETCDFLIB) $(ZLIB) $(BZLIB) $(LDFLAGS);\
+	fi;\
+        )
 
 # Dependencies
 AmbPDB.o: AmbPDB.cpp Trajout_Single_Stdout.h
@@ -46,8 +51,8 @@
 #	@echo CXX $<
 #	@$(CXX) $(CXXFLAGS) -c -o $@ $<
 .cpp.o:
-	@echo "[AMBPDB]  CXX $<"
-	$(VB)$(CXX) -I$(CPPTRAJ_INCDIR) $(CXXOPTFLAGS) $(CXXFLAGS) -c -o $@ $<
+	$(VB)echo "[AMBPDB]  CXX $<"
+	$(CXX) -I$(CPPTRAJ_INCDIR) $(CXXOPTFLAGS) $(CXXFLAGS) $(LDFLAGS) -c -o $@ $<
 
 # Clean/uninstall targets
 clean:
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/arpack/CMakeLists.txt ./AmberTools/src/arpack/CMakeLists.txt
--- AmberTools/src/arpack/CMakeLists.txt	2022-08-29 08:28:36.000000000 +0900
+++ ./AmberTools/src/arpack/CMakeLists.txt	2022-08-29 11:39:49.000000000 +0900
@@ -1,4 +1,5 @@
 #AMBER CMake buildfile for arpack
+
 project(arpack C Fortran)
 
 set(FORTRAN_SOURCE ivout.f dvout.f dgetv0.f dlaqrb.f dnaitr.f dnapps.f 
@@ -23,4 +24,4 @@
 	target_link_libraries(arpack lapack blas)
 endif()
 
-install_libraries(arpack)
\ No newline at end of file
+install_libraries(arpack)
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/configure2 ./AmberTools/src/configure2
--- AmberTools/src/configure2	2022-08-29 08:27:43.000000000 +0900
+++ ./AmberTools/src/configure2	2022-05-19 10:20:09.000000000 +0900
@@ -22,6 +22,7 @@
       pgi        |    pgcc   |   pgc++   | pgf90     |   14.9, 15.4, 16.5
       clang      |    clang  |  clang++  | gfortran  |
       cray       |    cc     |   CC      | ftn       |   8.4.6*
+      a64fx      |    fc     |   FCC     | frt       |   4.1.0 20200226
     --------------------------------------------------------------------------
 EOD
 }
@@ -287,6 +288,11 @@
     else
       cc_version=`$cc $1 2>&1 | grep -E "$basecc |[vV]ersion " \
                   | sed -e 's/Open64//' -e 's/(.*)//' -e 's/^[a-zA-Z :]* //' -e 's/ .*//'`
+      if [ "${verbose}" = "" ]; then
+        echo "cc_version=`$cc $1 2>&1 | grep -E \"$basecc |[vV]ersion \" \
+                  | sed -e 's/Open64//' -e 's/^[a-zA-Z :]* //' -e 's/ .*//'`"
+        echo "C version: ${cc_version}"
+      fi
     fi
     if [ -z "$cc_version" ] ; then
        echo "Error: $cc is not well formed or produces unusual version details!"
@@ -335,6 +341,8 @@
       # Compilers on cygwin can print extra info
       fc_version=`$fc $1 2>&1 | grep -E "$basefc |$basecc |[vV]ersion " | grep -v cygwin | sed -e "s@$basefc @@" \
                   -e 's/Open64//' -e 's/^[a-zA-Z :]* //' -e 's/ .*//'`
+    elif [ "$a64fx" = 'yes' ] ; then
+      fc_version=`$fc $1 | grep -o -E "[0-9]*\.[0-9]*\.[0-9]"`
     else
       fc_version=`$fc $1 2>&1 | grep -E "$basefc |$basecc |[vV]ersion " | sed -e "s@$basefc @@" \
                   -e 's/Open64//' -e 's/^[a-zA-Z :]* //' -e 's/ .*//'`
@@ -642,6 +650,7 @@
 build_sanderapi='build_sanderapi'
 moft='yes'
 answer=''
+a64fx='no'
 #------------------------------------------------------------------------------
 #  Initialize variables that are controlled by environment variables:
 #------------------------------------------------------------------------------
@@ -770,7 +779,7 @@
         exit 1
     fi
     if [ ! -d $amberprefix/dat ]; then
-        mkdir "$amberprefix/dat"
+        mkdir  "$amberprefix/dat"
     fi
     if [ ! -d $amberprefix/AmberTools/src ]; then
         mkdir -p "$amberprefix/AmberTools/src"
@@ -789,7 +798,7 @@
     fi
 
     if [ ! -d $amberprefix/AmberTools/test ]; then
-        mkdir "$amberprefix/AmberTools/test"
+        mkdir  "$amberprefix/AmberTools/test"
         cwd=`pwd`
         echo "Creating symlink for $amberprefix/AmberTools/test"
         cd "$amberprefix/AmberTools/test"
@@ -1369,7 +1378,7 @@
     sm30flags='-gencode arch=compute_30,code=sm_30'
 
     cudaversion=`$nvcc --version | grep 'release' | cut -d' ' -f5 | cut -d',' -f1`
-    if [ "$cudaversion" = "11.0" -o "$cudaversion" = "11.1" ]; then
+    if [ "$cudaversion" = "11.0" -o "$cudaversion" = "11.1" -o "$cudaversion" = "11.2" -o "$cudaversion" = "11.4" ]; then
       # Implement the standard, not warp synchronous, compilation
       sm75flags='-gencode arch=compute_75,code=sm_75'
       sm70flags='-gencode arch=compute_70,code=sm_70'
@@ -2177,6 +2186,139 @@
 
     ;;
 
+#################### Fujitsu compilers on A64FX System #######
+a64fx)
+    if [ "$intelmpi" = 'yes' ]; then
+        echo "Intel MPI must be used with the Intel compilers."
+        exit 1
+    fi
+
+    a64fx='yes';
+
+    frt='yes';
+    sse='no';
+    intelmpi='no';
+    pic="-Kpic";
+    yacc='bison -y -Wno-yacc';
+    free_format=-Free;
+
+    pic=-fpic
+    fpic=-Kpic
+
+    # -fw Output only warning and serious error messages (no informative messages).
+    # -fs Output only serious error messages.
+    warnflag=
+    fwarnflag=-fs
+
+    flibs_arch=""
+    flibsf_arch=""
+    ldflags=" "
+    if [ -z "$CC" ]; then cc="fcc -Nclangi -fsigned-char"; else cc="$CC"; fi
+    cflags="$pic $CFLAGS -fsigned-char "
+    ambercflags=" -fsigned-char "
+    if [ -z "$CXX" ]; then cplusplus="FCC -Nclang -fsigned-char -stdlib=libc++ "; else cplusplus="$CXX"; fi
+    cxxflags="$pic $CXXFLAGS --linkfortran"
+    ambercxxflags=" "
+    cpptrajcxxflags=" "
+    cpptrajldflags=" "
+    if [ -z "$FC" ]; then fc=frt; else fc="$FC"; fi
+    ld="$fc"
+    fflags="-Ksimd_nouse_multiple_structures $fpic $fwarnflag $FFLAGS"
+
+    # If -noopt has been requested, force lack of optimisation;
+    # otherwise, use the default levels. Since cflags, cxxflags
+    # and fflags are used everywhere, and *optflags and
+    # *nooptflags are not (some parts of Amber and AmberTools use
+    # neither *optflags nor *nooptflags), we'll put -O0 in cflags
+    # and so forth instead.
+    if [ "$optimise" = 'no' ]; then
+      cflags="$cflags -O0 "
+      cnooptflags="$pic -O0 "
+      coptflags="$pic -Kfast "
+      cxxflags="$cxxflags -O0 "
+      cxxnooptflags=" "
+      cxxoptflags="$pic "
+      fflags="$fflags -O0"
+      fnooptflags="-Ksimd_nouse_multiple_structures"
+      foptflags="-Ksimd_nouse_multiple_structures"
+    else
+      cnooptflags="$pic -O0 "
+      coptflags="$pic -Kfast "
+      cxxnooptflags="$pic -O0 "
+      cxxoptflags="$pic -Kfast "
+      fnooptflags=" $fpic -O0 -Ksimd_nouse_multiple_structures"
+      foptflags="$fpic -Kfast,simd_nouse_multiple_structures"
+    fi
+    
+    # Debugging options
+    if [ "$debug" = 'yes' ]; then
+      cflags="$cflags -g "
+      cxxflags="$cxxflags -g "
+      fflags="-Ksimd_nouse_multiple_structures $fflags -g"
+    fi
+
+#    extract_and_emit_compiler_versions '--version'
+
+    if [ "$pmemd_openmp" = 'yes' -o "$openmp" = 'yes' ]; then
+
+        # Enable OpenMP in PMEMD code.
+        if [ "$mpi" = 'yes' ]; then
+          foptflags="$foptflags $fwarnflag -Kopenmp -D_OPENMP_"
+        fi
+    fi
+      
+    if [ "$openmp" = 'yes' ]; then
+      
+        omp_flag="-Kopenmp -DOPENMP"
+      
+        flibs_arch="$flibs_arch -Kopenmp"
+        flibsf_arch="$flibsf_arch -Kopenmp"
+        # DRR - Currently MKL is statically linked by default, which appears
+        #       only to work for intel compilers.
+        if [ -n "$MKL_HOME" ] ; then
+          echo "Error: Currently MKL + OpenMP only supported for intel compilers."
+          echo "       Please unset MKL_HOME."
+          exit 1
+        fi
+    fi
+
+    freeformat_flag=-Free
+
+    # PMEMD Specifics
+    pmemd_fpp_flags='-DPUBFFT -DGNU_HACKS'
+    pmemd_foptflags=" $foptflags -Ksimd_nouse_multiple_structures $fwarnflag"
+    if [ "$pmemd_openmp" = 'yes' ]; then
+        pmemd_foptflags="$pmemd_foptflags -Kopenmp -D_OPENMP_"
+    fi
+    pmemd_coptflags="$coptflags"
+    if [ "$optimise" = 'no' ]; then
+        pmemd_foptflags="-O0 $pmemd_foptflags"
+        pmemd_coptflags="-O0 $pmemd_coptflags"
+    fi
+    if [ "$debug" = 'yes' ]; then
+        pmemd_foptflags="-g $pmemd_foptflags"
+        pmemd_coptflags="-g $pmemd_coptflags"
+    fi
+        
+    #midpoint optimization flags.
+    if [ "$midpoint" = 'yes' ]; then
+              if [ "$pmemd_openmp" = 'no' ]; then
+                       if [ "$spdp" = 'yes' ]; then
+                               pmemd_foptflags="$pmemd_foptflags -Dpmemd_SPDP -DMIDPOINT_SPDP"
+                               pmemd_coptflags="$pmemd_coptflags -Dpmemd_SPDP -DMIDPOINT_SPDP"
+                       else
+                               pmemd_foptflags="$pmemd_foptflags -Dpmemd_DPDP"
+                               pmemd_coptflags="$pmemd_coptflags -Dpmemd_DPDP"
+                       fi
+               else
+                       echo "Configure error: Cannot use midpoint with -openmp on."
+                       echo "Use: ./configure -midpoint -mpi gnu"
+                       exit 1
+               fi
+    fi
+
+    ;;
+
 #################### cray #######
 cray)
     test -z "$pic" && pic="-fpic"
@@ -2748,12 +2890,24 @@
 EOF
 echo ""
 echo "Testing mixed C/Fortran compilation:"
-echo "     $cc $cflags $cnooptflags -c -o testp.c$objsuffix testp.c"
-$cc $cflags $cnooptflags -c -o testp.c$objsuffix testp.c
-echo "     $fc $fflags $fnooptflags -c -o testp.f$objsuffix testp.f"
-$fc $fflags $fnooptflags -c -o testp.f$objsuffix testp.f
-echo "     $cc $cflags -o testp$suffix testp.c$objsuffix testp.f$objsuffix $flibs_arch $extra_ftest"
-$cc $cflags -o testp$suffix testp.c$objsuffix testp.f$objsuffix $flibs_arch $extra_ftest
+
+if [ $a64fx = 'yes' ]; then
+  frtlibs=" --linkfortran "
+  echo "    $cc -Nclang $cflags $cnooptflags -c -o testp.c$objsuffix testp.c"
+  $cc $cflags $cnooptflags -c -o testp.c$objsuffix testp.c
+  echo "     $fc $fflags $fnooptflags -c -o testp.f$objsuffix testp.f"
+  $fc $fflags $fnooptflags -c -o testp.f$objsuffix testp.f
+  echo "    $cc $cflags -o testp$suffix testp.c$objsuffix testp.f$objsuffix $flibs_arch $extra_ftest $frtlibs"
+  $cc $cflags -o testp$suffix testp.c$objsuffix testp.f$objsuffix $flibs_arch $extra_ftest $frtlibs
+else
+  echo "     $cc $cflags $cnooptflags -c -o testp.c$objsuffix testp.c"
+  $cc $cflags $cnooptflags -c -o testp.c$objsuffix testp.c
+  echo "     $fc $fflags $fnooptflags -c -o testp.f$objsuffix testp.f"
+  $fc $fflags $fnooptflags -c -o testp.f$objsuffix testp.f
+  echo "     $cc $cflags -o testp$suffix testp.c$objsuffix testp.f$objsuffix $flibs_arch $extra_ftest"
+  $cc $cflags -o testp$suffix testp.c$objsuffix testp.f$objsuffix $flibs_arch $extra_ftest
+fi
+
 if [ $? -ne 0 ] ; then
   echo "Error: Unabled to compile mixed C/Fortran code."
   echo "       Please check your compiler settings and configure flags."
@@ -2927,9 +3081,18 @@
                     --prefix=$amberprefix --disable-shared --disable-netcdf-4 --disable-dap \
                     --disable-doxygen > ../netcdf_config.log 2>&1
       else
+        if [ "$verbose" = '' ]; then
+          echo "./configure CC=\"$cc\" CFLAGS=\"$cflags $cnooptflags\" LDFLAGS=\"$ldflags\" \
+                    --prefix=$amberprefix --disable-netcdf-4 --disable-dap $windows_hostflag \
+                    --disable-shared --disable-doxygen"
+          ./configure CC="$cc" CFLAGS="$cflags $cnooptflags" LDFLAGS="$ldflags" \
+                    --prefix=$amberprefix --disable-netcdf-4 --disable-dap $windows_hostflag \
+                    --disable-shared --disable-doxygen
+        else   
         ./configure CC="$cc" CFLAGS="$cflags $cnooptflags" LDFLAGS="$ldflags" \
                     --prefix=$amberprefix --disable-netcdf-4 --disable-dap $windows_hostflag \
                     --disable-shared --disable-doxygen > ../netcdf_config.log 2>&1
+        fi
       fi
       ncerror=$?
       if [ $ncerror -gt 0 ]; then
@@ -3436,7 +3599,7 @@
       echo "   --configuring for mic (native mode)..."
       echo
       cd fftw-3.3 && \
-      ./configure --disable-doc --prefix=$amberprefix --libdir=$amberprefix/lib \
+      ./configure --prefix=$amberprefix --libdir=$amberprefix/lib \
         --enable-static --host=x86_64-k1om-linux \
       --build=x86_64-unknown-linux \
        $enable_mpi $mpicc $enable_debug \
@@ -3446,13 +3609,28 @@
         > ../fftw3_config.log 2>&1
       ncerror=$?
     else
-      cd fftw-3.3 && \
-        ./configure --disable-doc --prefix=$amberprefix --libdir=$amberprefix/lib \
-        --enable-static $enable_mpi $mpicc $enable_debug $enable_sse\
-        CC="$cc" CFLAGS="$cflags $coptflags" \
-        F77="$fc" FFLAGS="$fflags $foptflags" \
-        FLIBS="$flibs_arch" \
-        > ../fftw3_config.log 2>&1
+      if [ "$verbose" = "" ]; then
+        echo "d fftw-3.3 && \
+          ./configure --prefix=$amberprefix --libdir=$amberprefix/lib \
+          --enable-static $enable_mpi $mpicc $enable_debug $enable_sse\
+          CC=\"$cc\" CFLAGS=\"$cflags $coptflags\" \
+          F77=\"$fc\" FFLAGS=\"$fflags $foptflags\" \
+          FLIBS=\"$flibs_arch\""
+        cd fftw-3.3 && \
+          ./configure  --prefix=$amberprefix --libdir=$amberprefix/lib \
+          --enable-static $enable_mpi $mpicc $enable_debug $enable_sse\
+          CC="$cc" CFLAGS="$cflags $coptflags" \
+          F77="$fc" FFLAGS="$fflags $foptflags" \
+          FLIBS="$flibs_arch"
+      else
+        cd fftw-3.3 && \
+          ./configure  --prefix=$amberprefix --libdir=$amberprefix/lib \
+          --enable-static $enable_mpi $mpicc $enable_debug $enable_sse\
+          CC="$cc" CFLAGS="$cflags $coptflags" \
+          F77="$fc" FFLAGS="$fflags $foptflags" \
+          FLIBS="$flibs_arch" \
+          > ../fftw3_config.log 2>&1
+      fi
       ncerror=$?
     fi
     if [ $ncerror -gt 0 ]; then
@@ -3465,7 +3643,11 @@
     fi
     # Build FFTW3
     printf "Compiling the FFTW3 interface (may be time-consuming)..."
-    make install > fftw3.compile.log 2>&1
+    if [ "$verbose" = "" ]; then
+      make install
+    else
+      make install > fftw3.compile.log 2>&1
+    fi
     if [ $? -ne 0 ]; then
       printf "\nError: FFTW3 compile failed.\n"
       printf "       Check $AMBERHOME/AmberTools/src/fftw-3.3.8/fftw3.compile.log\n"
@@ -3547,7 +3729,12 @@
       ./bootstrap.sh --prefix=$amberprefix --with-toolset=intel-linux > ../boost_config.log
       ncerror=$?
   else
-      ./bootstrap.sh --prefix=$amberprefix > ../boost_config.log
+     if [ "$verbose" = "" ]; then
+       echo "CC=\"gcc -std=c++17\" ./bootstrap.sh --prefix=$amberprefix"
+       CC="gcc -std=c++17 " ./bootstrap.sh --prefix=$amberprefix 
+     else
+       CC="gcc -std=c++17 " ./bootstrap.sh --prefix=$amberprefix > ../boost_config.log
+     fi
       ncerror=$?
   fi
 
@@ -3559,9 +3746,15 @@
   else
       printf "OK\n"
       printf "Compiling boost (may be time-consuming)..."
-      ./b2 --with-program_options --with-iostreams --with-regex \
-           --with-system --with-timer --with-chrono --with-filesystem \
-           --with-graph --with-thread link=static install >> ../boost_config.log
+      if [ "$verbose" = "" ]; then
+        ./b2 --with-program_options --with-iostreams --with-regex \
+             --with-system --with-timer --with-chrono --with-filesystem \
+             --with-graph --with-thread link=static install 
+      else
+        ./b2 --with-program_options --with-iostreams --with-regex \
+             --with-system --with-timer --with-chrono --with-filesystem \
+             --with-graph --with-thread link=static install >> ../boost_config.log
+      fi
       if [ $? -ne 0 ]; then
          printf "\nError: Boost compile failed.\n"
          printf "       Check $AMBERHOME/AmberTools/src/boost_config.log\n"
@@ -3624,6 +3817,10 @@
       if [ -z "$MPICC" ]; then cc="mpiicc"; else cc="$MPICC"; fi
       if [ -z "$MPICXX" ]; then cplusplus="mpiicpc"; else cplusplus="$MPICXX"; fi
       if [ -z "$MPIF90" ]; then fc="mpiifort"; else fc="$MPIF90"; fi
+  elif [ "$a64fx" = 'yes' ]; then
+      if [ -z "$MPICC" ]; then cc="mpifcc -Nclang -fsigned-char"; else cc="$MPICC"; fi
+      if [ -z "$MPICXX" ]; then cplusplus="mpiFCC -Nclang -fsigned-char"; else cplusplus="$MPICXX"; fi
+      if [ -z "$MPIF90" ]; then fc="mpifrt"; else fc="$MPIF90"; fi
   else
       if [ -z "$MPICC" ]; then cc="mpicc"; else cc="$MPICC"; fi
       if [ -z "$MPICXX" ]; then cplusplus="mpicxx"; else cplusplus="$MPICXX"; fi
@@ -3829,10 +4026,33 @@
 else # TODO use libsci for cray?
   CPPTRAJOPTS="$CPPTRAJOPTS --with-blas=$CPPTRAJHOME --with-lapack=$CPPTRAJHOME"
 fi
-cd cpptraj && NVCCFLAGS=$nvccflags CXXFLAGS=$cpptrajcxxflags LDFLAGS=$cpptrajldflags \
-  ./configure $CPPTRAJOPTS --prefix=$CPPTRAJHOME \
-  --requires-flink --with-arpack=$CPPTRAJHOME \
-  -shared --skip-checks --nobuildlibs $compiler > $cwd/cpptraj_config.log 2>&1
+if [ "$verbose" = '' ]; then
+  printf "\n"
+  echo "cd cpptraj && NVCCFLAGS=$nvccflags CXXFLAGS=$cpptrajcxxflags LDFLAGS=$cpptrajldflags \
+    ./configure $CPPTRAJOPTS --prefix=$CPPTRAJHOME \
+    --requires-flink --with-arpack=$CPPTRAJHOME \
+    -shared --skip-checks --nobuildlibs $compiler"
+  cd cpptraj && NVCCFLAGS=$nvccflags CXXFLAGS=$cpptrajcxxflags LDFLAGS=$cpptrajldflags \
+    ./configure $CPPTRAJOPTS --prefix=$CPPTRAJHOME \
+    --requires-flink --with-arpack=$CPPTRAJHOME \
+    -shared --skip-checks --nobuildlibs $compiler
+#  cd cpptraj && NVCCFLAGS=$nvccflags CXXFLAGS=$cpptrajcxxflags FLAGS=$cpptrajcxxflags \
+#    LDFLAGS=$cpptrajldflags \
+#    ./configure $CPPTRAJOPTS --prefix=$CPPTRAJHOME --compile-verbose \
+#    --requires-flink --with-arpack=$CPPTRAJHOME \
+#    -shared --skip-checks $compiler
+else
+  cd cpptraj && NVCCFLAGS=$nvccflags CXXFLAGS=$cpptrajcxxflags LDFLAGS=$cpptrajldflags \
+    ./configure $CPPTRAJOPTS --prefix=$CPPTRAJHOME \
+    --requires-flink --with-arpack=$CPPTRAJHOME \
+    -shared --skip-checks --nobuildlibs $compiler > $cwd/cpptraj_config.log 2>&1
+#  cd cpptraj && NVCCFLAGS=$nvccflags CXXFLAGS=$cpptrajcxxflags FLAGS=$cpptrajcxxflags \
+#    LDFLAGS=$cpptrajldflags \
+#    ./configure $CPPTRAJOPTS --prefix=$CPPTRAJHOME \
+#    --requires-flink --with-arpack=$CPPTRAJHOME \
+#    -shared --skip-checks $compiler > $cwd/cpptraj_config.log 2>&1
+fi
+
 if [ "$?" -ne 0 ] ; then
   echo ""
   echo "CPPTRAJ configure failed. Check '$cwd/cpptraj_config.log' for details."
@@ -3867,18 +4087,20 @@
   if [ "$debug" = 'yes' ] ; then
     QUICKOPTS="$QUICKOPTS --debug"
   fi
-  if [ "$compiler" != 'gnu' ] ; then
-    if [ "$compiler" != 'intel' ] ; then
-      if [ "$compiler" != 'pgi' ] ; then
-        echo ""
-        echo "QUICK can only be compiled with gnu, intel, or pgi."
-        echo "You may use the --skip-quick flag to skip the QUICK installation."
-        exit 1
-      fi
-    fi
+  if [[ "$compiler" != 'gnu' && "$compiler" != 'intel' && "$compiler" != 'pgi' && "$compiler" != 'a64fx' ]] ; then
+    echo ""
+    echo "QUICK can only be compiled with gnu, intel, or pgi."
+    echo "You may use the --skip-quick flag to skip the QUICK installation."
+    exit 1
+  fi
+  if [ "$verbose" = "" ]; then
+    echo "cd quick && NVCCFLAGS=$nvccflags CC="fcc -Nclang" CXX="FCC -Nclang" ./configure $QUICKOPTS --shared --amber $QUICKverbose --prefix $QUICKHOME $compiler"
+    cd quick && NVCCFLAGS=$nvccflags CC="fcc -Nclang" CXX="FCC -Nclang" \
+      ./configure $QUICKOPTS --shared --amber $QUICKverbose --prefix $QUICKHOME $compiler
+  else
+    cd quick && NVCCFLAGS=$nvccflags CC="fcc -Nclang" CXX="FCC -Nclang" \
+      ./configure $QUICKOPTS --shared --amber $QUICKverbose --prefix $QUICKHOME $compiler > $cwd/quick_config.log 2>&1
   fi
-  cd quick && NVCCFLAGS=$nvccflags \
-    ./configure $QUICKOPTS --shared --amber $QUICKverbose --prefix $QUICKHOME $compiler > $cwd/quick_config.log 2>&1
   if [ "$?" -ne 0 ] ; then
     echo ""
     echo "QUICK configure failed. Check '$cwd/quick_config.log' for details."
@@ -3893,10 +4115,10 @@
       quick_flibsf="-L$AMBERHOME/lib -lquick-cuda -L$CUDA_HOME/lib64 -lcuda -lcudart -lcudadevrt -lcublas -lcusolver -lxc-cuda"
       quick_fppflags="-DQUICK -I$AMBERHOME/AmberTools/src/quick/build/include/cuda"
   elif [ "$mpi" = 'yes' ] && [ "$cuda" = 'no' ]; then
-      quick_flibsf="-L$AMBERHOME/lib -lquick-mpi -lblas-quick -lxc"
+      quick_flibsf="-L$AMBERHOME/lib -lquick-mpi -lblas-quick -ldlfind -llapack-quick -lxc"
       quick_fppflags="-DQUICK -I$AMBERHOME/AmberTools/src/quick/build/include/mpi"
   else
-      quick_flibsf="-L$AMBERHOME/lib -lquick -lblas-quick -lxc"
+      quick_flibsf="-L$AMBERHOME/lib -lquick -lblas-quick -ldlfind -llapack-quick -lxc"
       quick_fppflags="-DQUICK -I$AMBERHOME/AmberTools/src/quick/build/include/serial"
   fi
   echo "OK"
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/cphstats/CMakeLists.txt ./AmberTools/src/cphstats/CMakeLists.txt
--- AmberTools/src/cphstats/CMakeLists.txt	2022-08-29 08:27:57.000000000 +0900
+++ ./AmberTools/src/cphstats/CMakeLists.txt	2022-08-24 15:02:43.000000000 +0900
@@ -37,6 +37,11 @@
 	prottraj.cpp utilities.cpp conprob.cpp)
 
 set(CPHSTATS_FORTRAN_SOURCES parse_cpin.F90)
+
+if( "${COMPILER}" STREQUAL "FUJITSU" )
+	add_link_options("--linkfortran")
+endif()
+
 #---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
 #cphstats uses optimization
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/cphstats/Makefile ./AmberTools/src/cphstats/Makefile
--- AmberTools/src/cphstats/Makefile	2022-08-29 08:28:03.000000000 +0900
+++ ./AmberTools/src/cphstats/Makefile	2022-05-05 14:56:49.000000000 +0900
@@ -17,11 +17,11 @@
 
 $(PROGNAME): $(OBJS)
 	@echo "[CPHSTATS]  CXX $@"
-	$(VB)$(CXX) -o $(PROGNAME) $(OBJS) $(LDFLAGS) $(NOFORTRANMAIN) $(ZLIB) $(BZLIB)
+	$(VB)$(CXX) --linkfortran -o $(PROGNAME) $(OBJS) $(LDFLAGS) $(NOFORTRANMAIN) $(ZLIB) $(BZLIB)
 
 $(PROGNAME2): $(OBJS2)
 	@echo "[CPHSTATS]  CXX $@"
-	$(VB)$(CXX) -o $(PROGNAME2) $(OBJS2) $(LDFLAGS) $(NOFORTRANMAIN) $(ZLIB) $(BZLIB)
+	$(VB)$(CXX) --linkfortran -o $(PROGNAME2) $(OBJS2) $(LDFLAGS) $(NOFORTRANMAIN) $(ZLIB) $(BZLIB)
 
 install: $(PROGNAME) $(PROGNAME2)
 	/bin/mv $(PROGNAME) $(BINDIR)
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/cpptraj/configure ./AmberTools/src/cpptraj/configure
--- AmberTools/src/cpptraj/configure	2022-08-29 08:27:00.000000000 +0900
+++ ./AmberTools/src/cpptraj/configure	2022-05-05 21:38:52.000000000 +0900
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/bin/bash -i
 # CPPTRAJ standalone configure script.
 # Daniel R. Roe
 # 2010-11-18
@@ -11,7 +11,7 @@
 #-------------------------------------------------------------------------------
 # Print simple help message
 UsageSimple() {
-  echo "Usage: ./configure <OPTIONS> [gnu | intel | pgi | clang | cray | oneapi]"
+  echo "Usage: ./configure <OPTIONS> [gnu | intel | pgi | clang | cray | oneapi | a64fx]"
   echo "  OPTIONS:"
   echo "    --help         : Display this message."
   echo "    --prefix <dir> : Install CPPTRAJ to specified directory (default is this directory)."
@@ -246,11 +246,11 @@
 LIB_TYPE[$LNETCDF]='ld'              # ld = LDFLAGS, cpp = cpptraj, blank = special
 
 LIB_STAT[$LPARANC]='off'
-LIB_CKEY[$LPARANC]='pnetcdf'
+#LIB_CKEY[$LPARANC]='pnetcdf'
 LIB_HOME[$LPARANC]=''
-LIB_FLAG[$LPARANC]='-lpnetcdf'
-LIB_STTC[$LPARANC]='libpnetcdf.a'
-LIB_D_ON[$LPARANC]='-DHAS_PNETCDF'
+#LIB_FLAG[$LPARANC]='-lpnetcdf'
+#LIB_STTC[$LPARANC]='libpnetcdf.a'
+#LIB_D_ON[$LPARANC]='-DHAS_PNETCDF'
 LIB_DOFF[$LPARANC]=''
 LIB_TYPE[$LPARANC]='ld'
 
@@ -1391,6 +1391,7 @@
         *icpc*    ) COMPILERS='intel' ;;
         *icpx*    ) COMPILERS='oneapi' ;;
         *pgc++*   ) COMPILERS='pgi' ;;
+	*FCC*     ) COMPILERS='a64fx' ; echo "Determined Fujitsu compilers";;
         *CC*      ) COMPILERS='cray' ;;
         * ) WrnMsg "Could not detect compiler type ($CXX); assuming GNU" ;;
       esac
@@ -1453,6 +1454,27 @@
       picflag='-fPIC'
       C11FLAG='-std=c++11'
       ;;
+      "a64fx" )
+        if [ $USE_MPI -ne 0    ] ; then USE_MPI=3; fi
+        if [ -z "$CC" ]; then CC="fcc -Nclang -fsigned-char"; fi
+        if [ -z "$CXX" ]; then CXX="FCC -Nclang -fsigned-char"; fi
+        if [ -z "$FC" ]; then FC=frt; fi
+        CXXFLAGS="$CXXFLAGS"
+        CFLAGS="$CFLAGS"
+        hostflags=''
+        optflags=''
+        ompflag=''
+        warnflag=' -w ' # This will also print cautions
+        fwarnflag='-fs'
+        freefmtflag='-Free'
+        foptflags=''
+        FLINK=' --linkfortran ${FLINK}'
+        picflag='-Kpic'
+        C11FLAG='-std=c++11'
+        if [ $USE_OPENMP -eq 0 ] ; then
+          commonflags=''
+        fi
+      ;;
    'oneapi' )
       if [ -z "$CC" ]; then CC=icx; fi
       if [ -z "$CXX" ]; then CXX=icpx; fi
@@ -1564,6 +1586,27 @@
         commonflags='-h noomp'
       fi
       ;;
+     "a64fx" )
+       if [ $USE_MPI -ne 0    ] ; then USE_MPI=3; fi
+       if [ -z "$CC" ]; then CC="fcc -Nclang -fsigned-char"; fi
+       if [ -z "$CXX" ]; then CXX="FCC -Nclang -fsigned-char"; fi
+       if [ -z "$FC" ]; then FC=frt; fi
+       CXXFLAGS="$CXXFLAGS"
+       CFLAGS="$CFLAGS"
+       hostflags=''
+       optflags=''
+       ompflag=''
+       warnflag=' -w ' # This will also print cautions
+       fwarnflag='-fs'
+       freefmtflag='-Free'
+       foptflags=''
+       FLINK=' --linkfortran ${FLINK}'
+       picflag='-Kpic'
+       C11FLAG='-std=c++11'
+       if [ $USE_OPENMP -eq 0 ] ; then
+         commonflags=''
+       fi
+       ;;
     * ) Err "Unknown compilers: $1" ;;
   esac
   # Unless specified fortran warnflag is same as C/C++
@@ -1626,6 +1669,20 @@
       mpi_cc='mpiicc'
       mpi_cxx='mpiicpc'
       mpi_f90='mpiifort'
+    elif [ $USE_MPI -eq 3 ] ; then
+      if [[ $CC == *"-Nclang"* ]]; then
+        mpi_cc=$CC
+      else 
+        mpi_cc='mpifcc'
+      fi
+      echo "MPI C compiler: ${mpi_cc}"
+      if [[ $CXX == *"-Nclang"* ]]; then
+        mpi_cxx=$CXX
+      else
+        mpi_cxx='mpiFCC'
+      fi
+      echo "MPI C++ compiler: ${mpi_cxx}"
+      mpi_f90='mpifrt'
     fi
     if [ -z "$MPICC" ] ; then
       CC=$mpi_cc
@@ -1653,7 +1710,10 @@
     FC=ftn
   fi
   # Sanity check
-  if [ -z "$CC" -o -z "$CXX" -o -z "$FC" ] ; then
+  echo "if [[ "${CXX}" == *\"FCC\"* ]]; then"
+  if [[ "${CXX}" == *"FCC"* ]]; then
+    echo "Fujitsu FCC compiler is used"
+  elif [ -z "$CC" -o -z "$CXX" -o -z "$FC" ] ; then
     ErrMsg "No compiler specified and CXX not set."
     UsageSimple
     exit 1
@@ -2402,6 +2462,7 @@
     '--help' | '-h' ) UsageSimple ; exit 0 ;;
     '--full-help'   ) UsageFull   ; exit 0 ;;
     # Compiler Options
+    'a64fx'      ) COMPILERS=$KEY ;;
     'gnu'        ) COMPILERS=$KEY ;;
     'clang'      ) COMPILERS=$KEY ;;
     'intel'      ) COMPILERS=$KEY ;;
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/cpptraj/test/Makefile ./AmberTools/src/cpptraj/test/Makefile
--- AmberTools/src/cpptraj/test/Makefile	2022-08-29 08:26:25.000000000 +0900
+++ ./AmberTools/src/cpptraj/test/Makefile	2022-05-05 14:56:46.000000000 +0900
@@ -677,10 +677,10 @@
 	$(MAKE) test.complete summary OPT="$(OPT) hip"
 
 test.libcpptraj:
-	@cd Test_Libcpptraj && ./RunTest.sh $(OPT)
+	cd Test_Libcpptraj && ./RunTest.sh $(OPT)
 
 test.complete: CpptrajTest.sh MasterTest.sh
-	@./CpptrajTest.sh --target test.cpptraj $(OPT)
+	./CpptrajTest.sh --target test.cpptraj $(OPT)
 
 test.cpptraj: $(COMPLETETESTS)
 
@@ -688,17 +688,17 @@
 	$(MAKE) test.complete summary OPT="$(OPT) showerrors long"
 
 summary: CpptrajTest.sh MasterTest.sh
-	@./CpptrajTest.sh summary $(OPT)
+	./CpptrajTest.sh summary $(OPT)
 
 test.vg:
 	$(MAKE) test.complete summary OPT="$(OPT) vg"
 
 clean:
-	@echo "Cleaning all test directories:"
+	echo "Cleaning all test directories:"
 	$(MAKE) test.complete test.libcpptraj OPT=clean
 
 cleanprofile:
-	@echo "Removing GNU profile files:"
+	echo "Removing GNU profile files:"
 	(find . -name 'libstdcxx-profile.*' | \
         while read dif ;\
         do \
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/cpptraj/test/MasterTest.sh ./AmberTools/src/cpptraj/test/MasterTest.sh
--- AmberTools/src/cpptraj/test/MasterTest.sh	2022-08-29 08:27:00.000000000 +0900
+++ ./AmberTools/src/cpptraj/test/MasterTest.sh	2022-05-05 14:56:49.000000000 +0900
@@ -746,12 +746,12 @@
   CPPTRAJ_XDRFILE='yes'
   CPPTRAJ_TNGFILE=''
   CPPTRAJ_MATHLIB='yes'
-  CPPTRAJDEFINES=`$CPPTRAJ --defines`
+  CPPTRAJDEFINES=`$DO_PARALLEL $CPPTRAJ --defines`
   if [ $? -ne 0 ] ; then
-    ErrMsg "Could not execute '$CPPTRAJ --defines'"
+    ErrMsg "Could not execute '$DO_PARALLEL $CPPTRAJ --defines'"
     exit 1
   fi
-  for DEFINE in `$CPPTRAJ --defines` ; do
+  for DEFINE in `$DO_PARALLEL $CPPTRAJ --defines` ; do
     case "$DEFINE" in
       '-DHASGZ'         ) export CPPTRAJ_ZLIB=$DEFINE ;;
       '-DHASBZ2'        ) export CPPTRAJ_BZLIB=$DEFINE ;;
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/etc/CMakeLists.txt ./AmberTools/src/etc/CMakeLists.txt
--- AmberTools/src/etc/CMakeLists.txt	2022-08-29 08:36:14.000000000 +0900
+++ ./AmberTools/src/etc/CMakeLists.txt	2022-08-29 14:21:44.000000000 +0900
@@ -15,6 +15,9 @@
 add_executable(elsize elsize.c)
 target_link_libraries(elsize m)
 
+if( "${COMPILER}" STREQUAL "FUJITSU" )
+	add_link_options("--linkfortran")
+endif()
 add_nab_executable(molsurf NAB_SOURCES molsurf.nab)
 target_include_directories(molsurf PUBLIC ${NAB_HEADER_DIR})
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/fftw-3.3/CMakeLists.txt ./AmberTools/src/fftw-3.3/CMakeLists.txt
--- AmberTools/src/fftw-3.3/CMakeLists.txt	2022-08-29 08:35:15.000000000 +0900
+++ ./AmberTools/src/fftw-3.3/CMakeLists.txt	2022-06-08 15:19:34.000000000 +0900
@@ -415,6 +415,7 @@
 # Set up Fortran
 #------------------------------------------------------------------------
 if(NOT DISABLE_FORTRAN)
+	set(FortranCInterface_GLOBAL_SYMBOLS mysub_ my_sub_ ) #V
 	include(FortranCInterface)
 		
 	FortranCInterface_VERIFY() #check that Fortran can link to C
@@ -577,4 +578,4 @@
 
 if(ENABLE_MPI)
 	add_subdirectory(mpi)
-endif()
\ No newline at end of file
+endif()
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/fftw-3.3/config.guess ./AmberTools/src/fftw-3.3/config.guess
--- AmberTools/src/fftw-3.3/config.guess	2022-08-29 08:35:59.000000000 +0900
+++ ./AmberTools/src/fftw-3.3/config.guess	2022-05-25 14:18:32.000000000 +0900
@@ -1,14 +1,12 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
-#   Free Software Foundation, Inc.
+#   Copyright 1992-2019 Free Software Foundation, Inc.
 
-timestamp='2009-12-30'
+timestamp='2019-04-28'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
+# the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -17,26 +15,22 @@
 # General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
-# 02110-1301, USA.
+# along with this program; if not, see <https://www.gnu.org/licenses/>.
 #
 # As a special exception to the GNU General Public License, if you
 # distribute this file as part of a program that contains a
 # configuration script generated by Autoconf, you may include it under
-# the same distribution terms that you use for the rest of that program.
-
-
-# Originally written by Per Bothner.  Please send patches (context
-# diff format) to <config-patches@gnu.org> and include a ChangeLog
-# entry.
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
 #
-# This script attempts to guess a canonical system name similar to
-# config.sub.  If it succeeds, it prints the system name on stdout, and
-# exits with 0.  Otherwise, it exits with 1.
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
 # You can get the latest version of this script from:
-# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+# https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+#
+# Please send patches to <config-patches@gnu.org>.
+
 
 me=`echo "$0" | sed -e 's,.*/,,'`
 
@@ -45,7 +39,7 @@
 
 Output the configuration name of the system \`$me' is run on.
 
-Operation modes:
+Options:
   -h, --help         print this help, then exit
   -t, --time-stamp   print date of last modification, then exit
   -v, --version      print version number, then exit
@@ -56,9 +50,7 @@
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free
-Software Foundation, Inc.
+Copyright 1992-2019 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -92,8 +84,6 @@
   exit 1
 fi
 
-trap 'exit 1' 1 2 15
-
 # CC_FOR_BUILD -- compiler used by this script. Note that the use of a
 # compiler to aid in system detection is discouraged as it requires
 # temporary files to be created and, as you can see below, it is a
@@ -104,34 +94,38 @@
 
 # Portable tmp directory creation inspired by the Autoconf team.
 
-set_cc_for_build='
-trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
-trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
-: ${TMPDIR=/tmp} ;
- { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
- { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
- { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
- { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
-dummy=$tmp/dummy ;
-tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
-case $CC_FOR_BUILD,$HOST_CC,$CC in
- ,,)    echo "int x;" > $dummy.c ;
-	for c in cc gcc c89 c99 ; do
-	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
-	     CC_FOR_BUILD="$c"; break ;
-	  fi ;
-	done ;
-	if test x"$CC_FOR_BUILD" = x ; then
-	  CC_FOR_BUILD=no_compiler_found ;
-	fi
-	;;
- ,,*)   CC_FOR_BUILD=$CC ;;
- ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac ; set_cc_for_build= ;'
+tmp=
+# shellcheck disable=SC2172
+trap 'test -z "$tmp" || rm -fr "$tmp"' 0 1 2 13 15
+
+set_cc_for_build() {
+    : "${TMPDIR=/tmp}"
+    # shellcheck disable=SC2039
+    { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+	{ test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir "$tmp" 2>/dev/null) ; } ||
+	{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir "$tmp" 2>/dev/null) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+	{ echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; }
+    dummy=$tmp/dummy
+    case ${CC_FOR_BUILD-},${HOST_CC-},${CC-} in
+	,,)    echo "int x;" > "$dummy.c"
+	       for driver in cc gcc c89 c99 ; do
+		   if ($driver -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
+		       CC_FOR_BUILD="$driver"
+		       break
+		   fi
+	       done
+	       if test x"$CC_FOR_BUILD" = x ; then
+		   CC_FOR_BUILD=no_compiler_found
+	       fi
+	       ;;
+	,,*)   CC_FOR_BUILD=$CC ;;
+	,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+    esac
+}
 
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
 # (ghazi@noc.rutgers.edu 1994-08-24)
-if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+if test -f /.attbin/uname ; then
 	PATH=$PATH:/.attbin ; export PATH
 fi
 
@@ -140,12 +134,40 @@
 UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
+case "$UNAME_SYSTEM" in
+Linux|GNU|GNU/*)
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	LIBC=gnu
+
+	set_cc_for_build
+	cat <<-EOF > "$dummy.c"
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#else
+	LIBC=gnu
+	#endif
+	EOF
+	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`"
+
+	# If ldd exists, use it to detect musl libc.
+	if command -v ldd >/dev/null && \
+		ldd --version 2>&1 | grep -q ^musl
+	then
+	    LIBC=musl
+	fi
+	;;
+esac
+
 # Note: order is significant - the case branches are not exclusive.
 
-case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
     *:NetBSD:*:*)
 	# NetBSD (nbsd) targets should (where applicable) match one or
-	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
 	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
 	# switched to ELF, *-*-netbsd* would select the old
 	# object file format.  This provides both forward
@@ -155,21 +177,31 @@
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
 	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
-	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
-	case "${UNAME_MACHINE_ARCH}" in
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+	    "/sbin/$sysctl" 2>/dev/null || \
+	    "/usr/sbin/$sysctl" 2>/dev/null || \
+	    echo unknown)`
+	case "$UNAME_MACHINE_ARCH" in
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
-	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
+	    earmv*)
+		arch=`echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine="${arch}${endian}"-unknown
+		;;
+	    *) machine="$UNAME_MACHINE_ARCH"-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
-	# to ELF recently, or will in the future.
-	case "${UNAME_MACHINE_ARCH}" in
+	# to ELF recently (or will in the future) and ABI.
+	case "$UNAME_MACHINE_ARCH" in
+	    earm*)
+		os=netbsdelf
+		;;
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
-		eval $set_cc_for_build
+		set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
 			| grep -q __ELF__
 		then
@@ -181,7 +213,14 @@
 		fi
 		;;
 	    *)
-	        os=netbsd
+		os=netbsd
+		;;
+	esac
+	# Determine ABI tags.
+	case "$UNAME_MACHINE_ARCH" in
+	    earm*)
+		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+		abi=`echo "$UNAME_MACHINE_ARCH" | sed -e "$expr"`
 		;;
 	esac
 	# The OS release
@@ -189,42 +228,62 @@
 	# thus, need a distinct triplet. However, they do not need
 	# kernel version information, so it can be replaced with a
 	# suitable tag, in the style of linux-gnu.
-	case "${UNAME_VERSION}" in
+	case "$UNAME_VERSION" in
 	    Debian*)
 		release='-gnu'
 		;;
 	    *)
-		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		release=`echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2`
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
+	echo "$machine-${os}${release}${abi-}"
+	exit ;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	echo "$UNAME_MACHINE_ARCH"-unknown-bitrig"$UNAME_RELEASE"
 	exit ;;
     *:OpenBSD:*:*)
 	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
-	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+	echo "$UNAME_MACHINE_ARCH"-unknown-openbsd"$UNAME_RELEASE"
+	exit ;;
+    *:LibertyBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	echo "$UNAME_MACHINE_ARCH"-unknown-libertybsd"$UNAME_RELEASE"
+	exit ;;
+    *:MidnightBSD:*:*)
+	echo "$UNAME_MACHINE"-unknown-midnightbsd"$UNAME_RELEASE"
 	exit ;;
     *:ekkoBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-unknown-ekkobsd"$UNAME_RELEASE"
 	exit ;;
     *:SolidBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-unknown-solidbsd"$UNAME_RELEASE"
 	exit ;;
     macppc:MirBSD:*:*)
-	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
+	echo powerpc-unknown-mirbsd"$UNAME_RELEASE"
 	exit ;;
     *:MirBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-unknown-mirbsd"$UNAME_RELEASE"
 	exit ;;
+    *:Sortix:*:*)
+	echo "$UNAME_MACHINE"-unknown-sortix
+	exit ;;
+    *:Redox:*:*)
+	echo "$UNAME_MACHINE"-unknown-redox
+	exit ;;
+    mips:OSF1:*.*)
+        echo mips-dec-osf1
+        exit ;;
     alpha:OSF1:*:*)
 	case $UNAME_RELEASE in
 	*4.0)
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
 		;;
 	*5.*)
-	        UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
 		;;
 	esac
 	# According to Compaq, /usr/sbin/psrinfo has been available on
@@ -234,60 +293,54 @@
 	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
 	case "$ALPHA_CPU_TYPE" in
 	    "EV4 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV4.5 (21064)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "LCA4 (21066/21068)")
-		UNAME_MACHINE="alpha" ;;
+		UNAME_MACHINE=alpha ;;
 	    "EV5 (21164)")
-		UNAME_MACHINE="alphaev5" ;;
+		UNAME_MACHINE=alphaev5 ;;
 	    "EV5.6 (21164A)")
-		UNAME_MACHINE="alphaev56" ;;
+		UNAME_MACHINE=alphaev56 ;;
 	    "EV5.6 (21164PC)")
-		UNAME_MACHINE="alphapca56" ;;
+		UNAME_MACHINE=alphapca56 ;;
 	    "EV5.7 (21164PC)")
-		UNAME_MACHINE="alphapca57" ;;
+		UNAME_MACHINE=alphapca57 ;;
 	    "EV6 (21264)")
-		UNAME_MACHINE="alphaev6" ;;
+		UNAME_MACHINE=alphaev6 ;;
 	    "EV6.7 (21264A)")
-		UNAME_MACHINE="alphaev67" ;;
+		UNAME_MACHINE=alphaev67 ;;
 	    "EV6.8CB (21264C)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8AL (21264B)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.8CX (21264D)")
-		UNAME_MACHINE="alphaev68" ;;
+		UNAME_MACHINE=alphaev68 ;;
 	    "EV6.9A (21264/EV69A)")
-		UNAME_MACHINE="alphaev69" ;;
+		UNAME_MACHINE=alphaev69 ;;
 	    "EV7 (21364)")
-		UNAME_MACHINE="alphaev7" ;;
+		UNAME_MACHINE=alphaev7 ;;
 	    "EV7.9 (21364A)")
-		UNAME_MACHINE="alphaev79" ;;
+		UNAME_MACHINE=alphaev79 ;;
 	esac
 	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-	exit ;;
-    Alpha\ *:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# Should we change UNAME_MACHINE based on the output of uname instead
-	# of the specific Alpha model?
-	echo alpha-pc-interix
-	exit ;;
-    21064:Windows_NT:50:3)
-	echo alpha-dec-winnt3.5
-	exit ;;
+	echo "$UNAME_MACHINE"-dec-osf"`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`"
+	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
+	exitcode=$?
+	trap '' 0
+	exit $exitcode ;;
     Amiga*:UNIX_System_V:4.0:*)
 	echo m68k-unknown-sysv4
 	exit ;;
     *:[Aa]miga[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-amigaos
+	echo "$UNAME_MACHINE"-unknown-amigaos
 	exit ;;
     *:[Mm]orph[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-morphos
+	echo "$UNAME_MACHINE"-unknown-morphos
 	exit ;;
     *:OS/390:*:*)
 	echo i370-ibm-openedition
@@ -296,12 +349,12 @@
 	echo s390-ibm-zvmoe
 	exit ;;
     *:OS400:*:*)
-        echo powerpc-ibm-os400
+	echo powerpc-ibm-os400
 	exit ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
-	echo arm-acorn-riscix${UNAME_RELEASE}
+	echo arm-acorn-riscix"$UNAME_RELEASE"
 	exit ;;
-    arm:riscos:*:*|arm:RISCOS:*:*)
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
 	echo arm-unknown-riscos
 	exit ;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
@@ -326,38 +379,38 @@
 	    sparc) echo sparc-icl-nx7; exit ;;
 	esac ;;
     s390x:SunOS:*:*)
-	echo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	echo "$UNAME_MACHINE"-ibm-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
 	exit ;;
     sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	echo sparc-hal-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
 	exit ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
-	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	echo sparc-sun-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
 	exit ;;
     i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
-	echo i386-pc-auroraux${UNAME_RELEASE}
+	echo i386-pc-auroraux"$UNAME_RELEASE"
 	exit ;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
-	eval $set_cc_for_build
-	SUN_ARCH="i386"
+	set_cc_for_build
+	SUN_ARCH=i386
 	# If there is a compiler, see if it is configured for 64-bit objects.
 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
 	# This test works for both compilers.
-	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
 	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
-		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		grep IS_64BIT_ARCH >/dev/null
 	    then
-		SUN_ARCH="x86_64"
+		SUN_ARCH=x86_64
 	    fi
 	fi
-	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	echo "$SUN_ARCH"-pc-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
 	exit ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
-	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	echo sparc-sun-solaris3"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
 	exit ;;
     sun4*:SunOS:*:*)
 	case "`/usr/bin/arch -k`" in
@@ -366,25 +419,25 @@
 		;;
 	esac
 	# Japanese Language versions have a version number like `4.1.3-JL'.
-	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+	echo sparc-sun-sunos"`echo "$UNAME_RELEASE"|sed -e 's/-/_/'`"
 	exit ;;
     sun3*:SunOS:*:*)
-	echo m68k-sun-sunos${UNAME_RELEASE}
+	echo m68k-sun-sunos"$UNAME_RELEASE"
 	exit ;;
     sun*:*:4.2BSD:*)
 	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
-	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	test "x$UNAME_RELEASE" = x && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
-		echo m68k-sun-sunos${UNAME_RELEASE}
+		echo m68k-sun-sunos"$UNAME_RELEASE"
 		;;
 	    sun4)
-		echo sparc-sun-sunos${UNAME_RELEASE}
+		echo sparc-sun-sunos"$UNAME_RELEASE"
 		;;
 	esac
 	exit ;;
     aushp:SunOS:*:*)
-	echo sparc-auspex-sunos${UNAME_RELEASE}
+	echo sparc-auspex-sunos"$UNAME_RELEASE"
 	exit ;;
     # The situation for MiNT is a little confusing.  The machine name
     # can be virtually everything (everything which is not
@@ -395,44 +448,44 @@
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
+	echo m68k-atari-mint"$UNAME_RELEASE"
 	exit ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
-        exit ;;
+	echo m68k-atari-mint"$UNAME_RELEASE"
+	exit ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
+	echo m68k-atari-mint"$UNAME_RELEASE"
 	exit ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
-        echo m68k-milan-mint${UNAME_RELEASE}
-        exit ;;
+	echo m68k-milan-mint"$UNAME_RELEASE"
+	exit ;;
     hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
-        echo m68k-hades-mint${UNAME_RELEASE}
-        exit ;;
+	echo m68k-hades-mint"$UNAME_RELEASE"
+	exit ;;
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
-        echo m68k-unknown-mint${UNAME_RELEASE}
-        exit ;;
+	echo m68k-unknown-mint"$UNAME_RELEASE"
+	exit ;;
     m68k:machten:*:*)
-	echo m68k-apple-machten${UNAME_RELEASE}
+	echo m68k-apple-machten"$UNAME_RELEASE"
 	exit ;;
     powerpc:machten:*:*)
-	echo powerpc-apple-machten${UNAME_RELEASE}
+	echo powerpc-apple-machten"$UNAME_RELEASE"
 	exit ;;
     RISC*:Mach:*:*)
 	echo mips-dec-mach_bsd4.3
 	exit ;;
     RISC*:ULTRIX:*:*)
-	echo mips-dec-ultrix${UNAME_RELEASE}
+	echo mips-dec-ultrix"$UNAME_RELEASE"
 	exit ;;
     VAX*:ULTRIX*:*:*)
-	echo vax-dec-ultrix${UNAME_RELEASE}
+	echo vax-dec-ultrix"$UNAME_RELEASE"
 	exit ;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
-	echo clipper-intergraph-clix${UNAME_RELEASE}
+	echo clipper-intergraph-clix"$UNAME_RELEASE"
 	exit ;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
+	set_cc_for_build
+	sed 's/^	//' << EOF > "$dummy.c"
 #ifdef __cplusplus
 #include <stdio.h>  /* for printf() prototype */
 	int main (int argc, char *argv[]) {
@@ -441,23 +494,23 @@
 #endif
 	#if defined (host_mips) && defined (MIPSEB)
 	#if defined (SYSTYPE_SYSV)
-	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	  printf ("mips-mips-riscos%ssysv\\n", argv[1]); exit (0);
 	#endif
 	#if defined (SYSTYPE_SVR4)
-	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	  printf ("mips-mips-riscos%ssvr4\\n", argv[1]); exit (0);
 	#endif
 	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
-	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	  printf ("mips-mips-riscos%sbsd\\n", argv[1]); exit (0);
 	#endif
 	#endif
 	  exit (-1);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c &&
-	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
-	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" &&
+	  dummyarg=`echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`"$dummy" "$dummyarg"` &&
 	    { echo "$SYSTEM_NAME"; exit; }
-	echo mips-mips-riscos${UNAME_RELEASE}
+	echo mips-mips-riscos"$UNAME_RELEASE"
 	exit ;;
     Motorola:PowerMAX_OS:*:*)
 	echo powerpc-motorola-powermax
@@ -481,21 +534,21 @@
 	echo m88k-motorola-sysv3
 	exit ;;
     AViiON:dgux:*:*)
-        # DG/UX returns AViiON for all architectures
-        UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
+	# DG/UX returns AViiON for all architectures
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if [ "$UNAME_PROCESSOR" = mc88100 ] || [ "$UNAME_PROCESSOR" = mc88110 ]
 	then
-	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
-	       [ ${TARGET_BINARY_INTERFACE}x = x ]
+	    if [ "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx ] || \
+	       [ "$TARGET_BINARY_INTERFACE"x = x ]
 	    then
-		echo m88k-dg-dgux${UNAME_RELEASE}
+		echo m88k-dg-dgux"$UNAME_RELEASE"
 	    else
-		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+		echo m88k-dg-dguxbcs"$UNAME_RELEASE"
 	    fi
 	else
-	    echo i586-dg-dgux${UNAME_RELEASE}
+	    echo i586-dg-dgux"$UNAME_RELEASE"
 	fi
- 	exit ;;
+	exit ;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
 	echo m88k-dolphin-sysv3
 	exit ;;
@@ -510,7 +563,7 @@
 	echo m68k-tektronix-bsd
 	exit ;;
     *:IRIX*:*:*)
-	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+	echo mips-sgi-irix"`echo "$UNAME_RELEASE"|sed -e 's/-/_/g'`"
 	exit ;;
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
 	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
@@ -522,14 +575,14 @@
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
 	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
 	fi
-	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
+	echo "$UNAME_MACHINE"-ibm-aix"$IBM_REV"
 	exit ;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
-		eval $set_cc_for_build
-		sed 's/^		//' << EOF >$dummy.c
+		set_cc_for_build
+		sed 's/^		//' << EOF > "$dummy.c"
 		#include <sys/systemcfg.h>
 
 		main()
@@ -540,7 +593,7 @@
 			exit(0);
 			}
 EOF
-		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"`
 		then
 			echo "$SYSTEM_NAME"
 		else
@@ -552,28 +605,29 @@
 		echo rs6000-ibm-aix3.2
 	fi
 	exit ;;
-    *:AIX:*:[456])
+    *:AIX:*:[4567])
 	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
-	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
+	if /usr/sbin/lsattr -El "$IBM_CPU_ID" | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
+	if [ -x /usr/bin/lslpp ] ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
 	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
 	fi
-	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+	echo "$IBM_ARCH"-ibm-aix"$IBM_REV"
 	exit ;;
     *:AIX:*:*)
 	echo rs6000-ibm-aix
 	exit ;;
-    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+    ibmrt:4.4BSD:*|romp-ibm:4.4BSD:*)
 	echo romp-ibm-bsd4.4
 	exit ;;
     ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
-	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	echo romp-ibm-bsd"$UNAME_RELEASE"   # 4.3 with uname added to
 	exit ;;                             # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
 	echo rs6000-bull-bosx
@@ -588,67 +642,67 @@
 	echo m68k-hp-bsd4.4
 	exit ;;
     9000/[34678]??:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	case "${UNAME_MACHINE}" in
-	    9000/31? )            HP_ARCH=m68000 ;;
-	    9000/[34]?? )         HP_ARCH=m68k ;;
+	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
+	case "$UNAME_MACHINE" in
+	    9000/31?)            HP_ARCH=m68000 ;;
+	    9000/[34]??)         HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
 		if [ -x /usr/bin/getconf ]; then
 		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
-                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
-                    case "${sc_cpu_version}" in
-                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
-                      532)                      # CPU_PA_RISC2_0
-                        case "${sc_kernel_bits}" in
-                          32) HP_ARCH="hppa2.0n" ;;
-                          64) HP_ARCH="hppa2.0w" ;;
-			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
-                        esac ;;
-                    esac
+		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+		    case "$sc_cpu_version" in
+		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
+		      532)                      # CPU_PA_RISC2_0
+			case "$sc_kernel_bits" in
+			  32) HP_ARCH=hppa2.0n ;;
+			  64) HP_ARCH=hppa2.0w ;;
+			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
+			esac ;;
+		    esac
 		fi
-		if [ "${HP_ARCH}" = "" ]; then
-		    eval $set_cc_for_build
-		    sed 's/^              //' << EOF >$dummy.c
-
-              #define _HPUX_SOURCE
-              #include <stdlib.h>
-              #include <unistd.h>
-
-              int main ()
-              {
-              #if defined(_SC_KERNEL_BITS)
-                  long bits = sysconf(_SC_KERNEL_BITS);
-              #endif
-                  long cpu  = sysconf (_SC_CPU_VERSION);
-
-                  switch (cpu)
-              	{
-              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
-              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
-              	case CPU_PA_RISC2_0:
-              #if defined(_SC_KERNEL_BITS)
-              	    switch (bits)
-              		{
-              		case 64: puts ("hppa2.0w"); break;
-              		case 32: puts ("hppa2.0n"); break;
-              		default: puts ("hppa2.0"); break;
-              		} break;
-              #else  /* !defined(_SC_KERNEL_BITS) */
-              	    puts ("hppa2.0"); break;
-              #endif
-              	default: puts ("hppa1.0"); break;
-              	}
-                  exit (0);
-              }
+		if [ "$HP_ARCH" = "" ]; then
+		    set_cc_for_build
+		    sed 's/^		//' << EOF > "$dummy.c"
+
+		#define _HPUX_SOURCE
+		#include <stdlib.h>
+		#include <unistd.h>
+
+		int main ()
+		{
+		#if defined(_SC_KERNEL_BITS)
+		    long bits = sysconf(_SC_KERNEL_BITS);
+		#endif
+		    long cpu  = sysconf (_SC_CPU_VERSION);
+
+		    switch (cpu)
+			{
+			case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+			case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+			case CPU_PA_RISC2_0:
+		#if defined(_SC_KERNEL_BITS)
+			    switch (bits)
+				{
+				case 64: puts ("hppa2.0w"); break;
+				case 32: puts ("hppa2.0n"); break;
+				default: puts ("hppa2.0"); break;
+				} break;
+		#else  /* !defined(_SC_KERNEL_BITS) */
+			    puts ("hppa2.0"); break;
+		#endif
+			default: puts ("hppa1.0"); break;
+			}
+		    exit (0);
+		}
 EOF
-		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    (CCOPTS="" $CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null) && HP_ARCH=`"$dummy"`
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
-	if [ ${HP_ARCH} = "hppa2.0w" ]
+	if [ "$HP_ARCH" = hppa2.0w ]
 	then
-	    eval $set_cc_for_build
+	    set_cc_for_build
 
 	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
 	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
@@ -659,23 +713,23 @@
 	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
 	    # => hppa64-hp-hpux11.23
 
-	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+	    if echo __LP64__ | (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) |
 		grep -q __LP64__
 	    then
-		HP_ARCH="hppa2.0w"
+		HP_ARCH=hppa2.0w
 	    else
-		HP_ARCH="hppa64"
+		HP_ARCH=hppa64
 	    fi
 	fi
-	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+	echo "$HP_ARCH"-hp-hpux"$HPUX_REV"
 	exit ;;
     ia64:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	echo ia64-hp-hpux${HPUX_REV}
+	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
+	echo ia64-hp-hpux"$HPUX_REV"
 	exit ;;
     3050*:HI-UX:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
+	set_cc_for_build
+	sed 's/^	//' << EOF > "$dummy.c"
 	#include <unistd.h>
 	int
 	main ()
@@ -700,11 +754,11 @@
 	  exit (0);
 	}
 EOF
-	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"` &&
 		{ echo "$SYSTEM_NAME"; exit; }
 	echo unknown-hitachi-hiuxwe2
 	exit ;;
-    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)
 	echo hppa1.1-hp-bsd
 	exit ;;
     9000/8??:4.3bsd:*:*)
@@ -713,7 +767,7 @@
     *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
 	echo hppa1.0-hp-mpeix
 	exit ;;
-    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)
 	echo hppa1.1-hp-osf
 	exit ;;
     hp8??:OSF1:*:*)
@@ -721,9 +775,9 @@
 	exit ;;
     i*86:OSF1:*:*)
 	if [ -x /usr/sbin/sysversion ] ; then
-	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	    echo "$UNAME_MACHINE"-unknown-osf1mk
 	else
-	    echo ${UNAME_MACHINE}-unknown-osf1
+	    echo "$UNAME_MACHINE"-unknown-osf1
 	fi
 	exit ;;
     parisc*:Lites*:*:*)
@@ -731,132 +785,137 @@
 	exit ;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
 	echo c1-convex-bsd
-        exit ;;
+	exit ;;
     C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
 	if getsysinfo -f scalar_acc
 	then echo c32-convex-bsd
 	else echo c2-convex-bsd
 	fi
-        exit ;;
+	exit ;;
     C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
 	echo c34-convex-bsd
-        exit ;;
+	exit ;;
     C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
 	echo c38-convex-bsd
-        exit ;;
+	exit ;;
     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
 	echo c4-convex-bsd
-        exit ;;
+	exit ;;
     CRAY*Y-MP:*:*:*)
-	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo ymp-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*[A-Z]90:*:*:*)
-	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	echo "$UNAME_MACHINE"-cray-unicos"$UNAME_RELEASE" \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
 	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
 	      -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*TS:*:*:*)
-	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo t90-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*T3E:*:*:*)
-	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo alphaev5-cray-unicosmk"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     CRAY*SV1:*:*:*)
-	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo sv1-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     *:UNICOS/mp:*:*)
-	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo craynv-cray-unicosmp"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
-        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
-        exit ;;
+	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | sed -e 's/ /_/'`
+	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
     5000:UNIX_System_V:4.*:*)
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
-        echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
+	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
-	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-pc-bsdi"$UNAME_RELEASE"
 	exit ;;
     sparc*:BSD/OS:*:*)
-	echo sparc-unknown-bsdi${UNAME_RELEASE}
+	echo sparc-unknown-bsdi"$UNAME_RELEASE"
 	exit ;;
     *:BSD/OS:*:*)
-	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-unknown-bsdi"$UNAME_RELEASE"
+	exit ;;
+    arm:FreeBSD:*:*)
+	UNAME_PROCESSOR=`uname -p`
+	set_cc_for_build
+	if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_PCS_VFP
+	then
+	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabi
+	else
+	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabihf
+	fi
 	exit ;;
     *:FreeBSD:*:*)
-	case ${UNAME_MACHINE} in
-	    pc98)
-		echo i386-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	case "$UNAME_PROCESSOR" in
 	    amd64)
-		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
-	    *)
-		echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+		UNAME_PROCESSOR=x86_64 ;;
+	    i386)
+		UNAME_PROCESSOR=i586 ;;
 	esac
+	echo "$UNAME_PROCESSOR"-unknown-freebsd"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
 	exit ;;
     i*:CYGWIN*:*)
-	echo ${UNAME_MACHINE}-pc-cygwin
+	echo "$UNAME_MACHINE"-pc-cygwin
+	exit ;;
+    *:MINGW64*:*)
+	echo "$UNAME_MACHINE"-pc-mingw64
 	exit ;;
     *:MINGW*:*)
-	echo ${UNAME_MACHINE}-pc-mingw32
+	echo "$UNAME_MACHINE"-pc-mingw32
 	exit ;;
-    i*:windows32*:*)
-    	# uname -m includes "-pc" on this system.
-    	echo ${UNAME_MACHINE}-mingw32
+    *:MSYS*:*)
+	echo "$UNAME_MACHINE"-pc-msys
 	exit ;;
     i*:PW*:*)
-	echo ${UNAME_MACHINE}-pc-pw32
+	echo "$UNAME_MACHINE"-pc-pw32
 	exit ;;
     *:Interix*:*)
-    	case ${UNAME_MACHINE} in
+	case "$UNAME_MACHINE" in
 	    x86)
-		echo i586-pc-interix${UNAME_RELEASE}
+		echo i586-pc-interix"$UNAME_RELEASE"
 		exit ;;
 	    authenticamd | genuineintel | EM64T)
-		echo x86_64-unknown-interix${UNAME_RELEASE}
+		echo x86_64-unknown-interix"$UNAME_RELEASE"
 		exit ;;
 	    IA64)
-		echo ia64-unknown-interix${UNAME_RELEASE}
+		echo ia64-unknown-interix"$UNAME_RELEASE"
 		exit ;;
 	esac ;;
-    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
-	echo i${UNAME_MACHINE}-pc-mks
-	exit ;;
-    8664:Windows_NT:*)
-	echo x86_64-pc-mks
-	exit ;;
-    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
-	# UNAME_MACHINE based on the output of uname instead of i386?
-	echo i586-pc-interix
-	exit ;;
     i*:UWIN*:*)
-	echo ${UNAME_MACHINE}-pc-uwin
+	echo "$UNAME_MACHINE"-pc-uwin
 	exit ;;
     amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
-	echo x86_64-unknown-cygwin
-	exit ;;
-    p*:CYGWIN*:*)
-	echo powerpcle-unknown-cygwin
+	echo x86_64-pc-cygwin
 	exit ;;
     prep*:SunOS:5.*:*)
-	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	echo powerpcle-unknown-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
 	exit ;;
     *:GNU:*:*)
 	# the GNU system
-	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	echo "`echo "$UNAME_MACHINE"|sed -e 's,[-/].*$,,'`-unknown-$LIBC`echo "$UNAME_RELEASE"|sed -e 's,/.*$,,'`"
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-gnu
+	echo "$UNAME_MACHINE-unknown-`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`-$LIBC"
+	exit ;;
+    *:Minix:*:*)
+	echo "$UNAME_MACHINE"-unknown-minix
+	exit ;;
+    aarch64:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
-    i*86:Minix:*:*)
-	echo ${UNAME_MACHINE}-pc-minix
+    aarch64_be:Linux:*:*)
+	UNAME_MACHINE=aarch64_be
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     alpha:Linux:*:*)
 	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
@@ -867,115 +926,171 @@
 	  EV6)   UNAME_MACHINE=alphaev6 ;;
 	  EV67)  UNAME_MACHINE=alphaev67 ;;
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
-        esac
+	esac
 	objdump --private-headers /bin/sh | grep -q ld.so.1
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    arc:Linux:*:* | arceb:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     arm*:Linux:*:*)
-	eval $set_cc_for_build
+	set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
-	    echo ${UNAME_MACHINE}-unknown-linux-gnu
+	    echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	else
-	    echo ${UNAME_MACHINE}-unknown-linux-gnueabi
+	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+		| grep -q __ARM_PCS_VFP
+	    then
+		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabi
+	    else
+		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabihf
+	    fi
 	fi
 	exit ;;
     avr32*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     cris:Linux:*:*)
-	echo cris-axis-linux-gnu
+	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
 	exit ;;
     crisv32:Linux:*:*)
-	echo crisv32-axis-linux-gnu
+	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
+	exit ;;
+    e2k:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     frv:Linux:*:*)
-    	echo frv-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    hexagon:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     i*86:Linux:*:*)
-	LIBC=gnu
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC'`
-	echo "${UNAME_MACHINE}-pc-linux-${LIBC}"
+	echo "$UNAME_MACHINE"-pc-linux-"$LIBC"
 	exit ;;
     ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    k1om:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     m32r*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     mips:Linux:*:* | mips64:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
+	set_cc_for_build
+	IS_GLIBC=0
+	test x"${LIBC}" = xgnu && IS_GLIBC=1
+	sed 's/^	//' << EOF > "$dummy.c"
 	#undef CPU
-	#undef ${UNAME_MACHINE}
-	#undef ${UNAME_MACHINE}el
+	#undef mips
+	#undef mipsel
+	#undef mips64
+	#undef mips64el
+	#if ${IS_GLIBC} && defined(_ABI64)
+	LIBCABI=gnuabi64
+	#else
+	#if ${IS_GLIBC} && defined(_ABIN32)
+	LIBCABI=gnuabin32
+	#else
+	LIBCABI=${LIBC}
+	#endif
+	#endif
+
+	#if ${IS_GLIBC} && defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa64r6
+	#else
+	#if ${IS_GLIBC} && !defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa32r6
+	#else
+	#if defined(__mips64)
+	CPU=mips64
+	#else
+	CPU=mips
+	#endif
+	#endif
+	#endif
+
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=${UNAME_MACHINE}el
+	MIPS_ENDIAN=el
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=${UNAME_MACHINE}
+	MIPS_ENDIAN=
 	#else
-	CPU=
+	MIPS_ENDIAN=
 	#endif
 	#endif
 EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
-	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-gnu"; exit; }
+	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI'`"
+	test "x$CPU" != x && { echo "$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI"; exit; }
 	;;
-    or32:Linux:*:*)
-	echo or32-unknown-linux-gnu
+    mips64el:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    openrisc*:Linux:*:*)
+	echo or1k-unknown-linux-"$LIBC"
+	exit ;;
+    or32:Linux:*:* | or1k*:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     padre:Linux:*:*)
-	echo sparc-unknown-linux-gnu
+	echo sparc-unknown-linux-"$LIBC"
 	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
+	echo hppa64-unknown-linux-"$LIBC"
 	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
 	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
+	  PA7*) echo hppa1.1-unknown-linux-"$LIBC" ;;
+	  PA8*) echo hppa2.0-unknown-linux-"$LIBC" ;;
+	  *)    echo hppa-unknown-linux-"$LIBC" ;;
 	esac
 	exit ;;
     ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
+	echo powerpc64-unknown-linux-"$LIBC"
 	exit ;;
     ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
+	echo powerpc-unknown-linux-"$LIBC"
+	exit ;;
+    ppc64le:Linux:*:*)
+	echo powerpc64le-unknown-linux-"$LIBC"
+	exit ;;
+    ppcle:Linux:*:*)
+	echo powerpcle-unknown-linux-"$LIBC"
+	exit ;;
+    riscv32:Linux:*:* | riscv64:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
+	echo "$UNAME_MACHINE"-ibm-linux-"$LIBC"
 	exit ;;
     sh64*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    tile*:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     vax:Linux:*:*)
-	echo ${UNAME_MACHINE}-dec-linux-gnu
+	echo "$UNAME_MACHINE"-dec-linux-"$LIBC"
 	exit ;;
     x86_64:Linux:*:*)
-	echo x86_64-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-pc-linux-"$LIBC"
 	exit ;;
     xtensa*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
@@ -984,54 +1099,54 @@
 	echo i386-sequent-sysv4
 	exit ;;
     i*86:UNIX_SV:4.2MP:2.*)
-        # Unixware is an offshoot of SVR4, but it has its own version
-        # number series starting with 2...
-        # I am not positive that other SVR4 systems won't match this,
+	# Unixware is an offshoot of SVR4, but it has its own version
+	# number series starting with 2...
+	# I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
-        # Use sysv4.2uw... so that sysv4* matches it.
-	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
+	# Use sysv4.2uw... so that sysv4* matches it.
+	echo "$UNAME_MACHINE"-pc-sysv4.2uw"$UNAME_VERSION"
 	exit ;;
     i*86:OS/2:*:*)
 	# If we were able to find `uname', then EMX Unix compatibility
 	# is probably installed.
-	echo ${UNAME_MACHINE}-pc-os2-emx
+	echo "$UNAME_MACHINE"-pc-os2-emx
 	exit ;;
     i*86:XTS-300:*:STOP)
-	echo ${UNAME_MACHINE}-unknown-stop
+	echo "$UNAME_MACHINE"-unknown-stop
 	exit ;;
     i*86:atheos:*:*)
-	echo ${UNAME_MACHINE}-unknown-atheos
+	echo "$UNAME_MACHINE"-unknown-atheos
 	exit ;;
     i*86:syllable:*:*)
-	echo ${UNAME_MACHINE}-pc-syllable
+	echo "$UNAME_MACHINE"-pc-syllable
 	exit ;;
     i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
-	echo i386-unknown-lynxos${UNAME_RELEASE}
+	echo i386-unknown-lynxos"$UNAME_RELEASE"
 	exit ;;
     i*86:*DOS:*:*)
-	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+	echo "$UNAME_MACHINE"-pc-msdosdjgpp
 	exit ;;
-    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
-	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+    i*86:*:4.*:*)
+	UNAME_REL=`echo "$UNAME_RELEASE" | sed 's/\/MP$//'`
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
-		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
+		echo "$UNAME_MACHINE"-univel-sysv"$UNAME_REL"
 	else
-		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+		echo "$UNAME_MACHINE"-pc-sysv"$UNAME_REL"
 	fi
 	exit ;;
     i*86:*:5:[678]*)
-    	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	# UnixWare 7.x, OpenUNIX and OpenServer 6.
 	case `/bin/uname -X | grep "^Machine"` in
 	    *486*)	     UNAME_MACHINE=i486 ;;
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
 	esac
-	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	echo "$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}"
 	exit ;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
-		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+		echo "$UNAME_MACHINE"-pc-isc"$UNAME_REL"
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
 		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
 		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
@@ -1041,20 +1156,20 @@
 			&& UNAME_MACHINE=i686
 		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
 			&& UNAME_MACHINE=i686
-		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+		echo "$UNAME_MACHINE"-pc-sco"$UNAME_REL"
 	else
-		echo ${UNAME_MACHINE}-pc-sysv32
+		echo "$UNAME_MACHINE"-pc-sysv32
 	fi
 	exit ;;
     pc:*:*:*)
 	# Left here for compatibility:
-        # uname -m prints for DJGPP always 'pc', but it prints nothing about
-        # the processor, so we play safe by assuming i586.
+	# uname -m prints for DJGPP always 'pc', but it prints nothing about
+	# the processor, so we play safe by assuming i586.
 	# Note: whatever this is, it MUST be the same as what config.sub
-	# prints for the "djgpp" host, or else GDB configury will decide that
+	# prints for the "djgpp" host, or else GDB configure will decide that
 	# this is a cross-build.
 	echo i586-pc-msdosdjgpp
-        exit ;;
+	exit ;;
     Intel:Mach:3*:*)
 	echo i386-pc-mach3
 	exit ;;
@@ -1063,9 +1178,9 @@
 	exit ;;
     i860:*:4.*:*) # i860-SVR4
 	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
-	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	  echo i860-stardent-sysv"$UNAME_RELEASE" # Stardent Vistra i860-SVR4
 	else # Add other i860-SVR4 vendors below as they are discovered.
-	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	  echo i860-unknown-sysv"$UNAME_RELEASE"  # Unknown i860-SVR4
 	fi
 	exit ;;
     mini*:CTIX:SYS*5:*)
@@ -1085,39 +1200,39 @@
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	  && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+	  && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
-        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-          && { echo i486-ncr-sysv4; exit; } ;;
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4; exit; } ;;
     NCR*:*:4.2:* | MPRAS*:*:4.2:*)
 	OS_REL='.3'
 	test -r /etc/.relid \
 	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-	    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	    && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
-	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }
+	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
-	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
-	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	echo m68k-unknown-lynxos"$UNAME_RELEASE"
 	exit ;;
     mc68030:UNIX_System_V:4.*:*)
 	echo m68k-atari-sysv4
 	exit ;;
     TSUNAMI:LynxOS:2.*:*)
-	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	echo sparc-unknown-lynxos"$UNAME_RELEASE"
 	exit ;;
     rs6000:LynxOS:2.*:*)
-	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	echo rs6000-unknown-lynxos"$UNAME_RELEASE"
 	exit ;;
     PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
-	echo powerpc-unknown-lynxos${UNAME_RELEASE}
+	echo powerpc-unknown-lynxos"$UNAME_RELEASE"
 	exit ;;
     SM[BE]S:UNIX_SV:*:*)
-	echo mips-dde-sysv${UNAME_RELEASE}
+	echo mips-dde-sysv"$UNAME_RELEASE"
 	exit ;;
     RM*:ReliantUNIX-*:*:*)
 	echo mips-sni-sysv4
@@ -1128,15 +1243,15 @@
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
-		echo ${UNAME_MACHINE}-sni-sysv4
+		echo "$UNAME_MACHINE"-sni-sysv4
 	else
 		echo ns32k-sni-sysv
 	fi
 	exit ;;
-    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
-                      # says <Richard.M.Bartel@ccMail.Census.GOV>
-        echo i586-unisys-sysv4
-        exit ;;
+    PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+			# says <Richard.M.Bartel@ccMail.Census.GOV>
+	echo i586-unisys-sysv4
+	exit ;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
@@ -1148,25 +1263,25 @@
 	exit ;;
     i*86:VOS:*:*)
 	# From Paul.Green@stratus.com.
-	echo ${UNAME_MACHINE}-stratus-vos
+	echo "$UNAME_MACHINE"-stratus-vos
 	exit ;;
     *:VOS:*:*)
 	# From Paul.Green@stratus.com.
 	echo hppa1.1-stratus-vos
 	exit ;;
     mc68*:A/UX:*:*)
-	echo m68k-apple-aux${UNAME_RELEASE}
+	echo m68k-apple-aux"$UNAME_RELEASE"
 	exit ;;
     news*:NEWS-OS:6*:*)
 	echo mips-sony-newsos6
 	exit ;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
 	if [ -d /usr/nec ]; then
-	        echo mips-nec-sysv${UNAME_RELEASE}
+		echo mips-nec-sysv"$UNAME_RELEASE"
 	else
-	        echo mips-unknown-sysv${UNAME_RELEASE}
+		echo mips-unknown-sysv"$UNAME_RELEASE"
 	fi
-        exit ;;
+	exit ;;
     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
 	echo powerpc-be-beos
 	exit ;;
@@ -1179,63 +1294,97 @@
     BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
 	echo i586-pc-haiku
 	exit ;;
+    x86_64:Haiku:*:*)
+	echo x86_64-unknown-haiku
+	exit ;;
     SX-4:SUPER-UX:*:*)
-	echo sx4-nec-superux${UNAME_RELEASE}
+	echo sx4-nec-superux"$UNAME_RELEASE"
 	exit ;;
     SX-5:SUPER-UX:*:*)
-	echo sx5-nec-superux${UNAME_RELEASE}
+	echo sx5-nec-superux"$UNAME_RELEASE"
 	exit ;;
     SX-6:SUPER-UX:*:*)
-	echo sx6-nec-superux${UNAME_RELEASE}
+	echo sx6-nec-superux"$UNAME_RELEASE"
 	exit ;;
     SX-7:SUPER-UX:*:*)
-	echo sx7-nec-superux${UNAME_RELEASE}
+	echo sx7-nec-superux"$UNAME_RELEASE"
 	exit ;;
     SX-8:SUPER-UX:*:*)
-	echo sx8-nec-superux${UNAME_RELEASE}
+	echo sx8-nec-superux"$UNAME_RELEASE"
 	exit ;;
     SX-8R:SUPER-UX:*:*)
-	echo sx8r-nec-superux${UNAME_RELEASE}
+	echo sx8r-nec-superux"$UNAME_RELEASE"
+	exit ;;
+    SX-ACE:SUPER-UX:*:*)
+	echo sxace-nec-superux"$UNAME_RELEASE"
 	exit ;;
     Power*:Rhapsody:*:*)
-	echo powerpc-apple-rhapsody${UNAME_RELEASE}
+	echo powerpc-apple-rhapsody"$UNAME_RELEASE"
 	exit ;;
     *:Rhapsody:*:*)
-	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-apple-rhapsody"$UNAME_RELEASE"
 	exit ;;
     *:Darwin:*:*)
 	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	case $UNAME_PROCESSOR in
-	    i386)
-		eval $set_cc_for_build
-		if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
-		  if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		      (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
-		      grep IS_64BIT_ARCH >/dev/null
-		  then
-		      UNAME_PROCESSOR="x86_64"
-		  fi
-		fi ;;
-	    unknown) UNAME_PROCESSOR=powerpc ;;
-	esac
-	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
+	set_cc_for_build
+	if test "$UNAME_PROCESSOR" = unknown ; then
+	    UNAME_PROCESSOR=powerpc
+	fi
+	if test "`echo "$UNAME_RELEASE" | sed -e 's/\..*//'`" -le 10 ; then
+	    if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		       grep IS_64BIT_ARCH >/dev/null
+		then
+		    case $UNAME_PROCESSOR in
+			i386) UNAME_PROCESSOR=x86_64 ;;
+			powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		    esac
+		fi
+		# On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
+		if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
+		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		       grep IS_PPC >/dev/null
+		then
+		    UNAME_PROCESSOR=powerpc
+		fi
+	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # Avoid executing cc on OS X 10.9, as it ships with a stub
+	    # that puts up a graphical alert prompting to install
+	    # developer tools.  Any system running Mac OS X 10.7 or
+	    # later (Darwin 11 and later) is required to have a 64-bit
+	    # processor. This is not true of the ARM version of Darwin
+	    # that Apple uses in portable devices.
+	    UNAME_PROCESSOR=x86_64
+	fi
+	echo "$UNAME_PROCESSOR"-apple-darwin"$UNAME_RELEASE"
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
 	UNAME_PROCESSOR=`uname -p`
-	if test "$UNAME_PROCESSOR" = "x86"; then
+	if test "$UNAME_PROCESSOR" = x86; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
-	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
+	echo "$UNAME_PROCESSOR"-"$UNAME_MACHINE"-nto-qnx"$UNAME_RELEASE"
 	exit ;;
     *:QNX:*:4*)
 	echo i386-pc-qnx
 	exit ;;
-    NSE-?:NONSTOP_KERNEL:*:*)
-	echo nse-tandem-nsk${UNAME_RELEASE}
+    NEO-*:NONSTOP_KERNEL:*:*)
+	echo neo-tandem-nsk"$UNAME_RELEASE"
 	exit ;;
-    NSR-?:NONSTOP_KERNEL:*:*)
-	echo nsr-tandem-nsk${UNAME_RELEASE}
+    NSE-*:NONSTOP_KERNEL:*:*)
+	echo nse-tandem-nsk"$UNAME_RELEASE"
+	exit ;;
+    NSR-*:NONSTOP_KERNEL:*:*)
+	echo nsr-tandem-nsk"$UNAME_RELEASE"
+	exit ;;
+    NSV-*:NONSTOP_KERNEL:*:*)
+	echo nsv-tandem-nsk"$UNAME_RELEASE"
+	exit ;;
+    NSX-*:NONSTOP_KERNEL:*:*)
+	echo nsx-tandem-nsk"$UNAME_RELEASE"
 	exit ;;
     *:NonStop-UX:*:*)
 	echo mips-compaq-nonstopux
@@ -1244,18 +1393,19 @@
 	echo bs2000-siemens-sysv
 	exit ;;
     DS/*:UNIX_System_V:*:*)
-	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
+	echo "$UNAME_MACHINE"-"$UNAME_SYSTEM"-"$UNAME_RELEASE"
 	exit ;;
     *:Plan9:*:*)
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
-	if test "$cputype" = "386"; then
+	# shellcheck disable=SC2154
+	if test "$cputype" = 386; then
 	    UNAME_MACHINE=i386
 	else
 	    UNAME_MACHINE="$cputype"
 	fi
-	echo ${UNAME_MACHINE}-unknown-plan9
+	echo "$UNAME_MACHINE"-unknown-plan9
 	exit ;;
     *:TOPS-10:*:*)
 	echo pdp10-unknown-tops10
@@ -1276,14 +1426,14 @@
 	echo pdp10-unknown-its
 	exit ;;
     SEI:*:*:SEIUX)
-        echo mips-sei-seiux${UNAME_RELEASE}
+	echo mips-sei-seiux"$UNAME_RELEASE"
 	exit ;;
     *:DragonFly:*:*)
-	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	echo "$UNAME_MACHINE"-unknown-dragonfly"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
 	exit ;;
     *:*VMS:*:*)
-    	UNAME_MACHINE=`(uname -p) 2>/dev/null`
-	case "${UNAME_MACHINE}" in
+	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case "$UNAME_MACHINE" in
 	    A*) echo alpha-dec-vms ; exit ;;
 	    I*) echo ia64-dec-vms ; exit ;;
 	    V*) echo vax-dec-vms ; exit ;;
@@ -1292,24 +1442,39 @@
 	echo i386-pc-xenix
 	exit ;;
     i*86:skyos:*:*)
-	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	echo "$UNAME_MACHINE"-pc-skyos"`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`"
 	exit ;;
     i*86:rdos:*:*)
-	echo ${UNAME_MACHINE}-pc-rdos
+	echo "$UNAME_MACHINE"-pc-rdos
 	exit ;;
     i*86:AROS:*:*)
-	echo ${UNAME_MACHINE}-pc-aros
+	echo "$UNAME_MACHINE"-pc-aros
+	exit ;;
+    x86_64:VMkernel:*:*)
+	echo "$UNAME_MACHINE"-unknown-esx
+	exit ;;
+    amd64:Isilon\ OneFS:*:*)
+	echo x86_64-unknown-onefs
+	exit ;;
+    *:Unleashed:*:*)
+	echo "$UNAME_MACHINE"-unknown-unleashed"$UNAME_RELEASE"
 	exit ;;
 esac
 
-#echo '(No uname command or uname output not recognized.)' 1>&2
-#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
-
-eval $set_cc_for_build
-cat >$dummy.c <<EOF
+# No uname command or uname output not recognized.
+set_cc_for_build
+cat > "$dummy.c" <<EOF
 #ifdef _SEQUENT_
-# include <sys/types.h>
-# include <sys/utsname.h>
+#include <sys/types.h>
+#include <sys/utsname.h>
+#endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined (vax) || defined (__vax) || defined (__vax__) || defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#include <signal.h>
+#if defined(_SIZE_T_) || defined(SIGLOST)
+#include <sys/utsname.h>
+#endif
+#endif
 #endif
 main ()
 {
@@ -1322,22 +1487,14 @@
 #include <sys/param.h>
   printf ("m68k-sony-newsos%s\n",
 #ifdef NEWSOS4
-          "4"
+  "4"
 #else
-	  ""
+  ""
 #endif
-         ); exit (0);
+  ); exit (0);
 #endif
 #endif
 
-#if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix\n"); exit (0);
-#endif
-
-#if defined (hp300) && !defined (hpux)
-  printf ("m68k-hp-bsd\n"); exit (0);
-#endif
-
 #if defined (NeXT)
 #if !defined (__ARCHITECTURE__)
 #define __ARCHITECTURE__ "m68k"
@@ -1377,39 +1534,54 @@
 #endif
 
 #if defined (_SEQUENT_)
-    struct utsname un;
-
-    uname(&un);
-
-    if (strncmp(un.version, "V2", 2) == 0) {
-	printf ("i386-sequent-ptx2\n"); exit (0);
-    }
-    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
-	printf ("i386-sequent-ptx1\n"); exit (0);
-    }
-    printf ("i386-sequent-ptx\n"); exit (0);
+  struct utsname un;
 
+  uname(&un);
+  if (strncmp(un.version, "V2", 2) == 0) {
+    printf ("i386-sequent-ptx2\n"); exit (0);
+  }
+  if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+    printf ("i386-sequent-ptx1\n"); exit (0);
+  }
+  printf ("i386-sequent-ptx\n"); exit (0);
 #endif
 
 #if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
+#if !defined (ultrix)
+#include <sys/param.h>
+#if defined (BSD)
+#if BSD == 43
+  printf ("vax-dec-bsd4.3\n"); exit (0);
+#else
+#if BSD == 199006
+  printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#endif
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#else
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname un;
+  uname (&un);
+  printf ("vax-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("vax-dec-ultrix\n"); exit (0);
+#endif
+#endif
+#endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname *un;
+  uname (&un);
+  printf ("mips-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("mips-dec-ultrix\n"); exit (0);
+#endif  
+#endif
 #endif
 
 #if defined (alliant) && defined (i860)
@@ -1420,54 +1592,38 @@
 }
 EOF
 
-$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=`$dummy` &&
 	{ echo "$SYSTEM_NAME"; exit; }
 
 # Apollos put the system type in the environment.
+test -d /usr/apollo && { echo "$ISP-apollo-$SYSTYPE"; exit; }
 
-test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
+echo "$0: unable to guess system type" >&2
 
-# Convex versions that predate uname can use getsysinfo(1)
+case "$UNAME_MACHINE:$UNAME_SYSTEM" in
+    mips:Linux | mips64:Linux)
+	# If we got here on MIPS GNU/Linux, output extra information.
+	cat >&2 <<EOF
 
-if [ -x /usr/convex/getsysinfo ]
-then
-    case `getsysinfo -f cpu_type` in
-    c1*)
-	echo c1-convex-bsd
-	exit ;;
-    c2*)
-	if getsysinfo -f scalar_acc
-	then echo c32-convex-bsd
-	else echo c2-convex-bsd
-	fi
-	exit ;;
-    c34*)
-	echo c34-convex-bsd
-	exit ;;
-    c38*)
-	echo c38-convex-bsd
-	exit ;;
-    c4*)
-	echo c4-convex-bsd
-	exit ;;
-    esac
-fi
+NOTE: MIPS GNU/Linux systems require a C compiler to fully recognize
+the system type. Please install a C compiler and try again.
+EOF
+	;;
+esac
 
 cat >&2 <<EOF
-$0: unable to guess system type
 
-This script, last modified $timestamp, has failed to recognize
-the operating system you are using. It is advised that you
-download the most up to date version of the config scripts from
+This script (version $timestamp), has failed to recognize the
+operating system you are using. If your script is old, overwrite *all*
+copies of config.guess and config.sub with the latest versions from:
 
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
 and
-  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
 
-If the version you run ($0) is already up to date, please
-send the following data and any information you think might be
-pertinent to <config-patches@gnu.org> in order to provide the needed
-information to handle your system.
+If $0 has already been updated, send the following data and any
+information you think might be pertinent to config-patches@gnu.org to
+provide the necessary information to handle your system.
 
 config.guess timestamp = $timestamp
 
@@ -1486,16 +1642,16 @@
 /usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
 /usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
 
-UNAME_MACHINE = ${UNAME_MACHINE}
-UNAME_RELEASE = ${UNAME_RELEASE}
-UNAME_SYSTEM  = ${UNAME_SYSTEM}
-UNAME_VERSION = ${UNAME_VERSION}
+UNAME_MACHINE = "$UNAME_MACHINE"
+UNAME_RELEASE = "$UNAME_RELEASE"
+UNAME_SYSTEM  = "$UNAME_SYSTEM"
+UNAME_VERSION = "$UNAME_VERSION"
 EOF
 
 exit 1
 
 # Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
+# eval: (add-hook 'before-save-hook 'time-stamp)
 # time-stamp-start: "timestamp='"
 # time-stamp-format: "%:y-%02m-%02d"
 # time-stamp-end: "'"
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/mdgx/CMakeLists.txt ./AmberTools/src/mdgx/CMakeLists.txt
--- AmberTools/src/mdgx/CMakeLists.txt	2022-08-29 08:42:34.000000000 +0900
+++ ./AmberTools/src/mdgx/CMakeLists.txt	2022-08-11 14:38:46.000000000 +0900
@@ -57,6 +57,10 @@
 
 #------------------------------------------------------------------------------------------
 
+if( "${COMPILER}" STREQUAL "FUJITSU" )
+        add_link_options("--linkfortran")
+endif()
+
 add_compile_options(${OPT_CFLAGS})
 include_directories($<TARGET_PROPERTY:fftw,INTERFACE_INCLUDE_DIRECTORIES> $<TARGET_PROPERTY:netcdf,INTERFACE_INCLUDE_DIRECTORIES>)
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/moft/Makefile ./AmberTools/src/moft/Makefile
--- AmberTools/src/moft/Makefile	2022-08-29 08:34:00.000000000 +0900
+++ ./AmberTools/src/moft/Makefile	2022-05-05 14:56:50.000000000 +0900
@@ -23,12 +23,20 @@
 install: $(BINDIR)/metatwist
 
 metatwist.o:  metatwist.cpp $(HEADERS)
-	@echo "[MoFT]  CXX $<"
-	$(VB)$(CXX) $(CXXFLAGS) -c -std=c++0x -I. -I$(INCDIR) -o $@ $<
+	@echo "[MoFT Compile]  CXX $<"
+	if [[ "$(CXX)" = *"FCC"* ]] ; then \
+	  FCC -Nclang -std=c++11 -O2 -c  -I. -I$(INCDIR) -o $@ $< ;\
+	else \
+	  $(VB)$(CXX) $(CXXFLAGS) -c -std=c++0x -I. -I$(INCDIR) -o $@ $< ;\
+	fi;
 
 $(BINDIR)/metatwist:  metatwist.o
-	@echo "[MoFT]  CXX $@"
-	$(VB)$(CXX) -std=c++0x -o $@ $< -L$(LIBDIR) $(BOOSTLIB) $(FLIBS_FFTW3) $(ZLIB) $(BZLIB)
+	@echo "[MoFT Link]  CXX $@"
+	if [[ "$(CXX)" = *"FCC"* ]] ; then \
+	  FCC -Nclang -std=c++11 -O2  -o  $@ $< -L$(LIBDIR) $(BOOSTLIB) $(FLIBS_FFTW3) $(ZLIB) $(BZLIB) ;\
+	else \
+	  $(VB)$(CXX) -std=c++0x -o $@ $< -L$(LIBDIR) $(BOOSTLIB) $(FLIBS_FFTW3) $(ZLIB) $(BZLIB) ;\
+	fi;
 
 clean:
 	/bin/rm -f *.o
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/nab/Makefile ./AmberTools/src/nab/Makefile
--- AmberTools/src/nab/Makefile	2022-08-29 08:41:39.000000000 +0900
+++ ./AmberTools/src/nab/Makefile	2022-05-05 14:56:46.000000000 +0900
@@ -86,6 +86,9 @@
 	@cp xmin_opt.h lmod_opt.h $(INCDIR)
 	@mv $(BINDIR)/$(MPI)nab$(SFX) $(BINDIR)/to_be_dispatched/
 	@cat nab_template | sed "s/REPLACE_ME/$(MPI)nab$(SFX)/g" > $(BINDIR)/$(MPI)nab$(SFX)
+	if [[ "$(CC)" == *"fcc"* ]]; then \
+                sed -i 's/nab$(SFX)/nab$(SFX) -w --linkfortran/g' $(BINDIR)/$(MPI)nab$(SFX); \
+        fi;
 	@chmod +x $(BINDIR)/$(MPI)nab$(SFX)
 #	cp lmodprmtop $(BINDIR)
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/netcdf-4.6.1/CMakeLists.txt ./AmberTools/src/netcdf-4.6.1/CMakeLists.txt
--- AmberTools/src/netcdf-4.6.1/CMakeLists.txt	2022-08-29 08:34:23.000000000 +0900
+++ ./AmberTools/src/netcdf-4.6.1/CMakeLists.txt	2022-08-03 15:37:38.000000000 +0900
@@ -207,7 +207,8 @@
   CHECK_C_LINKER_FLAG("-Wl,--no-undefined" LIBTOOL_HAS_NO_UNDEFINED)
 
   IF(LIBTOOL_HAS_NO_UNDEFINED)
-    SET(CMAKE_SHARED_LINKER_FLAGS_DEBUG "${CMAKE_SHARED_LINKER_FLAGS_DEBUG} -Wl,--no-undefined")
+	  #  SET(CMAKE_SHARED_LINKER_FLAGS_DEBUG "${CMAKE_SHARED_LINKER_FLAGS_DEBUG} -Wl,--no-undefined")
+	  MESSAGE(STATUS "Do not add -Wl,--no-undefine...")
   ENDIF()
   SET(CMAKE_REQUIRED_FLAGS "${TMP_CMAKE_REQUIRED_FLAGS}")
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/CMakeLists.txt ./AmberTools/src/pbsa/CMakeLists.txt
--- AmberTools/src/pbsa/CMakeLists.txt	2022-08-29 08:39:31.000000000 +0900
+++ ./AmberTools/src/pbsa/CMakeLists.txt	2022-08-25 08:32:56.000000000 +0900
@@ -66,6 +66,10 @@
 
 target_link_libraries(pbsa netlib amber_common netcdff netcdf)
 
+if( "${COMPILER}" STREQUAL "FUJITSU" )
+	add_link_options("--linkfortran")
+endif()
+
 #------------------------------------------------------------------------------------------
 #libpbsa
 add_library(libpbsa ${LIBPBSA_SOURCES})
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/Makefile ./AmberTools/src/pbsa/Makefile
--- AmberTools/src/pbsa/Makefile	2022-08-29 08:39:31.000000000 +0900
+++ ./AmberTools/src/pbsa/Makefile	2022-05-05 14:56:46.000000000 +0900
@@ -241,7 +241,11 @@
 
 .F90.o:   $<
 	@echo "[PBSA]  FC $<"
-	$(VB)$(FC) $(PBSAFLAG) $(FPPFLAGS) -c $(FOPTFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o $@ $< $(CU_define) -$(MATRIX_FMT)
+	if [[ "$(FC)" == "frt" ]]; then \
+	  $(FC) $(PBSAFLAG) $(FPPFLAGS) -c $(FFLAGS) -Kfast $(AMBERFFLAGS) -o $@ $< $(CU_define) -$(MATRIX_FMT) ;\
+	else \
+	  $(FC) $(PBSAFLAG) $(FPPFLAGS) -c $(FOPTFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o $@ $< $(CU_define) -$(MATRIX_FMT) ;\
+	fi ; 
 
 depend::
 	./makedepend > depend
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/bicg.F90 ./AmberTools/src/pbsa/bicg.F90
--- AmberTools/src/pbsa/bicg.F90	2022-08-29 08:39:31.000000000 +0900
+++ ./AmberTools/src/pbsa/bicg.F90	2022-05-05 14:56:46.000000000 +0900
@@ -39,18 +39,22 @@
       deallocate(a, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( a(1:nz_num), stat=ier); REQUIRE(ier==0)
+   a(:)=0
    if ( allocated(ja) ) then
       deallocate(ja, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( ja(1:xmymzm+1), stat=ier); REQUIRE(ier==0) ! this is row index
+   ja(:)=0
    if ( allocated(ia) ) then
       deallocate(ia, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( ia(1:nz_num), stat=ier); REQUIRE(ier==0) ! this is column index
+   ia(:)=0
    if ( allocated(f) ) then
       deallocate(f, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( f(1:xmymzm), stat=ier); REQUIRE(ier==0)
+   f(:)=0
 
    call setcsr(xm,ym,zm,nbnd,nz_num,index,index2,c2,bv,a,f,ia,ja)
 
@@ -347,22 +351,27 @@
       deallocate(p, stat = ier); REQUIRE(ier==0)
    end if
    allocate(p(xmymzm), stat=ier); REQUIRE(ier==0)
+   p(:)=0
    if ( allocated(q) ) then
       deallocate(q, stat = ier); REQUIRE(ier==0)
    end if
    allocate(q(xmymzm), stat=ier); REQUIRE(ier==0)
+   q(:)=0
    if ( allocated(r) ) then
       deallocate(r, stat = ier); REQUIRE(ier==0)
    end if
    allocate(r(xmymzm), stat=ier); REQUIRE(ier==0)
+   r(:)=0
    if ( allocated(r0) ) then
       deallocate(r0, stat = ier); REQUIRE(ier==0)
    end if
    allocate(r0(xmymzm), stat=ier); REQUIRE(ier==0)
+   r0(:)=0
    if ( allocated(t) ) then
       deallocate(t, stat = ier); REQUIRE(ier==0)
    end if
    allocate(t(xmymzm), stat=ier); REQUIRE(ier==0)
+   t(:)=0
 
    ! initialize r, r0, p, norm
    r = b
@@ -460,14 +469,17 @@
       deallocate(sa, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( sa(1:7*xmymzm), stat=ier); REQUIRE(ier==0)
+   sa(:)=0
    if ( allocated(su) ) then
       deallocate(su, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( su(1:xmymzm), stat=ier); REQUIRE(ier==0)
+   su(:)=0
    if ( allocated(sf) ) then
       deallocate(sf, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( sf(1:xmymzm), stat=ier); REQUIRE(ier==0)
+   sf(:)=0
 
    call setdia(xm,ym,zm,nbnd,epsin,epsout,h,c2,index,index2,bv,ioffset,sa,sf)
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/density.F90 ./AmberTools/src/pbsa/density.F90
--- AmberTools/src/pbsa/density.F90	2022-08-29 08:39:33.000000000 +0900
+++ ./AmberTools/src/pbsa/density.F90	2022-05-05 14:56:46.000000000 +0900
@@ -76,6 +76,7 @@
       deallocate(ndenatm, stat = ier); REQUIRE(ier==0)
    end if
    allocate(ndenatm(1:xm,1:ym,1:zm), stat = ier ); REQUIRE(ier==0)
+   ndenatm(:,:,:)=0
    ndenatm = 0
 
    ! WMSB: Add atomic density contribution using the inkblot method as in SES/SAS
@@ -92,6 +93,7 @@
          deallocate(lvlset_f, stat = ier); REQUIRE(ier==0)
       end if
       allocate(lvlset_f(0:xm+1, 0:ym+1, 0:zm+1))
+      lvlset_f(:,:,:)=0
 
       lvlset_f = ZERO
       call cuda_lvlset(natom, lvlset_f, xm, ym, zm, real(radi), real(rh), &
@@ -241,6 +243,7 @@
       deallocate(bndatmptr, stat = ier); REQUIRE(ier==0)
    end if
    allocate(bndatmptr(0:nbnd+8*natom), stat = ier); REQUIRE(ier==0)
+   bndatmptr(:)=0
    maxlst = 16*nint( dble(natom)*(THIRD*sqrt(cutfd)**3+TEN) )
 
    bndatmptr(0) = 0
@@ -254,10 +257,12 @@
       deallocate(bndatmlst, stat = ier); REQUIRE(ier==0)
    end if
    allocate(bndatmlst(maxlst), stat = ier); REQUIRE(ier==0)
+   bndatmlst(:)=0
    if ( allocated(tempcnt)   ) then
       deallocate(tempcnt  , stat = ier); REQUIRE(ier==0)
    end if
    allocate(tempcnt(1:nbnd+8*natom)  , stat = ier); REQUIRE(ier==0)
+   tempcnt(:)=0
    bndatmlst = 0
    tempcnt = 0
 
@@ -639,26 +644,32 @@
       deallocate(index , stat = ier); REQUIRE(ier==0)
    end if
    allocate (index (1:xm,1:ym,1:zm), stat = ier); REQUIRE(ier==0)
+   index (:,:,:)=0
    if ( allocated(index2)  ) then
       deallocate(index2, stat = ier); REQUIRE(ier==0)
    end if
    allocate (index2(1:xm,1:ym,1:zm), stat = ier); REQUIRE(ier==0)
+   index2(:,:,:)=0
    if ( allocated(x     )  ) then
       deallocate(x     , stat = ier); REQUIRE(ier==0)
    end if
    allocate (x     (0:xm+1        ), stat = ier); REQUIRE(ier==0)
+   x(:)=0
    if ( allocated(y     )  ) then
       deallocate(y     , stat = ier); REQUIRE(ier==0)
    end if
    allocate (y     (0:ym+1        ), stat = ier); REQUIRE(ier==0)
+   y(:)=0
    if ( allocated(z     )  ) then
       deallocate(z     , stat = ier); REQUIRE(ier==0)
    end if
    allocate (z     (0:zm+1        ), stat = ier); REQUIRE(ier==0)
+   z(:)=0
    if ( allocated(cirreg)  ) then
       deallocate(cirreg, stat = ier); REQUIRE(ier==0)
    end if
    allocate (cirreg(1:15,1:nbnd   ), stat = ier); REQUIRE(ier==0)
+   cirreg(:,:)=0
 
    ! setting coordinates of grid points
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/gmres.F90 ./AmberTools/src/pbsa/gmres.F90
--- AmberTools/src/pbsa/gmres.F90	2022-08-29 08:39:35.000000000 +0900
+++ ./AmberTools/src/pbsa/gmres.F90	2022-05-05 14:56:46.000000000 +0900
@@ -62,26 +62,35 @@
          print *,'allocate a(1:nz_num) failed',nda,ist
          stop
       end if
+      a(:)=0
+
       allocate ( ja(1:nz_num), stat=ist)
       if ( ist /= 0 ) then
          print *,'allocate ja(1:nz_num) failed',ndja,ist
          stop
       end if
+      ja(:)=0
+
       allocate ( ia(1:nz_num), stat=ist)
       if ( ist /= 0 ) then
          print *,'allocate ia(1:nz_num) failed',ndia,ist
          stop
       end if
+      ia(:)=0
+
       allocate ( u(1:xmymzm)  , stat=ist)
       if ( ist /= 0 ) then
          print *,'allocate u(1:xmymzm)   failed',ndu,ist
          stop
       end if
+      u(:)=0
+
       allocate ( f(1:xmymzm)  , stat=ist)
       if ( ist /= 0 ) then
          print *,'allocate f(1:xmymzm)   failed',ndf,ist
          stop
       end if
+      f(:)=0
 !     print *,'allocation success!'
 
 !     print *,'entering seta'
@@ -105,6 +114,8 @@
       !leniw = NL+NU+4*N+32
       leniw = nz_num+4*n+32
       allocate(rwork(lenw),iwork(leniw))
+      rwork(:)=0
+      iwork(:)=0
 
       call dslugm(n, f, u, nelt, ia, ja, a, isym, nsave, itol, &
            tol, itmax,iter,err,lierr,iunit,rwork,lenw, iwork,leniw)
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/parms.F90 ./AmberTools/src/pbsa/parms.F90
--- AmberTools/src/pbsa/parms.F90	2022-08-29 08:39:30.000000000 +0900
+++ ./AmberTools/src/pbsa/parms.F90	2022-05-05 14:56:46.000000000 +0900
@@ -69,6 +69,26 @@
       write(6,'(a)') 'ERROR allocating parameter arrays!'
       call mexit(6, 1)
    end if
+   rk(:)=0
+   req(:)=0
+   tk(:)=0
+   teq(:)=0
+   pk(:)=0
+   pn(:)=0
+   phase(:)=0
+   one_scnb(:)=0
+   one_scee(:)=0
+   gams(:)=0
+   gamc(:)=0
+   cn1(:)=0
+   cn2(:)=0
+   cn3(:)=0
+   cn4(:)=0
+   cn5(:)=0
+   solty(:)=0
+   asol(:)=0
+   bsol(:)=0
+   hbcut(:)=0
 
    allocate(ipn(nptra), stat=ierror)
 
@@ -76,6 +96,7 @@
       write(6,'(a)') 'ERROR allocating ipn array!'
       call mexit(6, 1)
    end if
+   ipn(:)=0
 
    return
 
@@ -113,6 +134,8 @@
       write(6, '(a)') 'ERROR extending rk/req in add_qmmm_bonds (parms.F90)'
       call mexit(6, 1)
    end if
+   rk(:)=0 
+   req(:)=0
 
    ! Restore our original rk, req and then extend it with our new values
    rk(1:orig_numbnd) = rk_holder(1:orig_numbnd)
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/pb_anaiim.F90 ./AmberTools/src/pbsa/pb_anaiim.F90
--- AmberTools/src/pbsa/pb_anaiim.F90	2022-08-29 08:39:32.000000000 +0900
+++ ./AmberTools/src/pbsa/pb_anaiim.F90	2022-05-05 14:56:46.000000000 +0900
@@ -308,10 +308,20 @@
 
    call pbtimer_start(PBTIME_PBBUILDSYS)
    allocate (wp(nbnd), qp(nbnd))  ! jump conditions at irregular points
+   wp(:)=0
+   qp(:)=0
    allocate (qyp(nbnd),qzp(nbnd)) ! tangential derivatives of field jump conditions
+   qyp(:)=0
+   qzp(:)=0
    allocate (wyp(nbnd),wzp(nbnd)) ! tangential derivatives of potential jump conditions
+   wyp(:)=0
+   wzp(:)=0
    allocate (wyyp(nbnd),wzzp(nbnd),wyzp(nbnd)) ! second derivatives of potential jump conditions
+   wyyp(:)=0
+   wzzp(:)=0
+   wyzp(:)=0
    allocate (c2(nbnd, 27)) ! A matrix coefficients
+   c2(:,:)=0
 
    ! the surface related infrastructure data from density_surface module is used
 
@@ -1141,6 +1151,7 @@
    qzp = ZERO
 
    allocate(lacrd(4,atmlast-atmfirst+1))
+   lacrd(:,:)=0
 
    do ir = 1, nirreg
       xx     = cirreg( 1, ir)
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/pb_augdrv.F90 ./AmberTools/src/pbsa/pb_augdrv.F90
--- AmberTools/src/pbsa/pb_augdrv.F90	2022-08-29 08:39:34.000000000 +0900
+++ ./AmberTools/src/pbsa/pb_augdrv.F90	2022-05-05 14:56:46.000000000 +0900
@@ -718,18 +718,50 @@
    ! allocating working arrays
 
    allocate(cirreg1(1:15, 1:nbnd),ct(1:3, 1:nbnd))
+   cirreg1(:,:)=0
+   ct(:,:)=0
    allocate(wp(nbnd),qp(nbnd))
+   wp(:)=0
+   qp(:)=0
    allocate(unj(nbnd),unjf(nbnd),bf(nbnd),fvec(nbnd))
+   unj(:)=0
+   unjf(:)=0
+   bf(:)=0
+   fvec(:)=0
    allocate(q0p(nbnd),qyp(nbnd),qzp(nbnd))
+   q0p(:)=0
+   qyp(:)=0
+   qzp(:)=0
    allocate(w0p(nbnd),wyp(nbnd),wzp(nbnd))
+   w0p(:)=0
+   wyp(:)=0
+   wzp(:)=0
    allocate(wyyp(nbnd),wzzp(nbnd),wyzp(nbnd))
+   wyyp(:)=0
+   wzzp(:)=0
+   wyzp(:)=0
    allocate(wcoe(nbnd,nq),wxcoe(nbnd, nq),wycoe(nbnd, nq))
+   wcoe(:,:)=0
+   wxcoe(:,:)=0
+   wycoe(:,:)=0
    allocate(wzcoe(nbnd,nq),wxxcoe(nbnd, nq),wyycoe(nbnd, nq))
+   wzcoe(:,:)=0
+   wxxcoe(:,:)=0
+   wyycoe(:,:)=0
    allocate(wzzcoe(nbnd, nq),wxycoe(nbnd, nq))
+   wzzcoe(:,:)=0
+   wxycoe(:,:)=0
    allocate(wxzcoe(nbnd, nq),wyzcoe(nbnd, nq))
+   wxzcoe(:,:)=0
+   wyzcoe(:,:)=0
    allocate(sss1(nbnd),sss2(nbnd))
+   sss1(:)=0
+   sss2(:)=0
    allocate(c(l,m,n,7), c2(nbnd, 27))
+   c(:,:,:,:)=0
+   c2(:,:)=0
    allocate(f(l,m,n))
+   f(:,:,:)=0
 
    ! XP: cluster irregular grid points to get the new index2 and cirreg
 
@@ -1303,6 +1335,8 @@
    _REAL_,allocatable :: hg(:,:),v(:,:)
 
    allocate (hg(nbnd,mm),v(nbnd,mm))
+   hg(:,:)=0
+   v(:,:)=0
    write(6,'(a,i8)') 'The gmres dimension is ',ctn
    iter = 0
 
@@ -1668,10 +1702,19 @@
    integer l,m,n,i
 
       allocate(l_ad(1:l_xmymzm+l_xmym),l_am1(1-l_xmym:l_xmymzm+l_xmym))
+      l_ad(:)=0
+      l_am1(:)=0
       allocate(l_am2(1-l_xmym:l_xmymzm+l_xmym), l_am3(1-l_xmym:l_xmymzm+l_xmym))
+      l_am2(:)=0
+      l_am3(:)=0
       allocate(l_rd(1-l_xmym:l_xmymzm),l_bv(1-l_xmym:l_xmymzm))
+      l_rd(:)=0
+      l_bv(:)=0
       allocate(l_tv(1-l_xmym:l_xmymzm+l_xmym),l_zv(1-l_xmym:l_xmymzm+l_xmym))
+      l_tv(:)=0
+      l_zv(:)=0
       allocate(l_pv(1-l_xmym:l_xmymzm+l_xmym))
+      l_pv(:)=0
 
 end subroutine allocate_array
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/pb_bldsys.F90 ./AmberTools/src/pbsa/pb_bldsys.F90
--- AmberTools/src/pbsa/pb_bldsys.F90	2022-08-29 08:39:32.000000000 +0900
+++ ./AmberTools/src/pbsa/pb_bldsys.F90	2022-05-05 14:56:46.000000000 +0900
@@ -413,6 +413,7 @@
       ! WMBS: added membrane support
       call pbtimer_start(PBTIME_PBEXMOL_PARTA)
       insas(1:xmymzm_ext) = -2
+      atmsas(1:xmymzm_ext) = 0
       call pbtimer_stop(PBTIME_PBEXMOL_PARTA)
       call density_lvlset(eneopt,memopt,outlvlset,outmlvlset,natom,xm,ym,zm,gox,goy,goz,h,dprob*rh,&
               cutfd,mzmin,mzmax,gcrd,radip3,poretype,poreradi,insas,inmem,lvlset,mlvlset, ipb) ! Added ipb option for CUDA - R.Q.
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/pb_crgview.F90 ./AmberTools/src/pbsa/pb_crgview.F90
--- AmberTools/src/pbsa/pb_crgview.F90	2022-08-29 08:39:32.000000000 +0900
+++ ./AmberTools/src/pbsa/pb_crgview.F90	2022-05-05 14:56:46.000000000 +0900
@@ -53,6 +53,7 @@
    TOL = 1.d-5
 
    allocate (pol_charge(1:nbnd))
+   pol_charge(:)=0
 
    ! initialization
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/pb_fdfrc.F90 ./AmberTools/src/pbsa/pb_fdfrc.F90
--- AmberTools/src/pbsa/pb_fdfrc.F90	2022-08-29 08:39:32.000000000 +0900
+++ ./AmberTools/src/pbsa/pb_fdfrc.F90	2022-05-05 14:56:46.000000000 +0900
@@ -552,9 +552,13 @@
          grdreac = ZERO
          drcreac = ZERO
          allocate (pos_crg(3,MAXSURFC,natom))
+         pos_crg(:,:,:)=0
          allocate (ipos_crg(3,MAXSURFC,natom))
+         ipos_crg(:,:,:)=0
          allocate (surf_crg(MAXSURFC,natom))
+         surf_crg(:,:)=0
          allocate (crg_num(1:natom))
+         crg_num(:)=0
          if ( epsin /= epsout ) then
             call pb_crgview( pbverbose,pbprint,natom,pbfrc,epsx,epsy,epsz,zv(1),phi,chgrd,cphi )
             call pb_fdreaction( natom, 1, atmlast, idecomp, grdreac, outflag, pbfrc )
@@ -1157,6 +1161,7 @@
    ! pol_charge is in au
 
    allocate (pol_charge(1:nbnd))
+   pol_charge(:)=0
 
    ! Put all array pre-computation on device. TODO
    ! Port this to GPU, use array directly from device. R.Q.
@@ -1412,6 +1417,7 @@
 
    nbound = 2*xm*ym+2*xm*zm+2*zm*ym
    allocate(bound_crg(nbound))
+   bound_crg(:)=0
    do j = 1, ym; do i = 1, xm
       bound_crg(i+(j-1)*xm)=-h*phi(i,j,1)*eps0
       bound_crg(i+(j-1)*xm+xm*ym)=-h*phi(i,j,zm)*eps0
@@ -1428,6 +1434,7 @@
   ! compute polarization charges
 
    allocate (pol_charge(1:nbnd))
+   pol_charge(:)=0
    do ip = 1, nbnd
 
       i = iepsav(1,ip); j = iepsav(2,ip); k = iepsav(3,ip)
@@ -1794,6 +1801,7 @@
    ! pol_charge is in au
 
    allocate (pol_charge(1:nbnd))
+   pol_charge(:)=0
    call get_charge_pol(nbnd,xm,ym,zm,phi,cphi,chgrd,pol_charge,srfcrg)
 
    ! main double loops over polarization charges and atom charges
@@ -2212,6 +2220,7 @@
    ! pol_charge is in au
 
    allocate (pol_charge(1:nbnd))
+   pol_charge(:)=0
    call get_charge_pol(nbnd,xm,ym,zm,phi,cphi,chgrd,pol_charge,srfcrg)
 
    ! main double loops over polarization charges and atom charges
@@ -2396,6 +2405,7 @@
    ! pol_charge is in au
 
    allocate (pol_charge(1:nbnd))
+   pol_charge(:)=0
    call get_charge_pol(nbnd,xm,ym,zm,phi,cphi,chgrd,pol_charge,srfcrg)
 
    eelrf = ZERO
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/pb_iimdrv.F90 ./AmberTools/src/pbsa/pb_iimdrv.F90
--- AmberTools/src/pbsa/pb_iimdrv.F90	2022-08-29 08:39:31.000000000 +0900
+++ ./AmberTools/src/pbsa/pb_iimdrv.F90	2022-05-05 14:56:47.000000000 +0900
@@ -691,6 +691,30 @@
    allocate (wxzcoe(nbnd, nq),wyzcoe(nbnd, nq))
    allocate (sss1(nbnd),sss2(nbnd)) !dummy arrays
    allocate (c2(nbnd, 27))
+   wp(:)=0
+   qp(:)=0
+   q0p(:)=0
+   qyp(:)=0
+   qzp(:)=0
+   w0p(:)=0
+   wyp(:)=0
+   wzp(:)=0
+   wyyp(:)=0
+   wzzp(:)=0
+   wyzp(:)=0
+   wcoe(:,:)=0
+   wxcoe(:,:)=0
+   wycoe(:,:)=0 
+   wzcoe(:,:)=0
+   wxxcoe(:,:)=0
+   wyycoe(:,:)=0
+   wzzcoe(:,:)=0
+   wxycoe(:,:)=0
+   wxzcoe(:,:)=0
+   wyzcoe(:,:)=0
+   sss1(:)=0
+   sss2(:)=0
+   c2(:,:)=0
 
    ! the surface related infrastructure data from density_surface module is used
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/pb_init.F90 ./AmberTools/src/pbsa/pb_init.F90
--- AmberTools/src/pbsa/pb_init.F90	2022-08-29 08:39:32.000000000 +0900
+++ ./AmberTools/src/pbsa/pb_init.F90	2022-05-05 14:56:47.000000000 +0900
@@ -168,11 +168,23 @@
    allocate(    nex(     natom), STAT = alloc_err(7 ) )
    allocate(    iex(64,  natom), STAT = alloc_err(8 ) )
 
+   icrd(:,:)=0
+   grdcrg(:,:)=0
+   qgrdcrg(:)=0
+   acrg(:)=0
+   gcrg(:,:)=0
+   nshrt(:)=0
+   nex(:)=0
+   iex(:,:)=0
+
    if ( ifcap == 0 .or. (ifcap >= 3 .and. ifcap <= 5) ) then
 
    allocate(   acrd( 3,  natom), stat = alloc_err(9 ) )
    allocate(   gcrd( 3,  natom), stat = alloc_err(10) )
 
+   acrd( :,  :)=0
+   gcrd( :,  :)=0
+
    ! allocate sas informations
 
    allocate(  mdsig(  natom  ), stat = alloc_err(11) )
@@ -190,15 +202,37 @@
    allocate( avnexp(  natom  ), stat = alloc_err(22) )
    allocate(   scrd(3,maxsph ), stat = alloc_err(23) )
 
+   mdsig(  :  )=0
+   rmin(  :  )=0
+   radi(  :  )=0
+   radip(  :  )=0
+   radip2(  :  )=0
+   radip3(  :  )=0
+   nzratm(  :  )=0
+   nmax( :  )=0
+   nexp(  :  )=0
+   sumnmax(  :  )=0
+   sumnexp(  :  )=0
+   avnmax(  :  )=0
+   avnexp(  :  )=0 
+   scrd(:,: )=0
+
    else
 
    allocate(   acrd( 3, 0:natom), stat = alloc_err(9 ) )
    allocate(   gcrd( 3, 0:natom), stat = alloc_err(10) )
 
+   acrd( :, :)=0
+   gcrd( :, :)=0
+
    allocate(   radi(    0: 0   ), stat = alloc_err(12) )
    allocate( radip3(    1: 1   ), stat = alloc_err(15) )
    allocate( nzratm(    1: 1   ), stat = alloc_err(16) )
 
+   radi(:)=0
+   radip3(:)=0
+   nzratm(:)=0
+
    end if
 
    ! allocate pb nblists
@@ -222,15 +256,26 @@
    allocate( cn2pb  (  maxnba ), stat = alloc_err(28) )
    allocate( cn3pb  (  maxnba ), stat = alloc_err(29) )
 
+   iar1pb(:,:)=0
+   iprshrt(:)=0
+   cn1pb(:)=0
+   cn2pb(:)=0
+   cn3pb(:)=0
+
    ! allocate ibelly and outflag
 
    if ( ifcap == 3 .or. ifcap == 4 ) then
       allocate( ibelly(natom), stat = alloc_err(30) )
+      ibelly(:)=0
    end if
    allocate( outflag(  natom  ), stat = alloc_err(31) )
    allocate( outflagorig(  natom  ), stat = alloc_err(32) )
    allocate( mapout(  natom  ), stat = alloc_err(33) )
 
+   outflag(:)=0
+   outflagorig(:)=0
+   mapout(:)=0
+
    if ( alloc_err( 1)+alloc_err( 2)+alloc_err( 3)+alloc_err( 4)+alloc_err( 5)+&
         alloc_err( 6)+alloc_err( 7)+alloc_err( 8)+alloc_err( 9)+alloc_err(10)+&
         alloc_err(11)+alloc_err(12)+alloc_err(13)+alloc_err(14)+alloc_err(15)+&
@@ -507,6 +552,8 @@
          write(6,'(a,i6)') ' PB Bomb in pb_init(): Allocation aborted', alloc_err(1:2)
          call mexit(6,1)
       end if
+      liveflag(:)=0
+      realflag(:)=0
 
       ! Mengjuei -
       ! Basically liveflag HERE is a temporary switch storing the list of
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/pb_list.F90 ./AmberTools/src/pbsa/pb_list.F90
--- AmberTools/src/pbsa/pb_list.F90	2022-08-29 08:39:34.000000000 +0900
+++ ./AmberTools/src/pbsa/pb_list.F90	2022-05-05 14:56:47.000000000 +0900
@@ -570,10 +570,10 @@
             tmpnb(nclose) = j
          end if
       end do ! j = 1, natom
-!write(2012,*) i,eclose,cntr, '|'
-!write(2012,*) i,pclose,cntr, '|'
-!write(2012,*) i,sclose,cntr, '|'
-!write(2012,*) i,nclose,cntr, '|'
+write(2012,*) i,eclose,cntr, '|'
+write(2012,*) i,pclose,cntr, '|'
+write(2012,*) i,sclose,cntr, '|'
+write(2012,*) i,nclose,cntr, '|'
 
       ! part b: pack them into the new atom-based nblist
       ! since there is no separation of h-atom and other atoms, we need to
@@ -744,10 +744,23 @@
    allocate(   epsx( xmymzm_max+ym_max*zm_max ), stat = alloc_err(3 ) )
    allocate(   epsy( xmymzm_max+xm_max*zm_max ), stat = alloc_err(4 ) )
    allocate(   epsz( xmymzm_max+xm_max*ym_max ), stat = alloc_err(5 ) )
-   if ( ipb < 4 ) allocate(saltgrd( xmymzm_max ), stat = alloc_err(6 ) )
+
+   phi( : )=0
+   chgrd( : )=0
+   epsx( : )=0
+   epsy( : )=0
+   epsz( : )=0
+
+   if ( ipb < 4 ) then
+           allocate(saltgrd( xmymzm_max ), stat = alloc_err(6 ) )
+           saltgrd( : )=0
+   endif
    allocate( ioncrg( xmymzm_max ), stat = alloc_err(7 ) )
    allocate(     bv( xmymzm_max ), stat = alloc_err(8 ) )
 
+   ioncrg( : )=0
+   bv( : )=0
+
    ! geometry propery maps and auxiliary arrays for mapping dielectric and stern interfaces
 
    allocate(  insas( xmymzm_ext ), stat = alloc_err(9 ) )
@@ -756,16 +769,37 @@
    allocate(mlvlset( xmymzm_ext ), stat = alloc_err(12) )
    allocate(     zv( xmymzm_ext ), stat = alloc_err(13) )
 
+   insas( : )=0
+   atmsas( : )=0
+   lvlset( : )=0
+   mlvlset( : )=0
+   zv( : )=0
+
    ! physical property maps for forces
 
    allocate(   cphi   (1:xmymzm_max), stat = alloc_err(14) )
-   if (ipb <4 ) allocate( fedgex   (1:xmymzm_max), stat = alloc_err(15) )
-   if (ipb <4 ) allocate( fedgey   (1:xmymzm_max), stat = alloc_err(16) )
-   if (ipb <4 ) allocate( fedgez   (1:xmymzm_max), stat = alloc_err(17) )
+   cphi   (:)=0
+   if (ipb <4 ) then
+        allocate( fedgex   (1:xmymzm_max), stat = alloc_err(15) )
+        allocate( fedgey   (1:xmymzm_max), stat = alloc_err(16) )
+        allocate( fedgez   (1:xmymzm_max), stat = alloc_err(17) )
+
+        fedgex   (:)=0
+        fedgey   (:)=0
+        fedgez   (:)=0
+   endif
    allocate( iepsav (4,1:xmymzm_max), stat = alloc_err(18) )
-   if (ipb <4 ) allocate( iepsavx(4,1:xmymzm_max), stat = alloc_err(19) )
-   if (ipb <4 ) allocate( iepsavy(4,1:xmymzm_max), stat = alloc_err(20) )
-   if (ipb <4 ) allocate( iepsavz(4,1:xmymzm_max), stat = alloc_err(21) )
+   iepsav (:,:)=0
+   if (ipb <4 ) then 
+        allocate( iepsavx(4,1:xmymzm_max), stat = alloc_err(19) )
+        allocate( iepsavy(4,1:xmymzm_max), stat = alloc_err(20) )
+        allocate( iepsavz(4,1:xmymzm_max), stat = alloc_err(21) )
+
+        iepsavx(:,:)=0
+        iepsavy(:,:)=0
+        iepsavz(:,:)=0
+   endif
+   !iepsav(4,1:xmymzm_max) = 0
 
    ! the saved phi array for pbmd/pbdock
 
@@ -773,8 +807,14 @@
    do l = 1, nfocus
       totsavxmymzm = totsavxmymzm + savxmymzm(l)+2*SAVXMYM(l)
    end do
-   if ( bcopt /= 10) allocate( xs(totsavxmymzm), stat = alloc_err(22) )
-   if ( bcopt == 10) allocate( xs(xmymzm_ext), stat = alloc_err(22) )
+   if ( bcopt /= 10) then
+           allocate( xs(totsavxmymzm), stat = alloc_err(22) )
+           xs(:)=0
+   endif
+   if ( bcopt == 10) then
+           allocate( xs(xmymzm_ext), stat = alloc_err(22) )
+           xs(:)=0
+   endif
 
    if ( sum(alloc_err(1:32)) /= 0 ) then
       write(6,'(a)') 'PB bomb in pb_setgrd(): Allocation aborted', alloc_err(1:32)
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/pb_lsolver.F90 ./AmberTools/src/pbsa/pb_lsolver.F90
--- AmberTools/src/pbsa/pb_lsolver.F90	2022-08-29 08:39:30.000000000 +0900
+++ ./AmberTools/src/pbsa/pb_lsolver.F90	2022-05-05 14:56:47.000000000 +0900
@@ -100,6 +100,16 @@
          allocate( l_rd(1-l_xmym:l_xmymzm),l_bv(1-l_xmym:l_xmymzm))
          allocate( l_tv(1-l_xmym:l_xmymzm+l_xmym),l_zv(1-l_xmym:l_xmymzm+l_xmym))
          allocate( l_pv(1-l_xmym:l_xmymzm+l_xmym))
+
+         l_ad(:)=0
+         l_am1(:)=0
+         l_am2(:)=0
+         l_am3(:)=0
+         l_rd(:)=0
+         l_bv(:)=0
+         l_tv(:)=0
+         l_zv(:)=0
+         l_pv(:)=0
       else
          allocate( pl_bv(0:l_xm,0:l_ym,0:l_zm),pl_tv(1:l_xm+1,1:l_ym+1,1:l_zm+1) )
          allocate( pl_zv(0:l_xm,0:l_ym,0:l_zm),pl_pv(0:l_xm,0:l_ym,0:l_zm) )
@@ -109,12 +119,33 @@
          allocate( pl_am5(0:l_xm,0:l_ym,0:l_zm),pl_am6(0:l_xm,0:l_ym,0:l_zm) )
          allocate( pl_ind(1:l_xmymzm,3) )
          allocate( pl_iv(1:l_xm,1:l_ym,1:l_zm) )
+
+         pl_bv(:,:,:)=0
+         pl_tv(:,:,:)=0
+         pl_zv(:,:,:)=0
+         pl_pv(:,:,:)=0
+         pl_ad(:,:,:)=0
+         pl_rd(:,:,:)=0
+         pl_am1(:,:,:)=0
+         pl_am2(:,:,:)=0
+         pl_am3(:,:,:)=0
+         pl_am4(:,:,:)=0
+         pl_am5(:,:,:)=0
+         pl_am6(:,:,:)=0
+         pl_ind(:,:)=0
+         pl_iv(:,:,:)=0
       end if
    case (2)
       allocate ( mg_index(1:mg_nlevel+1),mg_index_ext(1:mg_nlevel+1))
       allocate ( mg_x_idx(1:mg_nlevel+1),mg_size(1:3,1:mg_nlevel) )
       allocate ( mg_onorm(1:mg_nlevel) )
 
+      mg_index(:)=0
+      mg_index_ext(:)=0
+      mg_x_idx(:)=0
+      mg_size(:,:)=0
+      mg_onorm(:)=0
+
       mg_index_ext(1) = 1
       mg_index(1) = 1
       mg_x_idx(1) = 1
@@ -126,6 +157,7 @@
       n = l + l_xmym
 
       allocate( l_zv(1:m) )
+      l_zv(:)=0
       if ( l_bcopt == 10 ) then
          allocate( l_scratch_vc( 1-(l_xm+3)*(l_ym+3):(l_xm+3)*(l_ym+3)*(l_zm+3)+(l_xm+3)*(l_ym+3)) )
          allocate( l_scratch_vf( 1-(l_xm+3)*(l_ym+3):(l_xm+3)*(l_ym+3)*(l_zm+3)+(l_xm+3)*(l_ym+3)) )
@@ -133,6 +165,13 @@
          allocate( l_scratch_am1(1-(l_xm+3)*(l_ym+3):(l_xm+3)*(l_ym+3)*(l_zm+3)) )
          allocate( l_scratch_am2(1-(l_xm+3)*(l_ym+3):(l_xm+3)*(l_ym+3)*(l_zm+3)) )
          allocate( l_scratch_am3(1-(l_xm+3)*(l_ym+3):(l_xm+3)*(l_ym+3)*(l_zm+3)) )
+
+         l_scratch_vc(:)=0
+         l_scratch_vf(:)=0
+         l_scratch_bz(:)=0
+         l_scratch_am1(:)=0
+         l_scratch_am2(:)=0
+         l_scratch_am3(:)=0
       end if
 
       do i = 2, mg_nlevel
@@ -155,22 +194,51 @@
       allocate ( l_ad(1:m), l_bv(1:m), l_rv(1:m), l_iv(1:m), l_bz(1:m) )
       allocate ( l_am1(1:l), l_am2(1:l), l_am3(1:l) )
       allocate ( l_xv(1:n) )
+
+      l_ad(:)=0
+      l_bv(:)=0
+      l_rv(:)=0
+      l_iv(:)=0
+      l_bz(:)=0
+
       if ( l_bcopt == 10 ) then
          allocate( pl_ind3d(0:(sum((2+mg_size(1,1:mg_nlevel)))),0:(sum((2+mg_size(2,1:mg_nlevel)))),&
                   0:(sum((2+mg_size(3,1:mg_nlevel)))) ) )
+          pl_ind3d(:,:,:)=0
       end if
    case (3)
       allocate(l_ad(1:l_xmymzm),l_am1(1-l_xmym:l_xmymzm),l_am2(1-l_xmym:l_xmymzm),l_am3(1-l_xmym:l_xmymzm))
       allocate(l_bv(1:l_xmymzm),l_pv(1-l_xmym:l_xmymzm+l_xmym),l_zv(1:l_xmymzm))
+
+      l_ad(:)=0
+      l_am1(:)=0
+      l_am2(:)=0
+      l_am3(:)=0
+      l_bv(:)=0
+      l_pv(:)=0
+      l_zv(:)=0
+
       if (l_bcopt==10) then
          allocate(l_am4(1-l_xmym:l_xmymzm),l_am5(1-l_xmym:l_xmymzm),l_am6(1-l_xmym:l_xmymzm))
+         l_am4(:)=0
+         l_am5(:)=0
+         l_am6(:)=0
       end if
    case (4)
       allocate(l_ad(1:l_xmymzm),l_am1(1-l_xmym:l_xmymzm),l_am2(1-l_xmym:l_xmymzm),l_am3(1-l_xmym:l_xmymzm))
       allocate(l_bv(1:l_xmymzm),l_zv(1:l_xmymzm))
+
+      l_ad(:)=0
+      l_am1(:)=0
+      l_am2(:)=0
+      l_am3(:)=0
+
       if (l_bcopt==10) then
          allocate(pl_ind3d(0:(l_xm+1),0:(l_ym+1),0:(l_zm+1)))
          allocate(pl_ind(1:l_xmymzm,1:3))
+
+         pl_ind3d(:,:,:)=0
+         pl_ind(:,:)=0
       end if
    end select
 
@@ -425,6 +493,9 @@
          m = m + (mg_size(1,i)+1) * (mg_size(2,i)+1) * (mg_size(3,i)+1)
       end do
       allocate( lepsx(1:m), lepsy(1:m), lepsz(1:m) )
+      lepsx(:)=0
+      lepsy(:)=0
+      lepsz(:)=0
       call feedepsintoam( l_xm, l_ym, l_zm, lepsx(1:l_xmymzm),  &
                           lepsy(1:l_xmymzm), lepsz(1:l_xmymzm), &
                                               epsx, epsy, epsz )
@@ -1382,14 +1453,19 @@
       deallocate(sa, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( sa(1:nz_num), stat=ier); REQUIRE(ier==0)
+   sa(:)=0
+
    if ( allocated(ja) ) then
       deallocate(ja, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( ja(1:l_xmymzm+1), stat=ier); REQUIRE(ier==0) ! this is row index
+   ja(:)=0
+
    if ( allocated(ia) ) then
       deallocate(ia, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( ia(1:nz_num), stat=ier); REQUIRE(ier==0) ! this is column index
+   ia(:)=0
 #endif
 
 #ifdef DIA
@@ -1398,15 +1474,19 @@
        deallocate(sa, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( sa(1:13*l_xmymzm), stat=ier); REQUIRE(ier==0)
+   sa(:)=0
 #endif
    if ( allocated(x) ) then
        deallocate(x, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( x(1:l_xmymzm), stat=ier); REQUIRE(ier==0)
+   x(:)=0
+
    if ( allocated(b) ) then
        deallocate(b, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( b(1:l_xmymzm), stat=ier); REQUIRE(ier==0)
+   b(:)=0
 
    ! neutralize grid charge in periodic Poisson systems
    ! salt would automatically do it in the periodic PB systems.
@@ -1843,29 +1923,38 @@
       deallocate(sa, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( sa(1:nz_num), stat=ier); REQUIRE(ier==0)
+   sa(:)=0
+
    if ( allocated(ja) ) then
       deallocate(ja, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( ja(1:l_xmymzm+1), stat=ier); REQUIRE(ier==0) ! this is row index
+   ja(:)=0
+
    if ( allocated(ia) ) then
       deallocate(ia, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( ia(1:nz_num), stat=ier); REQUIRE(ier==0) ! this is column index
+   ia(:)=0
 #endif
 #ifdef DIA
    if ( allocated(sa) ) then
       deallocate(sa, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( sa(1:nb*l_xmymzm), stat=ier); REQUIRE(ier==0)
+   sa(:)=0
 #endif
    if ( allocated(x) ) then
       deallocate(x, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( x(1:l_xmymzm), stat=ier); REQUIRE(ier==0)
+   x(:)=0
+
    if ( allocated(b) ) then
       deallocate(b, stat = ier); REQUIRE(ier==0)
    end if
    allocate ( b(1:l_xmymzm), stat=ier); REQUIRE(ier==0)
+    b(:)=0
 
    saccept = l_accept
    x(1:l_xmymzm) = xs(1:l_xmymzm)
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/pb_nhadrv.F90 ./AmberTools/src/pbsa/pb_nhadrv.F90
--- AmberTools/src/pbsa/pb_nhadrv.F90	2022-08-29 08:39:31.000000000 +0900
+++ ./AmberTools/src/pbsa/pb_nhadrv.F90	2022-05-05 14:56:47.000000000 +0900
@@ -462,6 +462,7 @@
    call pbtimer_start(PBTIME_PBBUILDSYS)
 
    allocate (c2(nbnd, 7)) ! A matrix coefficients
+   c2(:,:)=0
 
    beta_max = max(bi,bo)
    nz_num = 0
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/pb_nlsolver.F90 ./AmberTools/src/pbsa/pb_nlsolver.F90
--- AmberTools/src/pbsa/pb_nlsolver.F90	2022-08-29 08:39:32.000000000 +0900
+++ ./AmberTools/src/pbsa/pb_nlsolver.F90	2022-05-05 14:56:47.000000000 +0900
@@ -85,10 +85,22 @@
       allocate ( sav_am1(1:n), sav_am2(1:n), sav_am3(1:n), sav_ad(1:l) )
       allocate ( rd(1:n), pv(1:n), tv(1:n), zv(1:n) )
       allocate ( xv(1:n), xcorr(1:n) )
+
+      ad1(:)=0
+      rv(:)=0
+      iv(:)=0
+      zzv(:)=0
+      bv(:)=0
    case (2)
       allocate ( mg_index(1:mg_nlevel+1), mg_index_ext(1:mg_nlevel+1),mg_x_idx(1:mg_nlevel+1),mg_size(1:3,1:mg_nlevel) )
       allocate ( mg_onorm(1:mg_nlevel) )
 
+      mg_index(:)=0
+      mg_index_ext(:)=0
+      mg_x_idx(:)=0
+      mg_size(:,:)=0
+      mg_onorm(:)=0
+
       mg_index_ext(1) = 1
       mg_index(1) = 1
       mg_x_idx(1) = 1
@@ -100,6 +112,7 @@
       n = l + xmym
 
       allocate ( zv(m) )
+      zv(:)=0
 
       do i = 2, mg_nlevel
          mg_index_ext(i) = 1 + l
@@ -117,23 +130,76 @@
       allocate ( ad(1:m), ad1(1:m), bv(1:m), rv(1:m), iv(1:m), bz(1:m) )
       allocate ( am1(1:l), am2(1:l), am3(1:l) )
       allocate ( xv(1:n), xcorr(1:n) )
+
+      ad(:)=0
+      ad1(:)=0
+      bv(:)=0
+      rv(:)=0
+      iv(:)=0
+      bz(:)=0
+      am1(:)=0
+      am2(:)=0
+      am3(:)=0
+      xv(:)=0
+      xcorr(:)=0
    case (3)
       m = xmymzm
       allocate ( ad(1:m), ad1(1:m), bv(1:m), zv(1:m), iv(1:m), tv(1:m), rv(1:m) )
       allocate ( am1(1-xmym:xmymzm), am2(1-xmym:xmymzm), am3(1-xmym:xmymzm) )
       allocate ( pv(1-xmym:m+xmym) )
+
+
+      ad(:)=0
+      ad1(:)=0
+      bv(:)=0
+      zv(:)=0
+      iv(:)=0
+      tv(:)=0
+      rv(:)=0
+      am1(:)=0
+      am2(:)=0
+      am3(:)=0
+      pv(:)=0
    case (4)
       m = xmymzm
       allocate ( ad(1:m), ad1(1:m), bv(1:m), zv(1:m), iv(1:m) )
       allocate ( am1(1-xmym:xmymzm), am2(1-xmym:xmymzm), am3(1-xmym:xmymzm) )
+
+      ad(:)=0
+      ad1(:)=0
+      bv(:)=0
+      zv(:)=0
+      iv(:)=0
+      am1(:)=0
+      am2(:)=0
+      am3(:)=0
    case (5)
       m = xmymzm
       allocate ( ad(1:m), ad1(1:m), bv(1:m), zv(1:m), iv(1:m) )
       allocate ( am1(1-xmym:xmymzm), am2(1-xmym:xmymzm), am3(1-xmym:xmymzm) )
+
+      ad(:)=0
+      ad1(:)=0
+      bv(:)=0
+      zv(:)=0
+      iv(:)=0
+      am1(:)=0
+      am2(:)=0
+      am3(:)=0
    case (6)
       m = xmymzm
       allocate ( ad(1:m), ad1(1:m), bv(1:m), zv(1:m), iv(1:m), tv(1:m) )
       allocate ( am1(1-xmym:xmymzm), am2(1-xmym:xmymzm), am3(1-xmym:xmymzm) )
+
+      ad(:)=0
+      ad1(:)=0
+      bv(:)=0
+      zv(:)=0
+      iv(:)=0
+      tv(:)=0
+      am1(:)=0
+      am2(:)=0 
+      am3(:)=0
    case default
       m = xmymzm
       l = m + xmym
@@ -142,6 +208,20 @@
       allocate ( tv(1:m), zv(1:m) )
       allocate ( am1(1-xmym:xmymzm), am2(1-xmym:xmymzm), am3(1-xmym:xmymzm) )
       allocate ( xv(1:n), xcorr(1:n), pv(1-xmym:m+xmym) )
+
+      ad(:)=0
+      ad1(:)=0
+      bv(:)=0
+      rv(:)=0
+      iv(:)=0
+      tv(:)=0
+      zv(:)=0
+      am1(:)=0
+      am2(:)=0
+      am3(:)=0
+      xv(:)=0
+      xcorr(:)=0
+      pv(:)=0
    end select
 
 end subroutine allocate_array
@@ -268,6 +348,9 @@
          m = m + mg_size(1,i) * mg_size(2,i) * mg_size(3,i)
       end do
       allocate ( lepsx(1:m), lepsy(1:m), lepsz(1:m) )
+      lepsx(:)=0
+      lepsy(:)=0
+      lepsz(:)=0
       call feedepsintoam(epsx,epsy,epsz,lepsx(1),lepsy(1),lepsz(1))
       lfactor = factor1
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/pb_p3m.F90 ./AmberTools/src/pbsa/pb_p3m.F90
--- AmberTools/src/pbsa/pb_p3m.F90	2022-08-29 08:39:33.000000000 +0900
+++ ./AmberTools/src/pbsa/pb_p3m.F90	2022-05-05 14:56:47.000000000 +0900
@@ -61,26 +61,37 @@
          deallocate(tmpind, stat = ier); REQUIRE(ier==0)
       end if
       allocate(tmpind(3,8,natom), stat = ier); REQUIRE(ier==0)
+      tmpind(:,:,:)=0
+
       if ( allocated(du) ) then
          deallocate(du, stat = ier); REQUIRE(ier==0)
       end if
       allocate(du(3,natom), stat = ier); REQUIRE(ier==0)
+      du(:,:)=0
+
       if ( allocated(grdcrg) ) then
          deallocate(grdcrg, stat = ier); REQUIRE(ier==0)
       end if
       allocate(grdcrg(nbnd+8*natom), stat = ier); REQUIRE(ier==0)
+      grdcrg(:)=0
+
       if ( allocated(grdcrd) ) then
          deallocate(grdcrd, stat = ier); REQUIRE(ier==0)
       end if
       allocate(grdcrd(3,nbnd+8*natom), stat = ier); REQUIRE(ier==0)
+      grdcrd(:,:)=0
+
       if ( allocated(aphi) ) then
          deallocate(aphi, stat = ier); REQUIRE(ier==0)
       end if
       allocate (aphi(-1:1,-1:1,-1:1,natom), stat = ier); REQUIRE(ier==0)
+      aphi(:,:,:,:)=0
+
       if ( allocated(ndenatm) ) then
          deallocate(ndenatm, stat = ier); REQUIRE(ier==0)
       end if
       allocate(ndenatm(natom), stat = ier); REQUIRE(ier==0)
+      ndenatm(:)=0
 
       ! the charge list includes both boundary charges and 8 corners
       ! of each atom in PM correction
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/pbsa.F90 ./AmberTools/src/pbsa/pbsa.F90
--- AmberTools/src/pbsa/pbsa.F90	2022-08-29 08:39:30.000000000 +0900
+++ ./AmberTools/src/pbsa/pbsa.F90	2022-05-05 14:56:47.000000000 +0900
@@ -113,6 +113,11 @@
    allocate( ipairs(lastpr), stat = ier ); REQUIRE(ier==0)
    allocate( ih    (lasth ), stat = ier ); REQUIRE(ier==0)
 
+   x(:)=0
+   ix(:)=0
+   ipairs(:)=0
+   ih(:)=''
+
    lastrst = 1
    lastist = 1
    r_stack(1) = 0.0d0
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pbsa/sa_driver.F90 ./AmberTools/src/pbsa/sa_driver.F90
--- AmberTools/src/pbsa/sa_driver.F90	2022-08-29 08:39:31.000000000 +0900
+++ ./AmberTools/src/pbsa/sa_driver.F90	2022-05-05 14:56:47.000000000 +0900
@@ -838,6 +838,8 @@
       write(6,'(a,2i6)') 'SA Bomb in sa_srf(): Allocation aborted', alloc_err(1:2)
       call mexit(6, 1)
    end if
+   knockout(:)=.FALSE.
+   sphcrd(:,:)=0
 
    if ( pqropt == 0 ) then
 
@@ -928,6 +930,9 @@
       write(6,'(a,3i6)') 'SA Bomb in sa_srf(): Allocation aborted', alloc_err(1:3)
       call mexit(6, 1)
    end if
+   fstsdot(:)=0
+   lstsdot(:)=0
+   srfcrd(:,:)=0
 
    ! loop over nblist with cutsa
 
@@ -1060,6 +1065,12 @@
    allocate(  lstarc(            natom), stat = alloc_err(4) )
    allocate(    marc(            natom), stat = alloc_err(5) )
 
+   fstadot(:)=0
+   lstadot(:)=0
+   fstarc(:)=0
+   lstarc(:)=0
+   marc(:)=0
+
    if ( triopt > 0 ) then
 
    allocate(  triatm(3,   maxtri*natom), stat = alloc_err(6) )
@@ -1070,6 +1081,14 @@
    allocate( tricrd1(3,   maxtri*natom), stat = alloc_err(11))
    allocate(knocktri(     maxtri*natom), stat = alloc_err(12))
 
+   triatm(:,:)=0
+   triatm1(:,:)=0
+   triarc(:,:)=0
+   triarc1(:,:)=0
+   tricrd(:,:)=0
+   tricrd1(:,:)=0
+   knocktri(:)=.FALSE.
+
    else
 
    allocate(  triatm(3,              1), stat = alloc_err(6) )
@@ -1080,6 +1099,14 @@
    allocate( tricrd1(3,              1), stat = alloc_err(11))
    allocate(knocktri(                1), stat = alloc_err(12))
 
+   triatm(:,:)=0
+   triatm1(:,:)=0
+   triarc(:,:)=0
+   triarc1(:,:)=0
+   tricrd(:,:)=0
+   tricrd1(:,:)=0
+   knocktri(:)=.FALSE.
+
    end if
 
    if ( alloc_err(1)+alloc_err(2)+alloc_err(3)+alloc_err(4)+alloc_err(5)+&
@@ -1109,6 +1136,11 @@
       call mexit(6, 1)
    end if
 
+   m2narc(:,:)=0
+   arcatm(:,:)=0
+   savarc(:,:)=0
+   savactr(:,:)=0
+
    allocate(knockout(  maxarcdot*natom), stat = alloc_err(1) )
    allocate(  sphcrd(3,maxarcdot*natom), stat = alloc_err(2) )
    allocate( sphcrd1(3,maxarcdot*natom), stat = alloc_err(3) )
@@ -1119,6 +1151,12 @@
       call mexit(6, 1)
    end if
 
+   knockout(:)=.false.
+   sphcrd(:,:)=0
+   sphcrd1(:,:)=0
+   spharc(:)=0
+   spharc1(:)=0
+
    call pbtimer_stop(PBTIME_PBSAARC_SETUP)
 
    if ( pqropt == 0 ) then
@@ -1158,6 +1196,9 @@
    allocate(  dotarc(   msrf), stat = alloc_err(1) )
    allocate(  arccrd(3, msrf+mtri), stat = alloc_err(2) )
 
+   dotarc(:)=0
+   arccrd(:,:)=0
+
    ! for passing arccrd to CUDA - R.Q.
 #ifdef CUDA
    msrf_cu = msrf
@@ -1207,6 +1248,9 @@
    allocate(  dotarc(   msrf), stat = alloc_err(1) )
    allocate(  arccrd(3, msrf+mtri), stat = alloc_err(2) )
 
+   dotarc(:)=0
+   arccrd(:,:)=0
+
    ! for passing arccrd to CUDA - R.Q.
 #ifdef CUDA
    msrf_cu = msrf
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/pdb4amber/pdb4amber/pdb4amber.py ./AmberTools/src/pdb4amber/pdb4amber/pdb4amber.py
--- AmberTools/src/pdb4amber/pdb4amber/pdb4amber.py	2022-08-29 08:33:58.000000000 +0900
+++ ./AmberTools/src/pdb4amber/pdb4amber/pdb4amber.py	2022-05-05 14:56:47.000000000 +0900
@@ -385,9 +385,9 @@
 
         with open(basename + '_renum.txt', 'w') as fh:
             for residue in self.parm.residues:
-                fh.write("%3s %1s %5s    %3s %5s\n" %
-                   (residue.name, residue.chain, residue.number, residue.name,
-                    residue.idx + 1))
+                fh.write("%3s %c %5s    %3s %5s\n" %
+                         (residue.name, residue.chain, residue.number, residue.name,
+                          residue.idx + 1))
 
     def _write_pdb_to_stringio(self,
                                cys_cys_atomidx_set=None,
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/quick/Makefile ./AmberTools/src/quick/Makefile
--- AmberTools/src/quick/Makefile	2022-08-29 08:37:11.000000000 +0900
+++ ./AmberTools/src/quick/Makefile	2022-05-05 14:56:47.000000000 +0900
@@ -36,16 +36,16 @@
 	@echo  "Error: No build type found. Plesae run configure script first."
 
 serial: checkfolders
-	@echo  "Building serial version.."
-	@cp -f $(buildfolder)/make.serial.in $(buildfolder)/make.in
-	@cd $(buildfolder) && make --no-print-directory serial
-	@mv -f $(exefolder)/test-api $(homefolder)/test/
+	echo  "Building serial version.."
+	cp -f $(buildfolder)/make.serial.in $(buildfolder)/make.in
+	cd $(buildfolder) && make --no-print-directory serial
+	mv -f $(exefolder)/test-api $(homefolder)/test/
 
 mpi: checkfolders
-	@echo  "Building mpi version.."
-	@cp -f $(buildfolder)/make.mpi.in $(buildfolder)/make.in
-	@cd $(buildfolder) && make --no-print-directory mpi
-	@mv -f $(exefolder)/test-api.MPI $(homefolder)/test/
+	echo  "Building mpi version.."
+	cp -f $(buildfolder)/make.mpi.in $(buildfolder)/make.in
+	cd $(buildfolder) && make --no-print-directory mpi
+	mv -f $(exefolder)/test-api.MPI $(homefolder)/test/
 
 cuda: checkfolders
 	@echo  "Building cuda version.."
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/quick/configure ./AmberTools/src/quick/configure
--- AmberTools/src/quick/configure	2022-08-29 08:37:11.000000000 +0900
+++ ./AmberTools/src/quick/configure	2022-05-05 14:56:49.000000000 +0900
@@ -127,7 +127,13 @@
   fi
 
   #try to link with libmpi_cxx
-  $fort test_mpicxx.o test_prog.o -o testmpi $ldflags $mpi_cxx_flag 2>/dev/null >/dev/null
+  if [ "$compiler" != "a64fx" ]; then
+    $fort test_mpicxx.o test_prog.o -o testmpi $ldflags $mpi_cxx_flag 2>/dev/null >/dev/null
+  else
+    echo "$cxx test_mpicxx.o test_prog.o -o testmpi --linkfortran $mpi_cxx_flag"
+    $cxx test_mpicxx.o test_prog.o -o testmpi --linkfortran $mpi_cxx_flag 2>/dev/null >/dev/null
+  fi
+
   if [ "$?" -ne 0 ]; then
     echo  "Error: Fortran90 and C++ code cannot be linked using $fort $ldflags $mpi_cxx_flag "
     echo  "Try to check the commands using 'mpif90 -show' "
@@ -231,6 +237,24 @@
       cxx_search='pgc++'
     ;;
 
+  a64fx)
+    echo "Requested compiler: Fujitsu compilers for A64FX."
+
+    if [ "$mpi" = 'no' ] && [ "$cudampi" = 'no' ]; then
+      if [ -z "$FC" ]; then fort='frt'; else fort="$FC";fi
+      if [ -z "$CC" ]; then cc='fcc -Nclang'; else cc="$CC";fi
+      if [ -z "$CXX" ]; then cxx='FCC -Nclang'; else cxx="$CXX";fi
+    else
+      if [ -z "$MPIF90" ]; then fort='mpifrt'; else fort="$MPIF90";fi
+      if [ -z "$MPICC" ]; then cc='mpifcc -Nclang'; else cc="$MPICC";fi
+      if [ -z "$MPICXX" ]; then cxx='mpiFCC -Nclang'; else cxx="$MPICXX";fi
+    fi
+
+      fort_search='frt'
+      cc_search='fcc -Nclang'
+      cxx_search='FCC -Nclang'
+    ;;
+
   nvidia)
     echo "Requested compiler: NVIDIA."
 
@@ -254,175 +278,6 @@
     exit 1;;
 esac
 
-# check for the existance of each compiler
-if [ -z "`which $fort 2> /dev/null`" ]; then
-  echo  "Error: $fort is not found."
-  exit 1
-fi
-
-if [ -z "`which $cc 2> /dev/null`" ]; then
-  echo  "Error: $cc is not found."
-  exit 1
-fi
-
-if [ -z "`which $cxx 2> /dev/null`" ]; then
-  echo  "Error: $cxx is not found."
-  exit 1
-fi
-
-# general vars for compiler search
-info_option='-v'
-patch_seperator='.'
-version_string="[0-9]{1,4}.[0-9]{1,4}$patch_seperator[0-9]{1,4}"
-
-# pgi compilers use a different versioning output
-if [ "$fort_search" = 'pgfortran' ] || [ "$fort_search" = 'nvfortran' ]; then
-  patch_seperator='-'
-  version_string='[0-9]{1,4}.[0-9]{1,4}-[0-9]{1,4}'
-  info_option='--version'
-fi
-
-# check the fortran compiler version
-has_fort_version='no'
-fort_version='not'
-fort_version_major=''
-fort_version_minor=''
-fort_version_patch=''
-fort_search_string="$fort_search\s[vV]ersion\s$version_string"
-
-# pgi & nvidia compilers use a different version output
-if [ "$fort_search" = 'pgfortran' ] || [ "$fort_search" = 'nvfortran' ]; then
-  fort_search_string="$fort_search\s$version_string"
-fi
-
-fort_version_info=`$fort_search $info_option 2>&1 | grep -oE "$fort_search_string"`
-
-# some gnu installations gives off 'gcc version xx.xx.xx' instead of 'gfortran version xx.xx.xx'
-if [ -z "$fort_version_info" ]; then
-  fort_search_string="$cc_search\s[vV]ersion\s$version_string"
-  fort_version_info=`$fort_search $info_option 2>&1 | grep -oE "$fort_search_string"`
-fi
-
-fort_version=`echo $fort_version_info | grep -oE "$version_string"`
-
-if [ `echo $fort_version | grep -oE "$version_string" | wc -l` -gt 0 ]; then
-  has_fort_version='yes'
-  fort_version_major=`echo $fort_version | cut -d '.' -f1`
-  fort_version_minor=`echo $fort_version | cut -d '.' -f2`
-  fort_version_patch=`echo $fort_version | cut -d "$patch_seperator" -f3`
-fi
-
-if [ "$has_fort_version" = 'yes' ]; then
-  echo "  $fort version $fort_version found.."
-else
-   echo  "Warning: Failed to detect $fort version."
-fi
-
-if [ "$fort_search" = 'gfortran' ] && [ "$fort_version_major" -ge 10 ]; then
-  fort_vspec_flags='-fallow-argument-mismatch'
-fi
-
-# check the c compiler version
-has_cc_version='no'
-cc_version='not'
-cc_version_major=''
-cc_version_minor=''
-cc_version_patch=''
-cc_search_string="$cc_search\s[vV]ersion\s$version_string"
-
-# pgi & nvidia compilers use a different version output
-if [ "$cc_search" = 'pgcc' ] || [ "$cc_search" = 'nvc' ]; then
-  cc_search_string="$cc_search\s$version_string"
-fi
-
-cc_version_info=`$cc_search $info_option 2>&1 | grep -oE "$cc_search_string"`
-cc_version=`echo $cc_version_info | grep -oE "$version_string"`
-
-if [ `echo $cc_version | grep -oE "$version_string" | wc -l` -gt 0 ]; then
-  has_cc_version='yes'
-  cc_version_major=`echo $cc_version | cut -d '.' -f1`
-  cc_version_minor=`echo $cc_version | cut -d '.' -f2`
-  cc_version_patch=`echo $cc_version | cut -d "$patch_seperator" -f3`
-fi
-
-if [ "$has_cc_version" = 'yes' ]; then
-  echo "  $cc version $cc_version found.."
-else
-   echo  "Warning: Failed to detect $cc version."
-fi
-
-if [ "$os_name" = 'osx' ] && [ `echo $cc_version | grep -oE "$version_string" | wc -l` -lt 1 ] ; then
-  cc_version=`$cc_search -v 2>&1 | grep -oE "$version_string" | tail -1`
-  if [ `"$cc_search" -v 2>&1 | grep "clang"` -gt 0 ]; then
-    echo  "Error: $cc compiler was requested but clang c compiler is loaded."
-    echo  "       Please load the correct compiler."
-    exit 1
-  fi
-fi
-
-# check the cxx compiler version
-has_cxx_version='no'
-cxx_version='not'
-cxx_version_major=''
-cxx_version_minor=''
-cxx_version_patch=''
-cxx_search_string="$cxx_search\s[vV]ersion\s$version_string"
-
-# pgi & nvidia compilers use a different version output
-if [ "$cxx_search" = 'pgc++' ]; then
-  cxx_search_string="pgc\+\+\s$version_string"
-fi
-
-if [ "$cxx_search" = 'nvc++' ]; then
-  cxx_search_string="nvc\+\+\s$version_string"
-fi
-
-
-cxx_version_info=`$cxx_search $info_option 2>&1 | grep -oE "$cxx_search_string"`
-
-# some gnu installations gives off 'gcc version xx.xx.xx' instead of 'g++ version xx.xx.xx'
-if [ -z "$cxx_version_info" ]; then
-  cxx_version_info=`$cxx_search $info_option 2>&1 | grep -oE "$cc_search\s[vV]ersion\s$version_string"`
-fi
-
-cxx_version=`echo $cxx_version_info | grep -oE "$version_string"`
-
-if [ `echo $cxx_version | grep -oE "$version_string" | wc -l` -gt 0 ]; then
-  has_cxx_version='yes'
-  cxx_version_major=`echo $cxx_version | cut -d '.' -f1`
-  cxx_version_minor=`echo $cxx_version | cut -d '.' -f2`
-  cxx_version_patch=`echo $cxx_version | cut -d "$patch_seperator" -f3`
-fi
-
-if [ "$has_cxx_version" = 'yes' ]; then
-  echo "  $cxx version $cxx_version found.."
-else
-   echo  "Warning: Failed to detect $cxx version."
-fi
-
-if [ "$os_name" = 'osx' ] && [ `echo $cxx_version | grep -oE "$version_string" | wc -l` -lt 1 ] ; then
-  cxx_version=`$cxx_search -v 2>&1 | grep -E "$cxx_search | [vV]ersion " | grep -oE "$version_string" | tail -1`
-  if [ `"$cxx_search" -v 2>&1 | grep "clang"` > 0 ]; then
-    echo  "Error: $cxx compiler was requested but clang c++ compiler is loaded."
-    echo  "       Please load the correct compiler."
-    exit 1
-  fi
-fi
-
-# check for version compatibility
-if [ "$has_fort_version" = 'yes' ] && [ "$has_cc_version" = 'yes' ] && [ "$has_cxx_version" = 'yes' ]; then
-  if [ ! "$fort_version_major" = "$cc_version_major" ] && [ ! "$fort_version_major" = "$cxx_version_major" ]; then
-     print_compiler_mistmatch
-     exit 1
-   elif [ ! "$fort_version_minor" = "$cc_version_minor" ] && [ ! "$fort_version_minor" = "$cxx_version_minor" ]; then
-     print_compiler_mistmatch
-     exit 1
-   elif [ ! "$fort_version_patch" = "$cc_version_patch" ] && [ ! "$fort_version_patch" = "$cxx_version_patch" ]; then
-    print_compiler_mistmatch
-    exit 1
-  fi
-fi
-
 
 }
 
@@ -669,6 +524,7 @@
     gnu)           compiler='gnu';;
     intel)         compiler='intel';;
     pgi)           compiler='pgi';;
+    a64fx)           compiler='a64fx';;
     nvidia)        compiler='nvidia';;
     -h| -H| -help| --help) print_help;;
      *)  echo  "Error: $1 is an unknown flag."
@@ -763,7 +619,9 @@
   # copy the contents of basis folder since user may delete/relocate
   # QUICK_HOME folder after installation
   if [ ! -d "$quick_prefix/basis" ]; then
+    echo "mkdir -p \"$quick_prefix/basis\""
     mkdir -p "$quick_prefix/basis"
+    echo "cp -rf \"$QUICK_HOME/basis/\"* \"$quick_prefix/basis/\""
     cp -rf "$QUICK_HOME/basis/"* "$quick_prefix/basis/"
   fi
 
@@ -795,6 +653,16 @@
     installtypes="$installtypes $buildtype$install_string"
     uninstalltypes="$uninstalltypes $buildtype$uninstall_string"
   done
+
+elif [ "$aminstall" = "true" ]; then 
+  # copy the contents of basis folder since user may delete/relocate
+  # QUICK_HOME folder after installation
+  if [ ! -d "$quick_prefix/basis" ]; then
+    echo "mkdir -p \"$quick_prefix/basis\""
+    mkdir -p "$quick_prefix/basis"
+    echo "cp -rf \"$QUICK_HOME/basis/\"* \"$quick_prefix/basis/\""
+    cp -rf "$QUICK_HOME/basis/"* "$quick_prefix/basis/"
+  fi
 fi
 
 if [ "$useprefix" = "false" ]; then
@@ -1032,6 +900,11 @@
       cc_debug_flags='-g -traceback -DDEBUG'
       cxx_debug_flags='-g -traceback -DDEBUG'
       ;;
+    a64fx)
+      fort_debug_flags='-g -Cpp -DDEBUG -DDEBUGTIME'
+      cc_debug_flags='-g -DDEBUG'
+      cxx_debug_flags='-g -DDEBUG'
+      ;;
   esac
 
   if [ "$cuda" = 'yes' -o "$cudampi" = 'yes' ]; then
@@ -1086,8 +959,11 @@
         cflags="-L$CUDA_HOME/lib64 -lcuda -lm -lcudart -lcudadevrt -lcublas -lcusolver"
       fi
       ;;
+    a64fx)
+      fort_flags="$opt_flags $fort_debug_flags -Kfast -Free -Cpp --linkstl=libc++ $lib_flags -I$QUICK_HOME/build/include/$buildtype -M $QUICK_HOME/build/include/$buildtype"
+      ;;
     nvidia)
-      fort_flags="$opt_flags $fort_debug_flags -m64 -cpp $lib_flags -I$QUICK_HOME/build/include/$buildtype -module $QUICK_HOME/build/include/$buildtype"
+      fort_flags="$opt_flags $fort_debug_flags -Kpic -Kfast,simd_nouse_multiple_structures -Cpp $lib_flags -I$QUICK_HOME/build/include/$buildtype -module $QUICK_HOME/build/include/$buildtype"
       if [ "$cuda" = 'yes' ] || [ "$cudampi" = 'yes' ]; then
         cflags="-L$CUDA_HOME/lib64 -lcuda -lm -lcudart -lcudadevrt -lcublas -lcusolver"
       fi
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/quick/src/CMakeLists.txt ./AmberTools/src/quick/src/CMakeLists.txt
--- AmberTools/src/quick/src/CMakeLists.txt	2022-08-29 08:37:41.000000000 +0900
+++ ./AmberTools/src/quick/src/CMakeLists.txt	2022-08-24 10:36:38.000000000 +0900
@@ -102,6 +102,11 @@
 set(TEST_API_SOURCES quick_api_test.f90)
 set(MAIN_SOURCES main.f90)
 
+message(STATUS "CMAKE_Fortran_COMPILER_ID: ${CMAKE_Fortran_COMPILER_ID}  COMPILER: ${COMPILER}")
+if( "${COMPILER}" STREQUAL "FUJITSU" )
+	set(OPT_FFLAGS -Kfast -Ksimd_nouse_multiple_structures -Kpic -Cpp )
+        add_flags(Fortran -Cpp)
+endif()
 
 # the "subs" and "modules" source lists are for items in subdirectories.  We have to prepend the subdirectory path to these items.
 # --------------------------------------------------------------------
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/quick/src/blas/Makefile ./AmberTools/src/quick/src/blas/Makefile
--- AmberTools/src/quick/src/blas/Makefile
+++ AmberTools/src/quick/src/blas/Makefile
@@ -58,7 +58,23 @@
         $(blasobjfolder)/zhpr2.o \
 	$(blasobjfolder)/zgemm.o $(blasobjfolder)/zsymm.o $(blasobjfolder)/zsyrk.o $(blasobjfolder)/zsyr2k.o \
         $(blasobjfolder)/ztrmm.o $(blasobjfolder)/ztrsm.o $(blasobjfolder)/zhemm.o $(blasobjfolder)/zherk.o \
-        $(blasobjfolder)/zher2k.o $(blasobjfolder)/lsame.o $(blasobjfolder)/xerbla.o
+        $(blasobjfolder)/zher2k.o $(blasobjfolder)/lsame.o $(blasobjfolder)/xerbla.o \
+	$(blasobjfolder)/ssteqr.o  $(blasobjfolder)/sorgtr.o  $(blasobjfolder)/ssytrd.o \
+	$(blasobjfolder)/slansy.o  $(blasobjfolder)/sstebz.o $(blasobjfolder)/sormtr.o \
+	$(blasobjfolder)/sstein.o  $(blasobjfolder)/slacpy.o  $(blasobjfolder)/slasrt.o \
+	$(blasobjfolder)/ssterf.o  $(blasobjfolder)/slasr.o  $(blasobjfolder)/sorgql.o \
+	$(blasobjfolder)/slapy2.o $(blasobjfolder)/slassq.o $(blasobjfolder)/slascl.o \
+	$(blasobjfolder)/slaset.o $(blasobjfolder)/ssytd2.o \
+	$(blasobjfolder)/slatrd.o $(blasobjfolder)/sormqr.o $(blasobjfolder)/slae2.o \
+	$(blasobjfolder)/slagts.o $(blasobjfolder)/sisnan.o $(blasobjfolder)/scombssq.o \
+	$(blasobjfolder)/slarnv.o $(blasobjfolder)/slaebz.o $(blasobjfolder)/slartg.o \
+	$(blasobjfolder)/slaev2.o $(blasobjfolder)/slanst.o $(blasobjfolder)/sormql.o \
+	$(blasobjfolder)/sorgqr.o $(blasobjfolder)/slagtf.o $(blasobjfolder)/sorm2l.o \
+	$(blasobjfolder)/slaisnan.o $(blasobjfolder)/sorg2r.o $(blasobjfolder)/slarft.o \
+	$(blasobjfolder)/slarfg.o $(blasobjfolder)/slarfb.o $(blasobjfolder)/sorm2r.o \
+	$(blasobjfolder)/slaruv.o $(blasobjfolder)/slarf.o $(blasobjfolder)/sorg2l.o \
+	$(blasobjfolder)/ilaslc.o $(blasobjfolder)/ilaslr.o $(blasobjfolder)/slamch.o
+
 
 #  !---------------------------------------------------------------------!
 #  ! Build targets                                                       !
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/quick/src/dlfind/Makefile ./AmberTools/src/quick/src/dlfind/Makefile
--- AmberTools/src/quick/src/dlfind/Makefile	2022-08-29 08:38:32.000000000 +0900
+++ ./AmberTools/src/quick/src/dlfind/Makefile	2022-05-18 14:10:31.000000000 +0900
@@ -40,7 +40,8 @@
 
 OBJ =  $(OBJ_NOLAPACK) $(OBJ_LAPACK) 
 
-OBJ_MAIN = $(dlfindobjfolder)/dlfind_main_driver.o $(dlfindobjfolder)/dlf_serial.o 
+OBJ_MAIN = $(dlfindobjfolder)/dlfind_main_driver.o $(dlfindobjfolder)/dlf_serial.o \
+	   $(dlfindobjfolder)/dl_find.o
 ##OBJ_MAIN = $(dlfindobjfolder)/dlf_serial.o 
 
 
@@ -49,20 +50,21 @@
 #  !---------------------------------------------------------------------!
 
 $(OBJ_MOD):$(dlfindobjfolder)/%.o:%.f90
-	@echo "[QUICK]  FC $@"
-	$(VB)$(FOR) -c $< -o $@
+	echo "[QUICK]  FC $@"
+	$(VB)$(FOR) -c $< -o $@ -Cpp -fPIC
 
 $(OBJ):$(dlfindobjfolder)/%.o:%.f90
-	@echo "[QUICK]  FC $@"
-	$(VB)$(FOR) -c $< -o $@
+	echo "[QUICK]  FC $@"
+	$(VB)$(FOR) -c $< -o $@ -Cpp -fPIC
 
 $(OBJ_MAIN):$(dlfindobjfolder)/%.o:%.f90
-	@echo "[QUICK]  FC $@"
-	$(VB)$(FOR) -c $< -o $@
+	echo "[QUICK]  FC $@"
+	$(VB)$(FOR) -c $< -o $@ -Cpp -fPIC
 
 dlfind:$(OBJ_MOD) $(OBJ) $(OBJ_MAIN)
 	$(VB) $(ARCH) $(ARCHFLAGS) $(libfolder)/libdlfind.$(LIBEXT) $(dlfindobjfolder)/*.o
-	@-rm -f $(dlfindobjfolder)/dlfind_main_driver.o
+	cp  $(libfolder)/libdlfind.$(LIBEXT) $(installfolder)/lib
+	-rm -f $(dlfindobjfolder)/dlfind_main_driver.o
 
 #  !---------------------------------------------------------------------!
 #  ! Cleaning targets                                                    !
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/quick/src/dlfind/dlf_allocate.f90 ./AmberTools/src/quick/src/dlfind/dlf_allocate.f90
--- AmberTools/src/quick/src/dlfind/dlf_allocate.f90	2022-08-29 08:38:32.000000000 +0900
+++ ./AmberTools/src/quick/src/dlfind/dlf_allocate.f90	2022-05-15 19:21:33.000000000 +0900
@@ -46,33 +46,9 @@
 !!  it under the terms of the GNU Lesser General Public License as 
 !!  published by the Free Software Foundation, either version 3 of the 
 !!  License, or (at your option) any later version.
-!!
-!!  DL-FIND is distributed in the hope that it will be useful,
-!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
-!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-!!  GNU Lesser General Public License for more details.
-!!
-!!  You should have received a copy of the GNU Lesser General Public 
-!!  License along with DL-FIND.  If not, see 
-!!  <http://www.gnu.org/licenses/>.
-!!
 !! SOURCE
 module dlf_allocate
 
-#ifdef OLDALLOC 
-
-contains
-
-  ! only dummies. These subroutines should never be called
-  subroutine allocate_report
-  end subroutine allocate_report
-  subroutine allocate
-  end subroutine allocate
-  subroutine deallocate
-  end subroutine deallocate
-
-#else 
-
   use dlf_parameter_module, only: rk
   implicit none
 
@@ -477,6 +453,4 @@
   end subroutine allocate_report
 !!****
 
-#endif
-
 end module dlf_allocate
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/quick/src/hessian.f90 ./AmberTools/src/quick/src/hessian.f90
--- AmberTools/src/quick/src/hessian.f90	2022-08-29 08:38:28.000000000 +0900
+++ ./AmberTools/src/quick/src/hessian.f90	2022-05-05 14:56:49.000000000 +0900
@@ -8441,7 +8441,11 @@
     ! ASSIGN INVERSE ITERATION VECTOR FROM RANDOM NUMBERS.
     
         do 120 I=1,NDIM
+#ifdef __FUJITSU
+            CALL RANDOM_NUMBER(RNDOM)
+#else
             CALL RANDOM(IRAND,RNDOM)
+#endif
             RNDOM = 2.0D0*(RNDOM - 0.5D0)
             EVEC1(I,M) = RNDOM*TOLERA
         120 enddo
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/quick/src/lapack/Makefile ./AmberTools/src/quick/src/lapack/Makefile
--- AmberTools/src/quick/src/lapack/Makefile	2022-08-29 08:37:44.000000000 +0900
+++ ./AmberTools/src/quick/src/lapack/Makefile	2022-05-18 14:26:36.000000000 +0900
@@ -95,7 +95,7 @@
         $(lapackobjfolder)/zlarft.o $(lapackobjfolder)/zlascl.o $(lapackobjfolder)/zlaset.o \
         $(lapackobjfolder)/zlasr.o $(lapackobjfolder)/zlassq.o $(lapackobjfolder)/zlatrd.o \
         $(lapackobjfolder)/zsteqr.o $(lapackobjfolder)/zung2l.o $(lapackobjfolder)/zung2r.o \
-        $(lapackobjfolder)/zungql.o $(lapackobjfolder)/zungqr.o $(lapackobjfolder)/zungtr.o
+        $(lapackobjfolder)/zungql.o $(lapackobjfolder)/zungqr.o $(lapackobjfolder)/zungtr.o 
 
 #  !---------------------------------------------------------------------!
 #  ! Build targets                                                       !
@@ -107,6 +107,7 @@
 
 all:$(LAPACKOBJ)
 	$(VB)$(ARCH) $(ARCHFLAGS) $(libfolder)/liblapack.$(LIBEXT) $(lapackobjfolder)/*.o
+	cp  $(libfolder)/liblapack.$(LIBEXT) $(installfolder)/lib/liblapack-quick.$(LIBEXT)
 
 #  !---------------------------------------------------------------------!
 #  ! Cleaning targets                                                    !
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/quick/src/libxc/CMakeLists.txt ./AmberTools/src/quick/src/libxc/CMakeLists.txt
--- AmberTools/src/quick/src/libxc/CMakeLists.txt	2022-08-29 08:38:03.000000000 +0900
+++ ./AmberTools/src/quick/src/libxc/CMakeLists.txt	2022-08-24 08:44:56.000000000 +0900
@@ -133,6 +133,12 @@
 target_compile_definitions(xc PUBLIC USE_CMAKE_MANGLING)
 config_module_dirs(xc libxc/serial)
 
+message(STATUS "CMAKE_Fortran_COMPILER_ID: ${CMAKE_Fortran_COMPILER_ID}  COMPILER: ${COMPILER}")
+if( "${COMPILER}" STREQUAL "FUJITSU" )
+	set(OPT_FFLAGS -Kfast -Ksimd_nouse_multiple_structures -Kpic )
+        add_flags(Fortran -Cpp -Kpic )
+endif()
+
 # supress maybe uninitialized warnings
 if("${CMAKE_C_COMPILER_ID}" STREQUAL "GNU")
 	target_compile_options(xc PRIVATE -Wno-maybe-uninitialized)
@@ -149,4 +155,4 @@
 # build cuda code
 if(CUDA)
 	add_subdirectory(maple2c_device)
-endif()
\ No newline at end of file
+endif()
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/quick/src/subs/eigvec.f90 ./AmberTools/src/quick/src/subs/eigvec.f90
--- AmberTools/src/quick/src/subs/eigvec.f90	2022-08-29 08:37:51.000000000 +0900
+++ ./AmberTools/src/quick/src/subs/eigvec.f90	2022-05-05 14:56:49.000000000 +0900
@@ -97,7 +97,11 @@
      ! ASSIGN INVERSE ITERATION VECTOR FROM RANdoM NUMBERS.
 
      do 120 I=1,NDIM
+#ifdef __FUJITSU
+        CALL RANDOM_NUMBER(RNdoM)
+#else
         CALL RANdoM(IRAND,RNdoM)
+#endif
         RNdoM = 2.0D0*(RNdoM - 0.5D0)
         EVEC1(I,M) = RNdoM*TOLERA
 120  enddo
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/quick/tools/build-makefile ./AmberTools/src/quick/tools/build-makefile
--- AmberTools/src/quick/tools/build-makefile	2022-08-29 08:36:58.000000000 +0900
+++ ./AmberTools/src/quick/tools/build-makefile	2022-05-19 20:01:15.000000000 +0900
@@ -214,8 +214,14 @@
 
 mpi: cpmakein libxc_cpu quick_modules dlfind octree quick_subs $(OBJ) $(MAIN) blas-quick lapack $(TESTAPI)
 	$(VB)$(ARCH) $(ARCHFLAGS) $(libfolder)/libquick-mpi.$(LIBEXT) $(objfolder)/*.o
-	$(VB)$(FC) -o $(exefolder)/quick.MPI $(MAIN) -L$(libfolder) -lquick-mpi -lblas-quick -lxc -ldlfind -llapack -lblas-quick $(LDFLAGS)
-	$(VB)$(FC) -o $(exefolder)/test-api.MPI $(TESTAPI) -L$(libfolder) -lquick-mpi -lblas-quick -lxc -ldlfind -llapack -lblas-quick $(LDFLAGS)
+	$(VB)$(FC) -o $(exefolder)/quick.MPI $(MAIN) -L$(libfolder) -lquick-mpi -lblas-quick -ldlfind -lxc -ldlfind -llapack -lblas-quick $(LDFLAGS)
+	
+	$(VB)if [[ "$(FC)" = "mpifrt" ]] ; then \
+	  $(VB)$(CXX) --linkfortran -o $(exefolder)/test-api.MPI $(TESTAPI) -L$(libfolder) -lquick-mpi -lblas-quick  -ldlfind -llapack -lxc -stdlib=libc++ ;\
+        else \
+	   $(VB)$(FC) -o $(exefolder)/test-api.MPI $(TESTAPI) -L$(libfolder) -lquick-mpi -lblas-quick -lxc $(LDFLAGS) ;\
+	fi
+#	$(VB)$(FC) -o $(exefolder)/test-api.MPI $(TESTAPI) -L$(libfolder) -lquick-mpi -lblas-quick -lxc -ldlfind -llapack -lblas-quick $(LDFLAGS)
 
 cudampi: cpmakein libxc_cuda quick_modules dlfind octree quick_cuda quick_subs $(OBJ) $(MAIN) $(cusolverobj) $(cublasobj) blas-quick lapack $(TESTAPI)
 	$(VB)$(ARCH) $(ARCHFLAGS) $(libfolder)/libquick-cudampi.$(LIBEXT) $(objfolder)/*.o $(libxcdevobjfolder)/*.o
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/reduce/libpdb/Makefile ./AmberTools/src/reduce/libpdb/Makefile
--- AmberTools/src/reduce/libpdb/Makefile	2022-08-29 08:33:50.000000000 +0900
+++ ./AmberTools/src/reduce/libpdb/Makefile	2022-08-29 14:27:23.000000000 +0900
@@ -6,7 +6,7 @@
 
 .cpp.o:
 	@echo "[REDUCE]  CXX $<"
-	$(VB)$(CXX) $(CFLAGS) $(AMBERCXXFLAGS) -c $< -o $@
+	$(CXX) $(CFLAGS) $(AMBERCXXFLAGS) -c $< -o $@ 
 
 OPT		= -O
 DEBUG		= $(CXXDEBUGFLAGS)
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/reduce/reduce_src/Makefile ./AmberTools/src/reduce/reduce_src/Makefile
--- AmberTools/src/reduce/reduce_src/Makefile	2022-08-29 08:33:49.000000000 +0900
+++ ./AmberTools/src/reduce/reduce_src/Makefile	2022-08-29 14:28:15.000000000 +0900
@@ -28,7 +28,7 @@
 
 .cpp.o :
 	@echo "[REDUCE]  CXX $<"
-	$(VB)$(CXX) -c $(CFLAGS) $(AMBERCXXFLAGS) -o $@ $<
+	$(VB)$(CXX) -c $(CFLAGS) $(AMBERCXXFLAGS) -o $@ $< 
 
 .c.o :
 	@echo "[REDUCE]  CC $<"
@@ -41,7 +41,7 @@
 
 reduce$(SFX): $(OBJLIST)
 	@echo "[REDUCE]  CXX $@"
-	$(VB)$(CXX) $(LDFLAGS) $(AMBERLDFLAGS) -o $@ $(OBJLIST) $(LFLAGS) $(AMBERBUILDFLAGS)
+	$(VB)$(CXX) $(CXXFLAGS) $(LDFLAGS) $(AMBERLDFLAGS) -o $@ $(OBJLIST) $(LFLAGS) $(AMBERBUILDFLAGS) 
 
 clean:
 	@rm -rf *.o *.ckp ii_files
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/reduce/toolclasses/Makefile ./AmberTools/src/reduce/toolclasses/Makefile
--- AmberTools/src/reduce/toolclasses/Makefile	2022-08-29 08:33:51.000000000 +0900
+++ ./AmberTools/src/reduce/toolclasses/Makefile	2022-08-29 14:28:47.000000000 +0900
@@ -9,7 +9,7 @@
 
 .cpp.o:
 	@echo "[REDUCE]  CXX $<"
-	$(VB)$(CXX) $(CFLAGS) $(AMBERCXXFLAGS) -c $< -o $@
+	$(VB)$(CXX) $(CFLAGS) $(AMBERCXXFLAGS) -c $< -o $@ 
 
 OPT		= -O
 DEBUG		= $(CXXDEBUGFLAGS)
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/rism/Makefile ./AmberTools/src/rism/Makefile
--- AmberTools/src/rism/Makefile	2022-08-29 08:42:03.000000000 +0900
+++ ./AmberTools/src/rism/Makefile	2022-05-05 14:56:48.000000000 +0900
@@ -61,13 +61,20 @@
 
 
 librism: $(LIBOBJ)
-	@echo "[RISM]  AR $@"
+	$(VB)echo "[RISM]  AR $@"
+	$(VB)if [[ "$(FC)" = *"frt"* ]] ; then \
+                $(FC) $(FPPFLAGS) -c -Kpic -fs -Kfast,noeval,simd_nouse_multiple_structures -Free rism3d_potential_c  -o rism3d_potential_c.o rism3d_potential_c.F90 ;\
+        fi ;\
+        
 	$(VB)$(AR) $(LIBDIR)/$@.a $(LIBOBJ) > /dev/null
 	$(VB)$(RANLIB) $(LIBDIR)/$@.a
 
 librism_mpi: $(LIBOBJ_MPI)
 	@echo "[RISM]  AR $@"
-	$(VB)$(AR) $(LIBDIR)/$@.a $(LIBOBJ_MPI) > /dev/null
+	$(VB)if [[ "$(FC)" = *"frt"* ]] ; then \
+                $(FC) $(FPPFLAGS) -c -Kpic -fs -Kfast,noeval,simd_nouse_multiple_structures -Free rism3d_potential_c  -o rism3d_potential_c.o rism3d_potential_c.F90 ;\
+        fi ;\
+	$(VB)$(AR) $(LIBDIR)/$@.a $(LIBOBJ_MPI) 
 	$(VB)$(RANLIB) $(LIBDIR)/$@.a
 
 # ------ volslice information ------------------------------------------
@@ -75,7 +82,7 @@
 VSOBJ=volslice.o
 volslice$(SFX): $(VSOBJ) librism $(XBLAS)
 	@echo "[RISM]  FC $@"
-	$(VB)$(FC) $(FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o $(BINDIR)/volslice$(SFX) $(VSOBJ) \
+	$(FC) $(FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o $(BINDIR)/volslice$(SFX) $(VSOBJ) \
 	        -lrism $(FLIBSF) $(FLIBS_FFTW3) \
 	        $(FLIBSF) $(LDFLAGS) $(AMBERLDFLAGS) $(XBLAS) -L$(LIBDIR)
 
@@ -86,7 +93,7 @@
 
 rism3d.orave$(SFX): $(ORAVE_OBJ) librism orave.h
 	@echo "[RISM]  FC $@"
-	$(VB)$(FC) $(FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o rism3d.orave$(SFX) $(ORAVE_OBJ) \
+	$(FC) $(FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o rism3d.orave$(SFX) $(ORAVE_OBJ) \
 	        -L$(LIBDIR) -lrism  $(FLIBS_FFTW3) \
 	        $(FLIBSF) $(LDFLAGS) $(AMBERLDFLAGS)
 
@@ -99,7 +106,7 @@
 
 rism3d.thermo$(SFX): $(THERMOOBJ) librism
 	@echo "[RISM]  FC $@"
-	$(VB)$(FC) $(FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o rism3d.thermo$(SFX) \
+	$(FC) $(FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o rism3d.thermo$(SFX) \
 	      -L$(LIBDIR) $(THERMOOBJ) -lrism  $(FLIBS_FFTW3) \
 	      $(FLIBSF) $(LDFLAGS) $(AMBERLDFLAGS)
 # ------ Single-Point information ------------------------------------------
@@ -110,18 +117,30 @@
 	$(LEX) rism_options.l
 
 $(SPOBJ): %.o : %.c
-	@echo "[RISM]  CC $<"
-	$(VB)$(CC) -c $(COPTFLAGS) $(CFLAGS) $(AMBERCFLAGS) -I$(INCDIR) -I. -o $@ $<
+	$(VB)echo "[RISM]  CC $<"
+	$(VB)if [[ "$(CC)" = *"fcc"* ]] ; then \
+	  $(CC) -c $(COPTFLAGS) $(CFLAGS) $(AMBERCFLAGS) --linkfortran -I$(INCDIR) -I. -o $@ $< ;\
+	else \
+	  $(CC) -c $(COPTFLAGS) $(CFLAGS) $(AMBERCFLAGS) -I$(INCDIR) -I. -o $@ $< ;\
+        fi ;\
 
 rism3d.snglpnt$(SFX): $(SPOBJ)
-	@echo "[RISM]  CC $@"
-	$(VB)$(CC) $(CFLAGS) $^ -L$(LIBDIR) $(FLIBS) $(LM) \
-       $(LDFLAGS) -o $(BINDIR)/rism3d.snglpnt$(SFX)
+	$(VB)echo "[RISM]  CC $@"
+	$(VB)if [[ "$(CC)" = *"fcc"* ]] ; then \
+	  $(CC) $(CFLAGS) $^ -L$(LIBDIR) $(FLIBS) $(LM) --linkfortran $(LDFLAGS) -o $(BINDIR)/rism3d.snglpnt$(SFX) ;\
+        else \
+	  $(CC) $(CFLAGS) $^ -L$(LIBDIR) $(FLIBS) $(LM) $(LDFLAGS) -o $(BINDIR)/rism3d.snglpnt$(SFX) ;\
+        fi ;\
+
 
 rism3d.snglpnt.MPI$(SFX): $(SPOBJ)
-	@echo "[RISM]  CC $@"
-	$(VB)$(CC) $(CFLAGS) $^ -L$(LIBDIR) $(FLIBS) $(LM) \
-         $(LDFLAGS) -o $(BINDIR)/rism3d.snglpnt.MPI$(SFX)
+	$(VB)echo "[RISM]  CC $@"
+	$(VB)if [[ "$(CC)" = *"fcc"* ]] ; then \
+	  $(CC) $(CFLAGS) $^ -L$(LIBDIR) $(FLIBS) $(LM) --linkfortran $(LDFLAGS) -o $(BINDIR)/rism3d.snglpnt.MPI$(SFX) ;\
+        else \
+	  $(CC) $(CFLAGS) $^ -L$(LIBDIR) $(FLIBS) $(LM) $(LDFLAGS) -o $(BINDIR)/rism3d.snglpnt.MPI$(SFX) ;\
+        fi ;\
+
 # --------------------------------------------------------------------------
 
 yes: install
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/rism/rism1d_c.F90 ./AmberTools/src/rism/rism1d_c.F90
--- AmberTools/src/rism/rism1d_c.F90	2022-08-29 08:42:04.000000000 +0900
+++ ./AmberTools/src/rism/rism1d_c.F90	2022-05-05 14:56:48.000000000 +0900
@@ -949,6 +949,10 @@
 #ifdef __PGI
     use ieee_arithmetic, only : ieee_is_nan
 #endif
+#ifdef __FUJITSU
+    use ieee_arithmetic, only : ieee_is_nan
+#endif
+
     implicit none
     type(rism1d), intent(inout) :: this
     integer, intent(in) ::  maxstep,ksave,progress
@@ -1042,6 +1046,8 @@
        ! the PGI define to enable the most support for old compilers.
 #ifdef __PGI
        if (ieee_is_nan(residual)) &
+#elif __FUJITSU
+       if (ieee_is_nan(residual)) &
 #else
        if (isnan(residual)) &
 #endif
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/rism/rism3d_closure_c.F90 ./AmberTools/src/rism/rism3d_closure_c.F90
--- AmberTools/src/rism/rism3d_closure_c.F90	2022-08-29 08:42:03.000000000 +0900
+++ ./AmberTools/src/rism/rism3d_closure_c.F90	2022-05-05 14:56:48.000000000 +0900
@@ -2962,6 +2962,8 @@
     use constants, only : PI, FOURPI
 #ifdef __PGI
     use ieee_arithmetic, only : ieee_is_nan
+#elif __FUJITSU
+    use, intrinsic :: ieee_arithmetic
 #endif
     implicit none
     type(rism3d_potential), intent(inout) :: this !< potential object.
@@ -3036,6 +3038,8 @@
                 
 #ifdef __PGI
                 if (ieee_is_nan(this%grid%waveVectors2(ig))) &
+#elif __FUJITSU
+                if (ieee_is_nan(this%grid%waveVectors2(ig))) &
 #else
                 if (isnan(this%grid%waveVectors2(ig))) &
 #endif
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/rism/rism3d_potential_c.F90 ./AmberTools/src/rism/rism3d_potential_c.F90
--- AmberTools/src/rism/rism3d_potential_c.F90	2022-08-29 08:42:05.000000000 +0900
+++ ./AmberTools/src/rism/rism3d_potential_c.F90	2022-05-05 14:56:48.000000000 +0900
@@ -479,6 +479,8 @@
     use asympk_cut
 #ifdef __PGI
     use ieee_arithmetic, only : ieee_is_nan
+#elif __FUJITSU
+    use, intrinsic :: ieee_arithmetic
 #endif
     implicit none
     type(rism3d_potential), intent(inout) :: this
@@ -495,6 +497,8 @@
       ! the PGI define to enable the most support for old compilers.
 #ifdef __PGI
       if (ieee_is_nan(this%cut2_chlk)) then
+#elif __FUJITSU
+      if (ieee_is_nan(this%cut2_chlk)) then
 #else
       if (isnan(this%cut2_chlk)) then
 #endif
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/Makefile ./AmberTools/src/sander/Makefile
--- AmberTools/src/sander/Makefile	2022-08-29 08:36:20.000000000 +0900
+++ ./AmberTools/src/sander/Makefile	2022-05-25 11:46:50.000000000 +0900
@@ -38,6 +38,40 @@
 # Add also search paths for .mod files
 LOCALFLAGS = $(FREEFORMAT_FLAG) -I../pbsa -I../sqm -I../rism -I../../../include
 
+KMMD=kmmd_externFortran.o kmmd_context.o kmmd_forcecalc.o kmmd_parseJSON.o pdb_io.o \
+          scanDB.o DB_vs_forcefield.o hash.o
+
+hash.o:	$(AMBERHOME)/AmberTools/src/kmmd/hash.c
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/hash.c
+
+DB_vs_forcefield.o:	$(AMBERHOME)/AmberTools/src/kmmd/DB_vs_forcefield.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/DB_vs_forcefield.C
+
+kmmd_externFortran.o:	$(AMBERHOME)/AmberTools/src/kmmd/kmmd_externFortran.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/kmmd_externFortran.C
+
+kmmd_context.o:	$(AMBERHOME)/AmberTools/src/kmmd/kmmd_context.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/kmmd_context.C
+
+kmmd_forcecalc.o:	$(AMBERHOME)/AmberTools/src/kmmd/kmmd_forcecalc.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/kmmd_forcecalc.C
+
+kmmd_parseJSON.o:	$(AMBERHOME)/AmberTools/src/kmmd/kmmd_parseJSON.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/kmmd_parseJSON.C
+
+pdb_io.o:	$(AMBERHOME)/AmberTools/src/kmmd/pdb_io.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/pdb_io.C
+
+scanDB.o:	$(AMBERHOME)/AmberTools/src/kmmd/scanDB.C
+		@echo "[SANDER]  CC $<"
+			$(CC) -c $(AMBERHOME)/AmberTools/src/kmmd/scanDB.C
 
 EMILOBJ= \
     emil.o mdin_emil_dat.o
@@ -356,14 +390,17 @@
 	$(MAKE) $(BINDIR)/sander.APBS$(SFX)
 
 #---------------------------------------------------------------------------
-$(BINDIR)/sander$(SFX): libsqm $(MMOBJ) $(QMOBJ) \
+$(BINDIR)/sander$(SFX): $(KMMD) libsqm $(MMOBJ) $(QMOBJ) \
               $(FULLPIMDOBJ) $(EMIL) $(SEBOMDOBJ) sebomd \
               $(LSCIVROBJ) force.o syslib ../lib/nxtsec.o netlib \
-              $(NFE_OBJECTS) $(XRAY_OBJS) libpbsa libquick libtcpb librism $(PLUMED_DEPENDENCIES)
+              $(NFE_OBJECTS) libpbsa libquick libtcpb librism $(PLUMED_DEPENDENCIES)
 	@echo "[SANDER]  FC $@"
+	if [[ "$(FC)" = "frt" ]] ; then \
+	  $(FC) remd.F90 $(FPPFLAGS) -c -Kpic -Ksimd_nouse_multiple_structures -O0  ;\
+	fi
 	$(VB)$(FC) $(SANDER_FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o $@  $(MMOBJ) $(QMOBJ) $(SEBOMDOBJ) \
 	      $(FULLPIMDOBJ) $(LSCIVROBJ) force.o -L$(LIBDIR) -lsqm \
-	      $(NFE_OBJECTS) $(XRAY_OBJS) \
+	      $(NFE_OBJECTS) $(KMMD) \
 	      -lFpbsa ../lib/nxtsec.o \
 	      $(SEBOMDLIB) $(FBLIBS) \
 	      ../lib/sys.a $(NETCDFLIBF) \
@@ -371,6 +408,25 @@
 	      $(LDFLAGS) $(AMBERLDFLAGS)  $(LOCALFLAGS)  $(LIOLIBS) $(PLUMED_LOAD)
 
 #---------------------------------------------------------------------------
+$(BINDIR)/sander.MPI$(SFX): configured_parallel libsqm $(MMOBJ) $(QMOBJ) \
+              $(FULLPIMDOBJ) $(EMIL) $(LSCIVROBJ) $(EVBOBJ) force.o \
+              $(SEBOMDOBJ) sebomd $(KMMD) \
+              syslib ../lib/nxtsec.o netlib libpbsa libquick libtcpb librism_mpi $(NFE_OBJECTS) \
+              $(PLUMED_DEPENDENCIES)
+	@echo "[SANDER]  FC $@"
+	if [[ "$(FC)" = "mpifrt" ]] ; then \
+	  $(FC) remd.F90 $(FPPFLAGS) -c -Kpic -Ksimd_nouse_multiple_structures -O0  ;\
+	fi
+	$(VB)$(FC) $(SANDER_FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o $@  $(MMOBJ) $(QMOBJ) $(SEBOMDOBJ) \
+              $(FULLPIMDOBJ) $(LSCIVROBJ) $(EVBOBJ) force.o  \
+	      -L$(LIBDIR) -lsqm -lFpbsa \
+	      $(SEBOMDLIB) $(FBLIBS) $(KMMD) \
+	      ../lib/nxtsec.o ../lib/sys.a $(NFE_OBJECTS) $(NETCDFLIBF) \
+	      $(FLIBS_RISMSANDER) $(FFTW3) $(SANDER_FLIBSF) $(EMILLIB) \
+	      $(LDFLAGS) $(AMBERLDFLAGS)  $(LIOLIBS) $(PLUMED_LOAD)  -lstdc++ -lmpi_cxx \
+	       --linkstl=libc++
+
+#---------------------------------------------------------------------------
 $(BINDIR)/sander.quick.cuda$(SFX): configured_cuda libsqm $(MMOBJ) $(QMOBJ) \
               $(FULLPIMDOBJ) $(EMIL) $(SEBOMDOBJ) sebomd \
               $(LSCIVROBJ) force.o syslib ../lib/nxtsec.o netlib \
@@ -386,21 +442,6 @@
 	      $(LDFLAGS) $(AMBERLDFLAGS)  $(LOCALFLAGS)  $(LIOLIBS) $(PLUMED_LOAD)
 
 #---------------------------------------------------------------------------
-$(BINDIR)/sander.MPI$(SFX): configured_parallel libsqm $(MMOBJ) $(QMOBJ) \
-              $(FULLPIMDOBJ) $(EMIL) $(LSCIVROBJ) $(EVBOBJ) force.o \
-              $(SEBOMDOBJ) sebomd $(XRAY_OBJS) \
-              syslib ../lib/nxtsec.o netlib libpbsa libquick libtcpb librism_mpi $(NFE_OBJECTS) \
-              $(PLUMED_DEPENDENCIES)
-	@echo "[SANDER]  FC $@"
-	$(VB)$(FC) $(SANDER_FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o $@  $(MMOBJ) $(QMOBJ) $(SEBOMDOBJ) \
-              $(FULLPIMDOBJ) $(LSCIVROBJ) $(EVBOBJ) force.o \
-	      -L$(LIBDIR) -lsqm -lFpbsa \
-	      $(SEBOMDLIB) $(FBLIBS) $(XRAY_OBJS) \
-	      ../lib/nxtsec.o ../lib/sys.a $(NFE_OBJECTS) $(NETCDFLIBF) \
-	      $(FLIBS_RISMSANDER) $(FFTW3) $(SANDER_FLIBSF) $(EMILLIB) \
-	      $(LDFLAGS) $(AMBERLDFLAGS)  $(LIOLIBS) $(PLUMED_LOAD)
-
-#---------------------------------------------------------------------------
 $(BINDIR)/sander.quick.cuda.MPI$(SFX): configured_cuda configured_parallel libsqm $(MMOBJ) $(QMOBJ) \
               $(FULLPIMDOBJ) $(EMIL) $(LSCIVROBJ) $(EVBOBJ) force.o \
               $(SEBOMDOBJ) sebomd $(XRAY_OBJS) \
@@ -431,14 +472,14 @@
 
 
 #---------------------------------------------------------------------------
-$(BINDIR)/sander.LES$(SFX): libsqm $(LESOBJ) $(PARTPIMDOBJ) \
+$(BINDIR)/sander.LES$(SFX): $(KMMD) libsqm $(LESOBJ) $(PARTPIMDOBJ) \
               syslib ../lib/nxtsec.o netlib \
-              $(LSCIVROBJ) $(NFE_OBJECTS) $(XRAY_OBJS) \
+              $(LSCIVROBJ) $(NFE_OBJECTS)  \
               libpbsa libquick libtcpb librism $(EMIL) sebomd $(PLUMED_DEPENDENCIES)
 	@echo "[SANDER]  FC $@"
 	$(VB)$(FC) $(SANDER_FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o $@ $(LESOBJ) $(PARTPIMDOBJ) $(LSCIVROBJ) \
-		$(XRAY_OBJS) -L$(LIBDIR) -lsqm -lFpbsa \
-	        $(SEBOMDLIB) $(FBLIBS) \
+		-L$(LIBDIR) -lsqm -lFpbsa \
+	        $(SEBOMDLIB) $(FBLIBS)  $(KMMD) \
 		../lib/nxtsec.o ../lib/sys.a $(NFE_OBJECTS) $(NETCDFLIBF) \
 	      	$(FLIBS_RISMSANDER) $(FFTW3) $(SANDER_FLIBSF) $(EMILLIB) \
 		$(LDFLAGS) $(AMBERLDFLAGS)  $(LIOLIBS) $(PLUMED_LOAD)
@@ -460,15 +501,19 @@
 #---------------------------------------------------------------------------
 $(BINDIR)/sander.LES.MPI$(SFX): configured_parallel libsqm $(LESOBJ) $(EVBPIMD) \
               $(PARTPIMDOBJ) syslib ../lib/nxtsec.o \
-              netlib libpbsa libquick libtcpb librism_mpi $(EMIL) $(XRAY_OBJS) \
+              netlib libpbsa libquick libtcpb librism_mpi $(EMIL) $(KMMD) \
               $(LSCIVROBJ) $(NFE_OBJECTS) sebomd $(PLUMED_DEPENDENCIES)
 	@echo "[SANDER]  FC $@"
+	if [ "$(FC)" == "mpifrt" ] ; then \
+	  $(FC) remd.F90 -o remd.o $(FWARNFLAGS) $(FPPFLAGS) $(RISMSANDER) -c -Free -Kpic -Ksimd_nouse_multiple_structures -O0 -Free -I../pbsa -I../sqm -I../rism -I$(INCDIR) -DRISMSANDER ;\
+	fi
 	$(VB)$(FC) $(SANDER_FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o $@ $(LESOBJ) $(EVBPIMD) \
-              $(PARTPIMDOBJ) $(LSCIVROBJ) $(XRAY_OBJS) \
+              $(PARTPIMDOBJ) $(LSCIVROBJ) $(KMMD) \
               -L$(LIBDIR) -lsqm -lFpbsa $(SEBOMDLIB) $(FBLIBS) \
               ../lib/nxtsec.o ../lib/sys.a $(NFE_OBJECTS) $(NETCDFLIBF) \
               $(FLIBS_RISMSANDER) $(FFTW3) $(SANDER_FLIBSF) $(EMILLIB) \
-              $(LDFLAGS) $(AMBERLDFLAGS) $(LIOLIBS) $(PLUMED_LOAD)
+              $(LDFLAGS) $(AMBERLDFLAGS) $(LIOLIBS) $(PLUMED_LOAD) \
+	       --linkstl=libc++
 
 #---------------------------------------------------------------------------
 $(BINDIR)/sander.LES.quick.cuda.MPI$(SFX): configured_cuda configured_parallel libsqm $(LESOBJ) $(EVBPIMD) \
@@ -520,12 +565,12 @@
               $(SEBOMDOBJ) sebomd $(INCDIR)/sander_api.mod \
               $(LSCIVROBJ) force.o syslib $(PLUMED_DEPENDENCIES) \
               ../lib/nxtsec.o netlib \
-              $(NFE_OBJECTS) $(XRAY_OBJS) libpbsa libquick libtcpb librism fftw3_dummy.o
+              $(NFE_OBJECTS) libpbsa libquick libtcpb librism fftw3_dummy.o
 	@echo "[SANDER]  FC $@"
 	$(VB)$(FC) $(MAKE_SHARED) $(SANDER_FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) -o $@  $(APIOBJ) \
 		  $(QMAPIOBJ) $(SEBOMDOBJ) $(FULLPIMDOBJ) $(LSCIVROBJ) force.o \
 		  -L$(LIBDIR) -lsqm \
-	      $(NFE_OBJECTS) $(XRAY_OBJS) \
+	      $(NFE_OBJECTS) \
 	      -lFpbsa ../lib/nxtsec.o $(EMILLIB) \
 	      $(SEBOMDLIB) $(FBLIBS) \
 	      ../lib/sys.a $(NETCDFLIBF) \
@@ -535,12 +580,12 @@
 $(LIBDIR)/libsanderles$(SHARED_SUFFIX): libsqm $(LESAPIOBJ) \
 		$(PARTPIMDOBJ) $(QMAPIOBJ) syslib \
 		../lib/nxtsec.o netlib $(INCDIR)/sanderles_api.mod \
-		$(LSCIVROBJ) $(NFE_OBJECTS) $(XRAY_OBJS) \
+		$(LSCIVROBJ) $(NFE_OBJECTS) \
 		libpbsa libquick libtcpb librism $(EMIL) sebomd $(PLUMED_DEPENDENCIES) fftw3_dummy.o
 	@echo "[SANDER]  FC $@"
 	$(VB)$(FC) $(MAKE_SHARED) $(SANDER_FPPFLAGS) $(FFLAGS) $(AMBERFFLAGS) \
        -o $@ $(LESAPIOBJ) $(QMAPIOBJ) $(PARTPIMDOBJ) $(LSCIVROBJ) \
-		$(XRAY_OBJS) -L$(LIBDIR) -lsqm -lFpbsa $(EMILLIB) \
+		-L$(LIBDIR) -lsqm -lFpbsa $(EMILLIB) \
 	        $(SEBOMDLIB) $(FBLIBS) $(PLUMED_LOAD) \
 		../lib/nxtsec.o ../lib/sys.a $(NFE_OBJECTS) $(NETCDFLIBF) \
 	      	$(FLIBS_RISMSANDER) fftw3_dummy.o $(SANDER_FLIBSF) $(LIOLIBS)
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/ambmask.F90 ./AmberTools/src/sander/ambmask.F90
--- AmberTools/src/sander/ambmask.F90	2022-08-29 08:36:27.000000000 +0900
+++ ./AmberTools/src/sander/ambmask.F90	2022-05-05 14:56:48.000000000 +0900
@@ -113,21 +113,27 @@
    ! allocate memory for the topology arrays that we need:
    allocate(igraph(natom), stat=astat)
    if (astat/=0) stop "***igraph allocation error***"
+   igraph(:)=''
 
    allocate(isymbl(natom), stat=astat)
    if (astat/=0) stop "***isymbl allocation error***"
+   isymbl(:)=''
 
    allocate(lbres(nres), stat=astat)
    if (astat/=0) stop "***lbres allocation error***"
+   lbres(:)=''
 
    allocate(ipres(nres+1), stat=astat)
    if (astat/=0) stop "***ipres allocation error***"
+   ipres(1:nres+1)=0
 
    allocate(crd(3*natom), stat=astat)
    if (astat/=0) stop "***crd allocation error***"
+   crd(:)=0
 
    allocate(chg(natom), stat=astat)
    if (astat/=0) stop "***chg allocation error***"
+   chg(:)=0
 
    ! open the parm file and load the necessary stuff
    call amopen(10,prmtop,'O','F','R')
@@ -276,12 +282,19 @@
       ! debug info
       allocate(i6d(i6dmax), stat=astat)
       if (astat /= 0) stop "***memory allocation error***"
+      i6d(:)=0
 
       allocate(ed(edmax), stat=astat)
       if (astat /= 0) stop "***memory allocation error***"
+      ed(:)=0
 
       allocate(id(idmax),jd(idmax),kd(idmax),ld(idmax),ic(idmax), stat=astat)
       if (astat /= 0) stop "***memory allocation error***"
+      id(:)=0
+      jd(:)=0
+      kd(:)=0
+      ld(:)=0
+      ic(:)=0
       
       read(nf,rfmt) (ed(i), i=1,natom)      ! amass
       read(nf,ifmt) (i6d(i), i=1,natom)     ! iac
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/amd.F90 ./AmberTools/src/sander/amd.F90
--- AmberTools/src/sander/amd.F90	2022-08-29 08:36:19.000000000 +0900
+++ ./AmberTools/src/sander/amd.F90	2022-05-05 14:56:48.000000000 +0900
@@ -67,6 +67,7 @@
 
   allocate(amd_weights_and_energy(6), stat = alloc_failed)
   REQUIRE(alloc_failed==0)
+  amd_weights_and_energy(:)=0
 
   fwgt = 1.0
   fwgtd = 1.0
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/amoeba_adjust.F90 ./AmberTools/src/sander/amoeba_adjust.F90
--- AmberTools/src/sander/amoeba_adjust.F90	2022-08-29 08:36:17.000000000 +0900
+++ ./AmberTools/src/sander/amoeba_adjust.F90	2022-05-05 14:56:48.000000000 +0900
@@ -61,6 +61,7 @@
    if(.not.master) then
       allocate(adjust_list(3,num_adjust_list),stat=ierr)
       REQUIRE(ierr==0)
+      adjust_list(:,:)=0
    end if
 
    call mpi_bcast(adjust_list,3*num_adjust_list,MPI_INTEGER,0,commsander,ierr)
@@ -73,6 +74,7 @@
    if(.not.master) then
       allocate(dipole_dipole_tensor(6,num_adjust_list),stat=ierr)
       REQUIRE(ierr==0)
+      dipole_dipole_tensor(:,:)=0
    end if
 end subroutine AM_ADJUST_bcast
 #endif
@@ -93,6 +95,7 @@
   !allocate
   allocate(adjust_list(3,num_adjust_list),stat=ier)
   REQUIRE(ier==0)
+  adjust_list(:,:)=0
   dim1=3
   call AMOEBA_read_list_data('AMOEBA_ADJUST_',nf,dim1,num_adjust_list, &
                               adjust_list)
@@ -112,6 +115,7 @@
   ! allocate the dipole_dipole_tensors
   allocate(dipole_dipole_tensor(6,num_adjust_list),stat=ier)
   REQUIRE(ier==0)
+  dipole_dipole_tensor(:,:)=0
   AM_ADJUST_readparm = 1
   do_flag = ibset(do_flag,VALID_BIT)
 end function AM_ADJUST_readparm
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/amopen.F90 ./AmberTools/src/sander/amopen.F90
--- AmberTools/src/sander/amopen.F90	2022-08-29 08:36:26.000000000 +0900
+++ ./AmberTools/src/sander/amopen.F90	2022-05-05 14:56:48.000000000 +0900
@@ -10,6 +10,12 @@
    !  facc is used for file appending
 
    implicit none
+#ifdef MPI
+   include 'mpif.h'
+   integer, save     :: remd_comm
+   integer, save     :: remd_rank
+   integer :: ierror       ! Error code
+#endif
 
    !     INPUT:
 
@@ -90,6 +96,13 @@
       end if
       call mexit(6, 1)
    end if
+#ifdef MPI
+   call mpi_comm_rank(remd_comm, remd_rank, ierror)
+   if ( remd_rank .eq. 0 ) then
+    ! if (pos /= "APPEND") rewind(lun)
+   endif
+#else
    if (pos /= "APPEND") rewind(lun)
+#endif
    return
 end subroutine amopen 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/constante.F90 ./AmberTools/src/sander/constante.F90
--- AmberTools/src/sander/constante.F90	2022-08-29 08:36:17.000000000 +0900
+++ ./AmberTools/src/sander/constante.F90	2022-05-05 14:56:48.000000000 +0900
@@ -107,6 +107,8 @@
      write(6,'(a)') 'Error in constant E allocation!'
      call mexit(6, 1)
    end if
+   chrgdat_e(:)=0
+
 
 end subroutine cnsteallocate
 
@@ -378,6 +380,7 @@
    allocate(frac_pop(0:trescnt-1, 0:maxstates-1), stat=ierror)
 
    REQUIRE( ierror == 0 )
+   frac_pop(:,:)=0
 
    return
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/constantph.F90 ./AmberTools/src/sander/constantph.F90
--- AmberTools/src/sander/constantph.F90	2022-08-29 08:36:24.000000000 +0900
+++ ./AmberTools/src/sander/constantph.F90	2022-05-05 14:56:48.000000000 +0900
@@ -130,6 +130,18 @@
      write(6,'(a)') 'Error in constant pH allocation!'
      call mexit(6, 1)
    end if
+   chrgdat(:)=0
+   !stateinf(:)=0
+   resname(:)=''
+   statene(:)=0
+   pka_corr(:)=0
+   eo_corr(:)=0
+   hindex(:)=0
+   tpair(:)=0
+   resstate(:)=0
+   iselres(:)=0
+   protcnt(:)=0
+   eleccnt(:)=0
 
 end subroutine cnstphallocate
 
@@ -454,6 +466,7 @@
    allocate(frac_pop(0:trescnt-1, 0:maxstates-1), stat=ierror)
 
    REQUIRE( ierror == 0 )
+   frac_pop(:,:)=0
 
    return
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/egb.F90 ./AmberTools/src/sander/egb.F90
--- AmberTools/src/sander/egb.F90	2022-08-29 08:36:22.000000000 +0900
+++ ./AmberTools/src/sander/egb.F90	2022-05-05 14:56:48.000000000 +0900
@@ -46,12 +46,51 @@
              rbornlong(natom*ncopy), &
              rix(natom*ncopy),iridx(natom*ncopy),jridx(natom*ncopy), &
              vtemp7(ncopy),stat = ier )
+     r2x(:)=0
+     rjx(:)=0
+     vectmp1(:)=0
+     vectmp2(:)=0
+     vectmp3(:)=0
+     vectmp4(:)=0
+     vectmp5(:)=0
+     sumdeijda(:)=0
+     psi(:)=0
+     temp_jj(:)=0
+     skipv(:)=.FALSE.
+     k_vals(:)=0
+     j_vals(:)=0
+     neckidx(:)=0
+     scalefac(:)=0
+     spreadfrc(:)=.FALSE.
+     vthi2(:)=0
+     longskipv(:)=.FALSE.
+     nradii(:)=0
+     lesscalefac(:)=0
+     rbornlong(:)=0
+     rix(:)=0
+     iridx(:)=0
+     jridx(:)=0
+     vtemp7(:)=0
 #else
    allocate( r2x(natom), rjx(natom), vectmp1(natom), vectmp2(natom),   &
              vectmp3(natom), vectmp4(natom), vectmp5(natom), &
              sumdeijda(natom), psi(natom), temp_jj(natom),  &
              skipv(0:natom),k_vals(natom),j_vals(natom), neckidx(natom), &
              stat = ier )
+     r2x(:)=0
+     rjx(:)=0
+     vectmp1(:)=0
+     vectmp2(:)=0
+     vectmp3(:)=0
+     vectmp4(:)=0
+     vectmp5(:)=0
+     sumdeijda(:)=0
+     psi(:)=0
+     temp_jj(:)=0
+     skipv(:)=.FALSE.
+     k_vals(:)=0
+     j_vals(:)=0
+     neckidx(:)=0
 #endif
 
    REQUIRE( ier == 0 )
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/qm2_extern_mrcc_module.F90 ./AmberTools/src/sander/qm2_extern_mrcc_module.F90
--- AmberTools/src/sander/qm2_extern_mrcc_module.F90	2022-08-29 08:36:24.000000000 +0900
+++ ./AmberTools/src/sander/qm2_extern_mrcc_module.F90	2022-05-05 14:56:48.000000000 +0900
@@ -285,7 +285,7 @@
     if(mrcc_nml%nprintlog.ne.0) then
        nprintlogstep=nprintlogstep+1
        if(nprintlogstep.eq.mrcc_nml%nprintlog) then
-          write(inttochr,'(i256)') nstep
+          write(inttochr,'(i255)') nstep
           stat=system('cp '//trim(subdir)//logfile//' '&
                      //trim(subdir)//'step.'//trim(adjustl(inttochr))&
                      //'.'//logfile)
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/remd.F90 ./AmberTools/src/sander/remd.F90
--- AmberTools/src/sander/remd.F90	2022-08-29 08:36:17.000000000 +0900
+++ ./AmberTools/src/sander/remd.F90	2022-05-05 14:56:48.000000000 +0900
@@ -3517,9 +3517,14 @@
          end do
       end if
 
-      if (master .and. .not. remd_master) &
-         call mpi_gather(o_repnum, 1, mpi_integer, texchsuccess, 1, &
-                         MPI_INTEGER, 0, remd_comm, ierror)
+!      if (master .and. .not. remd_master) &
+      if (rem == 3) then
+        call mpi_gather(o_repnum, 1, mpi_integer, texchsuccess, 1, &
+                        MPI_INTEGER, 0, remd_comm, ierror)
+      else if (master .and. .not. remd_master) then
+        call mpi_gather(o_repnum, 1, mpi_integer, texchsuccess, 1, &
+                        MPI_INTEGER, 0, remd_comm, ierror)
+      end if
 
       if (rem < 0) then
          ! Make sure everyone in our communicator trades their neighbor replica
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/runmd.F90 ./AmberTools/src/sander/runmd.F90
--- AmberTools/src/sander/runmd.F90	2022-08-29 08:36:17.000000000 +0900
+++ ./AmberTools/src/sander/runmd.F90	2022-05-05 14:56:49.000000000 +0900
@@ -497,13 +497,17 @@
   if (icfe /= 0) then
     allocate(frcti(nr3 + 3*extra_atoms), stat=ierr)
     REQUIRE(ierr == 0)
+    frcti(:)=0
   end if
 #endif
 
   ! If ntwprt.NE.0, only print the atoms up to this value
   nrx = nr3
   if (ntwprt > 0) nrx = ntwprt*3
-  if (.not. allocated(f_or)) allocate(f_or(nr3))
+  if (.not. allocated(f_or)) then
+    allocate(f_or(nr3))
+    f_or(:)=0
+  endif
   if (abfqmmm_param%abfqmmm == 1) then
 #ifdef MPI
     call xdist(v, xx(lfrctmp), natom)
@@ -4212,6 +4216,7 @@
         if (.not. rstack_ok) then
           deallocate(r_stack)
           allocate(r_stack(1:lastrst), stat=alloc_ier)
+          r_stack(:)=0
           call reassign_rstack(routine)
         end if
         REQUIRE(rstack_ok)
@@ -4247,6 +4252,7 @@
         if (.not. rstack_ok) then
           deallocate(r_stack)
           allocate(r_stack(1:lastrst), stat=alloc_ier)
+          r_stack(:)=0
           call reassign_rstack(routine)
         endif
         REQUIRE(rstack_ok)
@@ -4319,6 +4325,7 @@
         if (.not. rstack_ok) then
           deallocate(r_stack)
           allocate(r_stack(1:lastrst), stat=alloc_ier)
+          r_stack(:)=0
           call reassign_rstack(routine)
         end if
         REQUIRE(rstack_ok)
@@ -4348,6 +4355,7 @@
         if (.not. rstack_ok) then
           deallocate(r_stack)
           allocate(r_stack(1:lastrst), stat=alloc_ier)
+          r_stack(:)=0
           call reassign_rstack(routine)
         end if
         REQUIRE(rstack_ok)
@@ -4436,7 +4444,9 @@
 !------------------------------------------------------------------------------
     !    General printed output:  {{{
     if (lout) then
+#ifndef __FUJITSU
       if (facc .ne. 'A') rewind(7)
+#endif
 
       ! Conserved quantity for Nose'-Hoover based thermostats.
       if (ipimd  == 0 .and. ntt > 4 .and. ntt <= 8) then
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/sander.F90 ./AmberTools/src/sander/sander.F90
--- AmberTools/src/sander/sander.F90	2022-08-29 08:36:24.000000000 +0900
+++ ./AmberTools/src/sander/sander.F90	2022-05-05 14:56:49.000000000 +0900
@@ -368,7 +368,10 @@
         ! Allocate all global arrays
         allocate( x(lastr), ix(lasti), ipairs(lastpr), ih(lasth), stat=ier)
         REQUIRE(ier == 0)
-        ix(1:lasti) = 0
+        x(:)=0
+        ix(:) = 0
+        ipairs(:)=0 
+        !ih(:)=0
 
         ! This sets up pointer arrays in MEMORY_MODULE to match array-offsets
         ! into the shared X, IX, and IH arrays. Eventually, LOCMEM code should
@@ -551,6 +554,16 @@
         write(6,*) 'Error allocating PUPIL interface memory.'
         call mexit(6, 1)
       end if
+      qcell   (:)=0
+      atmqmdomains(:)=0
+      pupqlist(:)=0
+      pupatm  (:)=0
+      pupchg  (:)=0
+      qfpup   (:)=0
+      qcdata  (:)=0
+      keyMM   (:)=0
+      pupres  (:)=0
+      keyres  (:)=0
 
       ! Initialise the "atomic numbers" and "quantum forces" vectors
       pupparticles = 0
@@ -869,6 +882,7 @@
         ! qm2_struct%scf_mchg will be deallocated in deallocate qmmm,
         ! so the allocation must have been successful here.
         REQUIRE(ier == 0)
+        qm2_struct%scf_mchg(:)=0
 
         ! We can also allocate ewald_memory
         if (qmmm_nml%qm_ewald > 0) then
@@ -881,6 +895,7 @@
 
         ! Again, qmmm_struct%dxyzqm will be deallocated in deallocate qmmm
         REQUIRE(ier == 0)
+        qmmm_struct%dxyzqm(:,:)=0
       else if(abfqmmm_param%abfqmmm == 1) then
         call abfqmmm_set_parameters(numbnd, nbonh, nbona, ntheth, ntheta, &
                                     nphih, nphia, ix(iibh), ix(ijbh), &
@@ -996,19 +1011,26 @@
         if (.not. master) then
           allocate(abfqmmm_param%x(3*natom), stat=ier)
           REQUIRE(ier == 0)
+          abfqmmm_param%x(:)=0
           allocate(abfqmmm_param%id(natom), stat=ier)
           REQUIRE(ier == 0)
+          abfqmmm_param%id(:)=0
           allocate(abfqmmm_param%mass(natom), stat=ier)
           REQUIRE(ier == 0)
+          abfqmmm_param%mass(:)=0
         end if
         allocate(abfqmmm_param%v(3*natom+iscale), stat=ier)
         REQUIRE(ier == 0)
+        abfqmmm_param%v(:)=0
         allocate(abfqmmm_param%f(3*natom+iscale), stat=ier)
         REQUIRE(ier == 0)
+        abfqmmm_param%f(:)=0
         allocate(abfqmmm_param%f1(3*natom+iscale), stat=ier)
         REQUIRE(ier == 0)
+        abfqmmm_param%f1(:)=0
         allocate(abfqmmm_param%f2(3*natom+iscale), stat=ier)
         REQUIRE(ier == 0)
+        abfqmmm_param%f2(:)=0
       end if
       call mpi_bcast(abfqmmm_param%x, 3*natom, mpi_double_precision, &
                      0, commsander, ier)
@@ -1042,15 +1064,19 @@
 
       allocate(x(1:lastr), stat=ier)
       REQUIRE(ier == 0)
+      x(:)=0
 
       allocate(ix(1:lasti), stat=ier)
       REQUIRE(ier == 0)
+      ix(:)=0
 
       allocate(ipairs(1:lastpr), stat=ier)
       REQUIRE(ier == 0)
+      ipairs(:)=0
 
       allocate(ih(1:lasth), stat=ier)
       REQUIRE(ier == 0)
+      !ih=0
 
       ! AWG Set up pointer arrays also on non-master nodes
       call memory_init()
@@ -1221,6 +1247,7 @@
 
         ! qmmm_struct%dxyzqm will be deallocated in deallocate qmmm
         REQUIRE(ier == 0)
+        qmmm_struct%dxyzqm(:,:)=0
       end if
     end if
     ! End of QM/MM MPI setup
@@ -1399,12 +1426,16 @@
       if (abfqmmm_param%qmstep == 1 .and. abfqmmm_param%system == 1) then
         allocate(abfqmmm_param%v(3*natom+iscale), stat=ier)
         REQUIRE(ier == 0)
+        abfqmmm_param%v(:)=0
         allocate(abfqmmm_param%f(3*natom+iscale), stat=ier)
         REQUIRE(ier == 0)
+        abfqmmm_param%f(:)=0
         allocate(abfqmmm_param%f1(3*natom+iscale), stat=ier)
         REQUIRE(ier == 0)
+        abfqmmm_param%f1(:)=0
         allocate(abfqmmm_param%f2(3*natom+iscale), stat=ier)
         REQUIRE(ier == 0)
+        abfqmmm_param%f2(:)=0
       end if
     end if
 
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/sebomd_module.F90 ./AmberTools/src/sander/sebomd_module.F90
--- AmberTools/src/sander/sebomd_module.F90	2022-08-29 08:36:18.000000000 +0900
+++ ./AmberTools/src/sander/sebomd_module.F90	2022-05-05 14:56:49.000000000 +0900
@@ -121,37 +121,6 @@
     implicit none
     integer :: stat
 
-    character(10) :: hamiltonian
-    character(10) :: modif
-    integer :: method
-    integer :: ncore
-    _REAL_ :: dbuff1
-    _REAL_ :: dbuff2
-    character(256) :: charge_out
-    character(256) :: bond_order_out
-    _REAL_ :: lambda
-    _REAL_ :: peptk
-    _REAL_ :: dpmax
-    _REAL_ :: bocut
-    integer :: charge
-    integer :: longrange
-    integer :: fullscf
-    integer :: ntwc
-    integer :: ntwb
-    integer :: chtype
-    integer :: chewald
-    integer :: screen
-    integer :: guess
-    integer :: pdump
-    integer :: ipolyn
-    integer :: nresidue
-    integer :: ntwh
-    integer :: peptcorr
-    integer :: iprec
-    integer :: debugmsg
-    integer :: debugforces
-    integer :: diag_routine
-
     namelist /sebomd/ hamiltonian, &
                       modif, &
                       ncore, &
@@ -182,6 +151,37 @@
                       diag_routine, &
                       dpmax, &
                       bocut
+   
+    character(10) :: hamiltonian
+    character(10) :: modif
+    integer :: method
+    integer :: ncore
+    _REAL_ :: dbuff1
+    _REAL_ :: dbuff2
+    character(256) :: charge_out
+    character(256) :: bond_order_out
+    _REAL_ :: lambda
+    _REAL_ :: peptk
+    _REAL_ :: dpmax
+    _REAL_ :: bocut
+    integer :: charge
+    integer :: longrange
+    integer :: fullscf
+    integer :: ntwc
+    integer :: ntwb
+    integer :: chtype
+    integer :: chewald
+    integer :: screen
+    integer :: guess
+    integer :: pdump
+    integer :: ipolyn
+    integer :: nresidue
+    integer :: ntwh
+    integer :: peptcorr
+    integer :: iprec
+    integer :: debugmsg
+    integer :: debugforces
+    integer :: diag_routine
 
     hamiltonian =   sebomd_obj%hamiltonian
     modif =   sebomd_obj%modif
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sander/softcore.F90 ./AmberTools/src/sander/softcore.F90
--- AmberTools/src/sander/softcore.F90	2022-08-29 08:36:24.000000000 +0900
+++ ./AmberTools/src/sander/softcore.F90	2022-05-05 14:56:49.000000000 +0900
@@ -15,7 +15,11 @@
 
 #include "parallel.h"
 #ifdef MPI
+#ifndef __FUJITSU
    include 'mpif.h'
+#else
+   include 'mpif-config.h'
+#endif
 
   integer ist(MPI_STATUS_SIZE), partner
 #endif
@@ -70,6 +74,9 @@
 #ifdef MPI
     subroutine setup_sc(natom,nres,igraph,isymbl,ipres, &
          lbres,crd, ntypes, clambda, nstlim)
+#ifdef __FUJITSU
+      include 'mpif.h'
+#endif
 
       integer, intent(in) :: natom, nres, ipres(*),ntypes, nstlim
       character(len=4), intent(in) :: igraph(*), isymbl(*), lbres(*)
@@ -257,6 +264,9 @@
 
 #ifdef MPI
     subroutine sc_change_clambda(clambda)
+#ifdef __FUJITSU
+      include 'mpif.h'
+#endif
       
       _REAL_,intent(in) :: clambda
 
@@ -381,6 +391,9 @@
 
 #ifdef MPI
     subroutine sc_check_and_adjust_crd(natom, crd)
+#ifdef __FUJITSU
+      include 'mpif.h'
+#endif
 
       ! Input variables
       integer, intent(in) :: natom
@@ -444,6 +457,9 @@
 !===================================================================================================
 
     subroutine sc_check_perturbed_molecules(nummols, molsiz)
+#ifdef __FUJITSU
+      include 'mpif.h'
+#endif
 
       integer nummols,molsiz(*)
 
@@ -573,7 +589,9 @@
       _REAL_ xmol_partner, ymol_partner, zmol_partner,BellyC_partner(3)
       dimension igrp(*)
 #  include "parallel.h"
+!#ifndef __FUJITSU
   include 'mpif.h'
+!#endif
 
       partner = ieor(masterrank,1)
       !Determine box-center difference:
@@ -699,6 +717,9 @@
     subroutine sc_pscale(x,amass,nummols,molsiz,oldrecip,ucell)
       ! This subroutine is copied from ew_pscale, but includes master-to-master
       ! communication to get average center of masses for perturbed molecules
+#ifdef __FUJITSU
+      include 'mpif.h'
+#endif
 
       _REAL_ x(3,*),amass(*)
       _REAL_ oldrecip(3,3),ucell(3,3)
@@ -782,6 +803,9 @@
 !===================================================================================================
 
     subroutine mix_temp_scaling(factor, v)
+#ifdef __FUJITSU
+      include 'mpif.h'
+#endif
 
       _REAL_ factor, v(*), factor_sc
       _REAL_ factor_partner
@@ -814,6 +838,9 @@
 !===================================================================================================
 
     subroutine sc_mix_sum(sum)
+#ifdef __FUJITSU
+      include 'mpif.h'
+#endif
 
       _REAL_ sum, sum_partner
 
@@ -917,6 +944,9 @@
 
 #ifdef MPI
     subroutine sc_mix_position(vcmx,vcmy,vcmz,clambda)
+#ifdef __FUJITSU
+      include 'mpif.h'
+#endif
 
       _REAL_ vcmx,vcmy,vcmz,clambda
       _REAL_ vcm(3), vcm_partner(3)
@@ -948,6 +978,9 @@
 
 #ifdef MPI
     subroutine sc_mix_velocities(v, nr3)
+#ifdef __FUJITSU
+      include 'mpif.h'
+#endif
 
       _REAL_ v(nr3),vcopy(nr3+3*extra_atoms)
       integer nr3, i
@@ -986,6 +1019,9 @@
 
 #ifdef MPI
     subroutine sc_sync_x(x,nr3)
+#ifdef __FUJITSU
+      include 'mpif.h'
+#endif
       
       _REAL_ x(nr3), xpartner(nr3+3*extra_atoms)
       integer nr3, i
@@ -1012,6 +1048,9 @@
 
 #ifdef MPI
     subroutine sc_compare(x,nr3, tag)
+#ifdef __FUJITSU
+      include 'mpif.h'
+#endif
       
       _REAL_ x(nr3), xpartner(nr3+3*extra_atoms)
       integer nr3, i
@@ -1168,6 +1207,9 @@
 
 #ifdef MPI
     subroutine calc_softcore_ekin(amass,v,vold,istart,iend)
+#ifdef __FUJITSU
+      include 'mpif.h'
+#endif
 
       integer istart,iend
       _REAL_ amass(*), v(*), vold(*), sc_ekin
@@ -1389,7 +1431,9 @@
 #  include "ew_cntrl.h"
 #  include "extra.h"
 #  include "parallel.h"
+!#ifndef __FUJITSU
    include 'mpif.h'
+!#endif
 
    nsum(:) = 0
    sum_val(:) = 0.d0
diff -ru -x Changes -x MANIFEST -x '*.yml' -x '*.json' -x README -x 'Makefile.*' -x '*.pm' -x '*.t' -x '*.o' -x '*.save' -x xblas -x additional_libs AmberTools/src/sebomd/se_etimer.F ./AmberTools/src/sebomd/se_etimer.F
--- AmberTools/src/sebomd/se_etimer.F	2022-08-29 08:39:01.000000000 +0900
+++ ./AmberTools/src/sebomd/se_etimer.F	2022-05-05 14:56:49.000000000 +0900
@@ -20,13 +20,15 @@
 #else
 #  ifdef __PGI
       call cpu_time(tnow)
-#  else
-#     if (__GNUC__ == 4 && __GNUC_MINOR__ <= 1)
+#elif __FUJITSU
+      call cpu_time(tnow)
+#else
+#if (__GNUC__ == 4 && __GNUC_MINOR__ <= 1)
       tnow = second()
-#     else
+#else
       tnow = 0.01*mclock()
-#     endif
-#  endif
+#endif
+#endif
 #endif
       if(first)then
          t0 = tnow
diff -uN AmberTools/src/quick/src/blas/ilaslc.f AmberTools/src/quick/src/blas/ilaslc.f
--- AmberTools/src/quick/src/blas/ilaslc.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/ilaslc.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,118 @@
+*> \brief \b ILASLC scans a matrix for its last non-zero column.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download ILASLC + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ilaslc.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ilaslc.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ilaslc.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       INTEGER FUNCTION ILASLC( M, N, A, LDA )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            M, N, LDA
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> ILASLC scans A for its last non-zero column.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix A.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix A.
+*> \endverbatim
+*>
+*> \param[in] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          The m by n matrix A.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A. LDA >= max(1,M).
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date June 2017
+*
+*> \ingroup realOTHERauxiliary
+*
+*  =====================================================================
+      INTEGER FUNCTION ILASLC( M, N, A, LDA )
+*
+*  -- LAPACK auxiliary routine (version 3.7.1) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     June 2017
+*
+*     .. Scalar Arguments ..
+      INTEGER            M, N, LDA
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL             ZERO
+      PARAMETER ( ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER I
+*     ..
+*     .. Executable Statements ..
+*
+*     Quick test for the common case where one corner is non-zero.
+      IF( N.EQ.0 ) THEN
+         ILASLC = N
+      ELSE IF( A(1, N).NE.ZERO .OR. A(M, N).NE.ZERO ) THEN
+         ILASLC = N
+      ELSE
+*     Now scan each column from the end, returning with the first non-zero.
+         DO ILASLC = N, 1, -1
+            DO I = 1, M
+               IF( A(I, ILASLC).NE.ZERO ) RETURN
+            END DO
+         END DO
+      END IF
+      RETURN
+      END
diff -uN AmberTools/src/quick/src/blas/ilaslr.f AmberTools/src/quick/src/blas/ilaslr.f
--- AmberTools/src/quick/src/blas/ilaslr.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/ilaslr.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,121 @@
+*> \brief \b ILASLR scans a matrix for its last non-zero row.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download ILASLR + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ilaslr.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ilaslr.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ilaslr.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       INTEGER FUNCTION ILASLR( M, N, A, LDA )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            M, N, LDA
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> ILASLR scans A for its last non-zero row.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix A.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix A.
+*> \endverbatim
+*>
+*> \param[in] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          The m by n matrix A.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A. LDA >= max(1,M).
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERauxiliary
+*
+*  =====================================================================
+      INTEGER FUNCTION ILASLR( M, N, A, LDA )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      INTEGER            M, N, LDA
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL             ZERO
+      PARAMETER ( ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER I, J
+*     ..
+*     .. Executable Statements ..
+*
+*     Quick test for the common case where one corner is non-zero.
+      IF( M.EQ.0 ) THEN
+         ILASLR = M
+      ELSEIF( A(M, 1).NE.ZERO .OR. A(M, N).NE.ZERO ) THEN
+         ILASLR = M
+      ELSE
+*     Scan up each column tracking the last zero row seen.
+         ILASLR = 0
+         DO J = 1, N
+            I=M
+            DO WHILE((A(MAX(I,1),J).EQ.ZERO).AND.(I.GE.1))
+               I=I-1
+            ENDDO
+            ILASLR = MAX( ILASLR, I )
+         END DO
+      END IF
+      RETURN
+      END
diff -uN AmberTools/src/quick/src/blas/scombssq.f AmberTools/src/quick/src/blas/scombssq.f
--- AmberTools/src/quick/src/blas/scombssq.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/scombssq.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,94 @@
+*> \brief \b SCOMBSSQ adds two scaled sum of squares quantities
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SCOMBSSQ( V1, V2 )
+*
+*       .. Array Arguments ..
+*       REAL               V1( 2 ), V2( 2 )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SCOMBSSQ adds two scaled sum of squares quantities, V1 := V1 + V2.
+*> That is,
+*>
+*>    V1_scale**2 * V1_sumsq := V1_scale**2 * V1_sumsq
+*>                            + V2_scale**2 * V2_sumsq
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in,out] V1
+*> \verbatim
+*>          V1 is REAL array, dimension (2).
+*>          The first scaled sum.
+*>          V1(1) = V1_scale, V1(2) = V1_sumsq.
+*> \endverbatim
+*>
+*> \param[in] V2
+*> \verbatim
+*>          V2 is REAL array, dimension (2).
+*>          The second scaled sum.
+*>          V2(1) = V2_scale, V2(2) = V2_sumsq.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date November 2018
+*
+*> \ingroup OTHERauxiliary
+*
+*  =====================================================================
+      SUBROUTINE SCOMBSSQ( V1, V2 )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     November 2018
+*
+*     .. Array Arguments ..
+      REAL               V1( 2 ), V2( 2 )
+*     ..
+*
+* =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO
+      PARAMETER          ( ZERO = 0.0D+0 )
+*     ..
+*     .. Executable Statements ..
+*
+      IF( V1( 1 ).GE.V2( 1 ) ) THEN
+         IF( V1( 1 ).NE.ZERO ) THEN
+            V1( 2 ) = V1( 2 ) + ( V2( 1 ) / V1( 1 ) )**2 * V2( 2 )
+         ELSE
+            V1( 2 ) = V1( 2 ) + V2( 2 )
+         END IF
+      ELSE
+         V1( 2 ) = V2( 2 ) + ( V1( 1 ) / V2( 1 ) )**2 * V1( 2 )
+         V1( 1 ) = V2( 1 )
+      END IF
+      RETURN
+*
+*     End of SCOMBSSQ
+*
+      END
diff -uN AmberTools/src/quick/src/blas/sisnan.f AmberTools/src/quick/src/blas/sisnan.f
--- AmberTools/src/quick/src/blas/sisnan.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/sisnan.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,80 @@
+*> \brief \b SISNAN tests input for NaN.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SISNAN + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sisnan.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sisnan.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sisnan.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       LOGICAL FUNCTION SISNAN( SIN )
+*
+*       .. Scalar Arguments ..
+*       REAL, INTENT(IN) :: SIN
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SISNAN returns .TRUE. if its argument is NaN, and .FALSE.
+*> otherwise.  To be replaced by the Fortran 2003 intrinsic in the
+*> future.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] SIN
+*> \verbatim
+*>          SIN is REAL
+*>          Input to test for NaN.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date June 2017
+*
+*> \ingroup OTHERauxiliary
+*
+*  =====================================================================
+      LOGICAL FUNCTION SISNAN( SIN )
+*
+*  -- LAPACK auxiliary routine (version 3.7.1) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     June 2017
+*
+*     .. Scalar Arguments ..
+      REAL, INTENT(IN) :: SIN
+*     ..
+*
+*  =====================================================================
+*
+*  .. External Functions ..
+      LOGICAL SLAISNAN
+      EXTERNAL SLAISNAN
+*  ..
+*  .. Executable Statements ..
+      SISNAN = SLAISNAN(SIN,SIN)
+      RETURN
+      END
diff -uN AmberTools/src/quick/src/blas/slacpy.f AmberTools/src/quick/src/blas/slacpy.f
--- AmberTools/src/quick/src/blas/slacpy.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slacpy.f	2022-08-30 19:17:30.000000000 +0900
@@ -0,0 +1,156 @@
+*> \brief \b SLACPY copies all or part of one two-dimensional array to another.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLACPY + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slacpy.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slacpy.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slacpy.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLACPY( UPLO, M, N, A, LDA, B, LDB )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          UPLO
+*       INTEGER            LDA, LDB, M, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), B( LDB, * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLACPY copies all or part of a two-dimensional matrix A to another
+*> matrix B.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] UPLO
+*> \verbatim
+*>          UPLO is CHARACTER*1
+*>          Specifies the part of the matrix A to be copied to B.
+*>          = 'U':      Upper triangular part
+*>          = 'L':      Lower triangular part
+*>          Otherwise:  All of the matrix A
+*> \endverbatim
+*>
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix A.  M >= 0.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix A.  N >= 0.
+*> \endverbatim
+*>
+*> \param[in] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          The m by n matrix A.  If UPLO = 'U', only the upper triangle
+*>          or trapezoid is accessed; if UPLO = 'L', only the lower
+*>          triangle or trapezoid is accessed.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A.  LDA >= max(1,M).
+*> \endverbatim
+*>
+*> \param[out] B
+*> \verbatim
+*>          B is REAL array, dimension (LDB,N)
+*>          On exit, B = A in the locations specified by UPLO.
+*> \endverbatim
+*>
+*> \param[in] LDB
+*> \verbatim
+*>          LDB is INTEGER
+*>          The leading dimension of the array B.  LDB >= max(1,M).
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup OTHERauxiliary
+*
+*  =====================================================================
+      SUBROUTINE SLACPY( UPLO, M, N, A, LDA, B, LDB )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          UPLO
+      INTEGER            LDA, LDB, M, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), B( LDB, * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Local Scalars ..
+      INTEGER            I, J
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      EXTERNAL           LSAME
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MIN
+*     ..
+*     .. Executable Statements ..
+*
+      IF( LSAME( UPLO, 'U' ) ) THEN
+         DO 20 J = 1, N
+            DO 10 I = 1, MIN( J, M )
+               B( I, J ) = A( I, J )
+   10       CONTINUE
+   20    CONTINUE
+      ELSE IF( LSAME( UPLO, 'L' ) ) THEN
+         DO 40 J = 1, N
+            DO 30 I = J, M
+               B( I, J ) = A( I, J )
+   30       CONTINUE
+   40    CONTINUE
+      ELSE
+         DO 60 J = 1, N
+            DO 50 I = 1, M
+               B( I, J ) = A( I, J )
+   50       CONTINUE
+   60    CONTINUE
+      END IF
+      RETURN
+*
+*     End of SLACPY
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slae2.f AmberTools/src/quick/src/blas/slae2.f
--- AmberTools/src/quick/src/blas/slae2.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slae2.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,185 @@
+*> \brief \b SLAE2 computes the eigenvalues of a 2-by-2 symmetric matrix.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLAE2 + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slae2.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slae2.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slae2.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLAE2( A, B, C, RT1, RT2 )
+*
+*       .. Scalar Arguments ..
+*       REAL               A, B, C, RT1, RT2
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix
+*>    [  A   B  ]
+*>    [  B   C  ].
+*> On return, RT1 is the eigenvalue of larger absolute value, and RT2
+*> is the eigenvalue of smaller absolute value.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] A
+*> \verbatim
+*>          A is REAL
+*>          The (1,1) element of the 2-by-2 matrix.
+*> \endverbatim
+*>
+*> \param[in] B
+*> \verbatim
+*>          B is REAL
+*>          The (1,2) and (2,1) elements of the 2-by-2 matrix.
+*> \endverbatim
+*>
+*> \param[in] C
+*> \verbatim
+*>          C is REAL
+*>          The (2,2) element of the 2-by-2 matrix.
+*> \endverbatim
+*>
+*> \param[out] RT1
+*> \verbatim
+*>          RT1 is REAL
+*>          The eigenvalue of larger absolute value.
+*> \endverbatim
+*>
+*> \param[out] RT2
+*> \verbatim
+*>          RT2 is REAL
+*>          The eigenvalue of smaller absolute value.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup OTHERauxiliary
+*
+*> \par Further Details:
+*  =====================
+*>
+*> \verbatim
+*>
+*>  RT1 is accurate to a few ulps barring over/underflow.
+*>
+*>  RT2 may be inaccurate if there is massive cancellation in the
+*>  determinant A*C-B*B; higher precision or correctly rounded or
+*>  correctly truncated arithmetic would be needed to compute RT2
+*>  accurately in all cases.
+*>
+*>  Overflow is possible only if RT1 is within a factor of 5 of overflow.
+*>  Underflow is harmless if the input data is 0 or exceeds
+*>     underflow_threshold / macheps.
+*> \endverbatim
+*>
+*  =====================================================================
+      SUBROUTINE SLAE2( A, B, C, RT1, RT2 )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      REAL               A, B, C, RT1, RT2
+*     ..
+*
+* =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE
+      PARAMETER          ( ONE = 1.0E0 )
+      REAL               TWO
+      PARAMETER          ( TWO = 2.0E0 )
+      REAL               ZERO
+      PARAMETER          ( ZERO = 0.0E0 )
+      REAL               HALF
+      PARAMETER          ( HALF = 0.5E0 )
+*     ..
+*     .. Local Scalars ..
+      REAL               AB, ACMN, ACMX, ADF, DF, RT, SM, TB
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, SQRT
+*     ..
+*     .. Executable Statements ..
+*
+*     Compute the eigenvalues
+*
+      SM = A + C
+      DF = A - C
+      ADF = ABS( DF )
+      TB = B + B
+      AB = ABS( TB )
+      IF( ABS( A ).GT.ABS( C ) ) THEN
+         ACMX = A
+         ACMN = C
+      ELSE
+         ACMX = C
+         ACMN = A
+      END IF
+      IF( ADF.GT.AB ) THEN
+         RT = ADF*SQRT( ONE+( AB / ADF )**2 )
+      ELSE IF( ADF.LT.AB ) THEN
+         RT = AB*SQRT( ONE+( ADF / AB )**2 )
+      ELSE
+*
+*        Includes case AB=ADF=0
+*
+         RT = AB*SQRT( TWO )
+      END IF
+      IF( SM.LT.ZERO ) THEN
+         RT1 = HALF*( SM-RT )
+*
+*        Order of execution important.
+*        To get fully accurate smaller eigenvalue,
+*        next line needs to be executed in higher precision.
+*
+         RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B
+      ELSE IF( SM.GT.ZERO ) THEN
+         RT1 = HALF*( SM+RT )
+*
+*        Order of execution important.
+*        To get fully accurate smaller eigenvalue,
+*        next line needs to be executed in higher precision.
+*
+         RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B
+      ELSE
+*
+*        Includes case RT1 = RT2 = 0
+*
+         RT1 = HALF*RT
+         RT2 = -HALF*RT
+      END IF
+      RETURN
+*
+*     End of SLAE2
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slaebz.f AmberTools/src/quick/src/blas/slaebz.f
--- AmberTools/src/quick/src/blas/slaebz.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slaebz.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,649 @@
+*> \brief \b SLAEBZ computes the number of eigenvalues of a real symmetric tridiagonal matrix which are less than or equal to a given value, and performs other tasks required by the routine sstebz.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLAEBZ + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slaebz.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slaebz.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaebz.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLAEBZ( IJOB, NITMAX, N, MMAX, MINP, NBMIN, ABSTOL,
+*                          RELTOL, PIVMIN, D, E, E2, NVAL, AB, C, MOUT,
+*                          NAB, WORK, IWORK, INFO )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            IJOB, INFO, MINP, MMAX, MOUT, N, NBMIN, NITMAX
+*       REAL               ABSTOL, PIVMIN, RELTOL
+*       ..
+*       .. Array Arguments ..
+*       INTEGER            IWORK( * ), NAB( MMAX, * ), NVAL( * )
+*       REAL               AB( MMAX, * ), C( * ), D( * ), E( * ), E2( * ),
+*      $                   WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLAEBZ contains the iteration loops which compute and use the
+*> function N(w), which is the count of eigenvalues of a symmetric
+*> tridiagonal matrix T less than or equal to its argument  w.  It
+*> performs a choice of two types of loops:
+*>
+*> IJOB=1, followed by
+*> IJOB=2: It takes as input a list of intervals and returns a list of
+*>         sufficiently small intervals whose union contains the same
+*>         eigenvalues as the union of the original intervals.
+*>         The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.
+*>         The output interval (AB(j,1),AB(j,2)] will contain
+*>         eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.
+*>
+*> IJOB=3: It performs a binary search in each input interval
+*>         (AB(j,1),AB(j,2)] for a point  w(j)  such that
+*>         N(w(j))=NVAL(j), and uses  C(j)  as the starting point of
+*>         the search.  If such a w(j) is found, then on output
+*>         AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output
+*>         (AB(j,1),AB(j,2)] will be a small interval containing the
+*>         point where N(w) jumps through NVAL(j), unless that point
+*>         lies outside the initial interval.
+*>
+*> Note that the intervals are in all cases half-open intervals,
+*> i.e., of the form  (a,b] , which includes  b  but not  a .
+*>
+*> To avoid underflow, the matrix should be scaled so that its largest
+*> element is no greater than  overflow**(1/2) * underflow**(1/4)
+*> in absolute value.  To assure the most accurate computation
+*> of small eigenvalues, the matrix should be scaled to be
+*> not much smaller than that, either.
+*>
+*> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
+*> Matrix", Report CS41, Computer Science Dept., Stanford
+*> University, July 21, 1966
+*>
+*> Note: the arguments are, in general, *not* checked for unreasonable
+*> values.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] IJOB
+*> \verbatim
+*>          IJOB is INTEGER
+*>          Specifies what is to be done:
+*>          = 1:  Compute NAB for the initial intervals.
+*>          = 2:  Perform bisection iteration to find eigenvalues of T.
+*>          = 3:  Perform bisection iteration to invert N(w), i.e.,
+*>                to find a point which has a specified number of
+*>                eigenvalues of T to its left.
+*>          Other values will cause SLAEBZ to return with INFO=-1.
+*> \endverbatim
+*>
+*> \param[in] NITMAX
+*> \verbatim
+*>          NITMAX is INTEGER
+*>          The maximum number of "levels" of bisection to be
+*>          performed, i.e., an interval of width W will not be made
+*>          smaller than 2^(-NITMAX) * W.  If not all intervals
+*>          have converged after NITMAX iterations, then INFO is set
+*>          to the number of non-converged intervals.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The dimension n of the tridiagonal matrix T.  It must be at
+*>          least 1.
+*> \endverbatim
+*>
+*> \param[in] MMAX
+*> \verbatim
+*>          MMAX is INTEGER
+*>          The maximum number of intervals.  If more than MMAX intervals
+*>          are generated, then SLAEBZ will quit with INFO=MMAX+1.
+*> \endverbatim
+*>
+*> \param[in] MINP
+*> \verbatim
+*>          MINP is INTEGER
+*>          The initial number of intervals.  It may not be greater than
+*>          MMAX.
+*> \endverbatim
+*>
+*> \param[in] NBMIN
+*> \verbatim
+*>          NBMIN is INTEGER
+*>          The smallest number of intervals that should be processed
+*>          using a vector loop.  If zero, then only the scalar loop
+*>          will be used.
+*> \endverbatim
+*>
+*> \param[in] ABSTOL
+*> \verbatim
+*>          ABSTOL is REAL
+*>          The minimum (absolute) width of an interval.  When an
+*>          interval is narrower than ABSTOL, or than RELTOL times the
+*>          larger (in magnitude) endpoint, then it is considered to be
+*>          sufficiently small, i.e., converged.  This must be at least
+*>          zero.
+*> \endverbatim
+*>
+*> \param[in] RELTOL
+*> \verbatim
+*>          RELTOL is REAL
+*>          The minimum relative width of an interval.  When an interval
+*>          is narrower than ABSTOL, or than RELTOL times the larger (in
+*>          magnitude) endpoint, then it is considered to be
+*>          sufficiently small, i.e., converged.  Note: this should
+*>          always be at least radix*machine epsilon.
+*> \endverbatim
+*>
+*> \param[in] PIVMIN
+*> \verbatim
+*>          PIVMIN is REAL
+*>          The minimum absolute value of a "pivot" in the Sturm
+*>          sequence loop.
+*>          This must be at least  max |e(j)**2|*safe_min  and at
+*>          least safe_min, where safe_min is at least
+*>          the smallest number that can divide one without overflow.
+*> \endverbatim
+*>
+*> \param[in] D
+*> \verbatim
+*>          D is REAL array, dimension (N)
+*>          The diagonal elements of the tridiagonal matrix T.
+*> \endverbatim
+*>
+*> \param[in] E
+*> \verbatim
+*>          E is REAL array, dimension (N)
+*>          The offdiagonal elements of the tridiagonal matrix T in
+*>          positions 1 through N-1.  E(N) is arbitrary.
+*> \endverbatim
+*>
+*> \param[in] E2
+*> \verbatim
+*>          E2 is REAL array, dimension (N)
+*>          The squares of the offdiagonal elements of the tridiagonal
+*>          matrix T.  E2(N) is ignored.
+*> \endverbatim
+*>
+*> \param[in,out] NVAL
+*> \verbatim
+*>          NVAL is INTEGER array, dimension (MINP)
+*>          If IJOB=1 or 2, not referenced.
+*>          If IJOB=3, the desired values of N(w).  The elements of NVAL
+*>          will be reordered to correspond with the intervals in AB.
+*>          Thus, NVAL(j) on output will not, in general be the same as
+*>          NVAL(j) on input, but it will correspond with the interval
+*>          (AB(j,1),AB(j,2)] on output.
+*> \endverbatim
+*>
+*> \param[in,out] AB
+*> \verbatim
+*>          AB is REAL array, dimension (MMAX,2)
+*>          The endpoints of the intervals.  AB(j,1) is  a(j), the left
+*>          endpoint of the j-th interval, and AB(j,2) is b(j), the
+*>          right endpoint of the j-th interval.  The input intervals
+*>          will, in general, be modified, split, and reordered by the
+*>          calculation.
+*> \endverbatim
+*>
+*> \param[in,out] C
+*> \verbatim
+*>          C is REAL array, dimension (MMAX)
+*>          If IJOB=1, ignored.
+*>          If IJOB=2, workspace.
+*>          If IJOB=3, then on input C(j) should be initialized to the
+*>          first search point in the binary search.
+*> \endverbatim
+*>
+*> \param[out] MOUT
+*> \verbatim
+*>          MOUT is INTEGER
+*>          If IJOB=1, the number of eigenvalues in the intervals.
+*>          If IJOB=2 or 3, the number of intervals output.
+*>          If IJOB=3, MOUT will equal MINP.
+*> \endverbatim
+*>
+*> \param[in,out] NAB
+*> \verbatim
+*>          NAB is INTEGER array, dimension (MMAX,2)
+*>          If IJOB=1, then on output NAB(i,j) will be set to N(AB(i,j)).
+*>          If IJOB=2, then on input, NAB(i,j) should be set.  It must
+*>             satisfy the condition:
+*>             N(AB(i,1)) <= NAB(i,1) <= NAB(i,2) <= N(AB(i,2)),
+*>             which means that in interval i only eigenvalues
+*>             NAB(i,1)+1,...,NAB(i,2) will be considered.  Usually,
+*>             NAB(i,j)=N(AB(i,j)), from a previous call to SLAEBZ with
+*>             IJOB=1.
+*>             On output, NAB(i,j) will contain
+*>             max(na(k),min(nb(k),N(AB(i,j)))), where k is the index of
+*>             the input interval that the output interval
+*>             (AB(j,1),AB(j,2)] came from, and na(k) and nb(k) are the
+*>             the input values of NAB(k,1) and NAB(k,2).
+*>          If IJOB=3, then on output, NAB(i,j) contains N(AB(i,j)),
+*>             unless N(w) > NVAL(i) for all search points  w , in which
+*>             case NAB(i,1) will not be modified, i.e., the output
+*>             value will be the same as the input value (modulo
+*>             reorderings -- see NVAL and AB), or unless N(w) < NVAL(i)
+*>             for all search points  w , in which case NAB(i,2) will
+*>             not be modified.  Normally, NAB should be set to some
+*>             distinctive value(s) before SLAEBZ is called.
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (MMAX)
+*>          Workspace.
+*> \endverbatim
+*>
+*> \param[out] IWORK
+*> \verbatim
+*>          IWORK is INTEGER array, dimension (MMAX)
+*>          Workspace.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:       All intervals converged.
+*>          = 1--MMAX: The last INFO intervals did not converge.
+*>          = MMAX+1:  More than MMAX intervals were generated.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup OTHERauxiliary
+*
+*> \par Further Details:
+*  =====================
+*>
+*> \verbatim
+*>
+*>      This routine is intended to be called only by other LAPACK
+*>  routines, thus the interface is less user-friendly.  It is intended
+*>  for two purposes:
+*>
+*>  (a) finding eigenvalues.  In this case, SLAEBZ should have one or
+*>      more initial intervals set up in AB, and SLAEBZ should be called
+*>      with IJOB=1.  This sets up NAB, and also counts the eigenvalues.
+*>      Intervals with no eigenvalues would usually be thrown out at
+*>      this point.  Also, if not all the eigenvalues in an interval i
+*>      are desired, NAB(i,1) can be increased or NAB(i,2) decreased.
+*>      For example, set NAB(i,1)=NAB(i,2)-1 to get the largest
+*>      eigenvalue.  SLAEBZ is then called with IJOB=2 and MMAX
+*>      no smaller than the value of MOUT returned by the call with
+*>      IJOB=1.  After this (IJOB=2) call, eigenvalues NAB(i,1)+1
+*>      through NAB(i,2) are approximately AB(i,1) (or AB(i,2)) to the
+*>      tolerance specified by ABSTOL and RELTOL.
+*>
+*>  (b) finding an interval (a',b'] containing eigenvalues w(f),...,w(l).
+*>      In this case, start with a Gershgorin interval  (a,b).  Set up
+*>      AB to contain 2 search intervals, both initially (a,b).  One
+*>      NVAL element should contain  f-1  and the other should contain  l
+*>      , while C should contain a and b, resp.  NAB(i,1) should be -1
+*>      and NAB(i,2) should be N+1, to flag an error if the desired
+*>      interval does not lie in (a,b).  SLAEBZ is then called with
+*>      IJOB=3.  On exit, if w(f-1) < w(f), then one of the intervals --
+*>      j -- will have AB(j,1)=AB(j,2) and NAB(j,1)=NAB(j,2)=f-1, while
+*>      if, to the specified tolerance, w(f-k)=...=w(f+r), k > 0 and r
+*>      >= 0, then the interval will have  N(AB(j,1))=NAB(j,1)=f-k and
+*>      N(AB(j,2))=NAB(j,2)=f+r.  The cases w(l) < w(l+1) and
+*>      w(l-r)=...=w(l+k) are handled similarly.
+*> \endverbatim
+*>
+*  =====================================================================
+      SUBROUTINE SLAEBZ( IJOB, NITMAX, N, MMAX, MINP, NBMIN, ABSTOL,
+     $                   RELTOL, PIVMIN, D, E, E2, NVAL, AB, C, MOUT,
+     $                   NAB, WORK, IWORK, INFO )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      INTEGER            IJOB, INFO, MINP, MMAX, MOUT, N, NBMIN, NITMAX
+      REAL               ABSTOL, PIVMIN, RELTOL
+*     ..
+*     .. Array Arguments ..
+      INTEGER            IWORK( * ), NAB( MMAX, * ), NVAL( * )
+      REAL               AB( MMAX, * ), C( * ), D( * ), E( * ), E2( * ),
+     $                   WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO, TWO, HALF
+      PARAMETER          ( ZERO = 0.0E0, TWO = 2.0E0,
+     $                   HALF = 1.0E0 / TWO )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            ITMP1, ITMP2, J, JI, JIT, JP, KF, KFNEW, KL,
+     $                   KLNEW
+      REAL               TMP1, TMP2
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, MAX, MIN
+*     ..
+*     .. Executable Statements ..
+*
+*     Check for Errors
+*
+      INFO = 0
+      IF( IJOB.LT.1 .OR. IJOB.GT.3 ) THEN
+         INFO = -1
+         RETURN
+      END IF
+*
+*     Initialize NAB
+*
+      IF( IJOB.EQ.1 ) THEN
+*
+*        Compute the number of eigenvalues in the initial intervals.
+*
+         MOUT = 0
+         DO 30 JI = 1, MINP
+            DO 20 JP = 1, 2
+               TMP1 = D( 1 ) - AB( JI, JP )
+               IF( ABS( TMP1 ).LT.PIVMIN )
+     $            TMP1 = -PIVMIN
+               NAB( JI, JP ) = 0
+               IF( TMP1.LE.ZERO )
+     $            NAB( JI, JP ) = 1
+*
+               DO 10 J = 2, N
+                  TMP1 = D( J ) - E2( J-1 ) / TMP1 - AB( JI, JP )
+                  IF( ABS( TMP1 ).LT.PIVMIN )
+     $               TMP1 = -PIVMIN
+                  IF( TMP1.LE.ZERO )
+     $               NAB( JI, JP ) = NAB( JI, JP ) + 1
+   10          CONTINUE
+   20       CONTINUE
+            MOUT = MOUT + NAB( JI, 2 ) - NAB( JI, 1 )
+   30    CONTINUE
+         RETURN
+      END IF
+*
+*     Initialize for loop
+*
+*     KF and KL have the following meaning:
+*        Intervals 1,...,KF-1 have converged.
+*        Intervals KF,...,KL  still need to be refined.
+*
+      KF = 1
+      KL = MINP
+*
+*     If IJOB=2, initialize C.
+*     If IJOB=3, use the user-supplied starting point.
+*
+      IF( IJOB.EQ.2 ) THEN
+         DO 40 JI = 1, MINP
+            C( JI ) = HALF*( AB( JI, 1 )+AB( JI, 2 ) )
+   40    CONTINUE
+      END IF
+*
+*     Iteration loop
+*
+      DO 130 JIT = 1, NITMAX
+*
+*        Loop over intervals
+*
+         IF( KL-KF+1.GE.NBMIN .AND. NBMIN.GT.0 ) THEN
+*
+*           Begin of Parallel Version of the loop
+*
+            DO 60 JI = KF, KL
+*
+*              Compute N(c), the number of eigenvalues less than c
+*
+               WORK( JI ) = D( 1 ) - C( JI )
+               IWORK( JI ) = 0
+               IF( WORK( JI ).LE.PIVMIN ) THEN
+                  IWORK( JI ) = 1
+                  WORK( JI ) = MIN( WORK( JI ), -PIVMIN )
+               END IF
+*
+               DO 50 J = 2, N
+                  WORK( JI ) = D( J ) - E2( J-1 ) / WORK( JI ) - C( JI )
+                  IF( WORK( JI ).LE.PIVMIN ) THEN
+                     IWORK( JI ) = IWORK( JI ) + 1
+                     WORK( JI ) = MIN( WORK( JI ), -PIVMIN )
+                  END IF
+   50          CONTINUE
+   60       CONTINUE
+*
+            IF( IJOB.LE.2 ) THEN
+*
+*              IJOB=2: Choose all intervals containing eigenvalues.
+*
+               KLNEW = KL
+               DO 70 JI = KF, KL
+*
+*                 Insure that N(w) is monotone
+*
+                  IWORK( JI ) = MIN( NAB( JI, 2 ),
+     $                          MAX( NAB( JI, 1 ), IWORK( JI ) ) )
+*
+*                 Update the Queue -- add intervals if both halves
+*                 contain eigenvalues.
+*
+                  IF( IWORK( JI ).EQ.NAB( JI, 2 ) ) THEN
+*
+*                    No eigenvalue in the upper interval:
+*                    just use the lower interval.
+*
+                     AB( JI, 2 ) = C( JI )
+*
+                  ELSE IF( IWORK( JI ).EQ.NAB( JI, 1 ) ) THEN
+*
+*                    No eigenvalue in the lower interval:
+*                    just use the upper interval.
+*
+                     AB( JI, 1 ) = C( JI )
+                  ELSE
+                     KLNEW = KLNEW + 1
+                     IF( KLNEW.LE.MMAX ) THEN
+*
+*                       Eigenvalue in both intervals -- add upper to
+*                       queue.
+*
+                        AB( KLNEW, 2 ) = AB( JI, 2 )
+                        NAB( KLNEW, 2 ) = NAB( JI, 2 )
+                        AB( KLNEW, 1 ) = C( JI )
+                        NAB( KLNEW, 1 ) = IWORK( JI )
+                        AB( JI, 2 ) = C( JI )
+                        NAB( JI, 2 ) = IWORK( JI )
+                     ELSE
+                        INFO = MMAX + 1
+                     END IF
+                  END IF
+   70          CONTINUE
+               IF( INFO.NE.0 )
+     $            RETURN
+               KL = KLNEW
+            ELSE
+*
+*              IJOB=3: Binary search.  Keep only the interval containing
+*                      w   s.t. N(w) = NVAL
+*
+               DO 80 JI = KF, KL
+                  IF( IWORK( JI ).LE.NVAL( JI ) ) THEN
+                     AB( JI, 1 ) = C( JI )
+                     NAB( JI, 1 ) = IWORK( JI )
+                  END IF
+                  IF( IWORK( JI ).GE.NVAL( JI ) ) THEN
+                     AB( JI, 2 ) = C( JI )
+                     NAB( JI, 2 ) = IWORK( JI )
+                  END IF
+   80          CONTINUE
+            END IF
+*
+         ELSE
+*
+*           End of Parallel Version of the loop
+*
+*           Begin of Serial Version of the loop
+*
+            KLNEW = KL
+            DO 100 JI = KF, KL
+*
+*              Compute N(w), the number of eigenvalues less than w
+*
+               TMP1 = C( JI )
+               TMP2 = D( 1 ) - TMP1
+               ITMP1 = 0
+               IF( TMP2.LE.PIVMIN ) THEN
+                  ITMP1 = 1
+                  TMP2 = MIN( TMP2, -PIVMIN )
+               END IF
+*
+               DO 90 J = 2, N
+                  TMP2 = D( J ) - E2( J-1 ) / TMP2 - TMP1
+                  IF( TMP2.LE.PIVMIN ) THEN
+                     ITMP1 = ITMP1 + 1
+                     TMP2 = MIN( TMP2, -PIVMIN )
+                  END IF
+   90          CONTINUE
+*
+               IF( IJOB.LE.2 ) THEN
+*
+*                 IJOB=2: Choose all intervals containing eigenvalues.
+*
+*                 Insure that N(w) is monotone
+*
+                  ITMP1 = MIN( NAB( JI, 2 ),
+     $                    MAX( NAB( JI, 1 ), ITMP1 ) )
+*
+*                 Update the Queue -- add intervals if both halves
+*                 contain eigenvalues.
+*
+                  IF( ITMP1.EQ.NAB( JI, 2 ) ) THEN
+*
+*                    No eigenvalue in the upper interval:
+*                    just use the lower interval.
+*
+                     AB( JI, 2 ) = TMP1
+*
+                  ELSE IF( ITMP1.EQ.NAB( JI, 1 ) ) THEN
+*
+*                    No eigenvalue in the lower interval:
+*                    just use the upper interval.
+*
+                     AB( JI, 1 ) = TMP1
+                  ELSE IF( KLNEW.LT.MMAX ) THEN
+*
+*                    Eigenvalue in both intervals -- add upper to queue.
+*
+                     KLNEW = KLNEW + 1
+                     AB( KLNEW, 2 ) = AB( JI, 2 )
+                     NAB( KLNEW, 2 ) = NAB( JI, 2 )
+                     AB( KLNEW, 1 ) = TMP1
+                     NAB( KLNEW, 1 ) = ITMP1
+                     AB( JI, 2 ) = TMP1
+                     NAB( JI, 2 ) = ITMP1
+                  ELSE
+                     INFO = MMAX + 1
+                     RETURN
+                  END IF
+               ELSE
+*
+*                 IJOB=3: Binary search.  Keep only the interval
+*                         containing  w  s.t. N(w) = NVAL
+*
+                  IF( ITMP1.LE.NVAL( JI ) ) THEN
+                     AB( JI, 1 ) = TMP1
+                     NAB( JI, 1 ) = ITMP1
+                  END IF
+                  IF( ITMP1.GE.NVAL( JI ) ) THEN
+                     AB( JI, 2 ) = TMP1
+                     NAB( JI, 2 ) = ITMP1
+                  END IF
+               END IF
+  100       CONTINUE
+            KL = KLNEW
+*
+         END IF
+*
+*        Check for convergence
+*
+         KFNEW = KF
+         DO 110 JI = KF, KL
+            TMP1 = ABS( AB( JI, 2 )-AB( JI, 1 ) )
+            TMP2 = MAX( ABS( AB( JI, 2 ) ), ABS( AB( JI, 1 ) ) )
+            IF( TMP1.LT.MAX( ABSTOL, PIVMIN, RELTOL*TMP2 ) .OR.
+     $          NAB( JI, 1 ).GE.NAB( JI, 2 ) ) THEN
+*
+*              Converged -- Swap with position KFNEW,
+*                           then increment KFNEW
+*
+               IF( JI.GT.KFNEW ) THEN
+                  TMP1 = AB( JI, 1 )
+                  TMP2 = AB( JI, 2 )
+                  ITMP1 = NAB( JI, 1 )
+                  ITMP2 = NAB( JI, 2 )
+                  AB( JI, 1 ) = AB( KFNEW, 1 )
+                  AB( JI, 2 ) = AB( KFNEW, 2 )
+                  NAB( JI, 1 ) = NAB( KFNEW, 1 )
+                  NAB( JI, 2 ) = NAB( KFNEW, 2 )
+                  AB( KFNEW, 1 ) = TMP1
+                  AB( KFNEW, 2 ) = TMP2
+                  NAB( KFNEW, 1 ) = ITMP1
+                  NAB( KFNEW, 2 ) = ITMP2
+                  IF( IJOB.EQ.3 ) THEN
+                     ITMP1 = NVAL( JI )
+                     NVAL( JI ) = NVAL( KFNEW )
+                     NVAL( KFNEW ) = ITMP1
+                  END IF
+               END IF
+               KFNEW = KFNEW + 1
+            END IF
+  110    CONTINUE
+         KF = KFNEW
+*
+*        Choose Midpoints
+*
+         DO 120 JI = KF, KL
+            C( JI ) = HALF*( AB( JI, 1 )+AB( JI, 2 ) )
+  120    CONTINUE
+*
+*        If no more intervals to refine, quit.
+*
+         IF( KF.GT.KL )
+     $      GO TO 140
+  130 CONTINUE
+*
+*     Converged
+*
+  140 CONTINUE
+      INFO = MAX( KL+1-KF, 0 )
+      MOUT = KL
+*
+      RETURN
+*
+*     End of SLAEBZ
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slaev2.f AmberTools/src/quick/src/blas/slaev2.f
--- AmberTools/src/quick/src/blas/slaev2.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slaev2.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,238 @@
+*> \brief \b SLAEV2 computes the eigenvalues and eigenvectors of a 2-by-2 symmetric/Hermitian matrix.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLAEV2 + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slaev2.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slaev2.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaev2.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLAEV2( A, B, C, RT1, RT2, CS1, SN1 )
+*
+*       .. Scalar Arguments ..
+*       REAL               A, B, C, CS1, RT1, RT2, SN1
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
+*>    [  A   B  ]
+*>    [  B   C  ].
+*> On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
+*> eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
+*> eigenvector for RT1, giving the decomposition
+*>
+*>    [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
+*>    [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] A
+*> \verbatim
+*>          A is REAL
+*>          The (1,1) element of the 2-by-2 matrix.
+*> \endverbatim
+*>
+*> \param[in] B
+*> \verbatim
+*>          B is REAL
+*>          The (1,2) element and the conjugate of the (2,1) element of
+*>          the 2-by-2 matrix.
+*> \endverbatim
+*>
+*> \param[in] C
+*> \verbatim
+*>          C is REAL
+*>          The (2,2) element of the 2-by-2 matrix.
+*> \endverbatim
+*>
+*> \param[out] RT1
+*> \verbatim
+*>          RT1 is REAL
+*>          The eigenvalue of larger absolute value.
+*> \endverbatim
+*>
+*> \param[out] RT2
+*> \verbatim
+*>          RT2 is REAL
+*>          The eigenvalue of smaller absolute value.
+*> \endverbatim
+*>
+*> \param[out] CS1
+*> \verbatim
+*>          CS1 is REAL
+*> \endverbatim
+*>
+*> \param[out] SN1
+*> \verbatim
+*>          SN1 is REAL
+*>          The vector (CS1, SN1) is a unit right eigenvector for RT1.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup OTHERauxiliary
+*
+*> \par Further Details:
+*  =====================
+*>
+*> \verbatim
+*>
+*>  RT1 is accurate to a few ulps barring over/underflow.
+*>
+*>  RT2 may be inaccurate if there is massive cancellation in the
+*>  determinant A*C-B*B; higher precision or correctly rounded or
+*>  correctly truncated arithmetic would be needed to compute RT2
+*>  accurately in all cases.
+*>
+*>  CS1 and SN1 are accurate to a few ulps barring over/underflow.
+*>
+*>  Overflow is possible only if RT1 is within a factor of 5 of overflow.
+*>  Underflow is harmless if the input data is 0 or exceeds
+*>     underflow_threshold / macheps.
+*> \endverbatim
+*>
+*  =====================================================================
+      SUBROUTINE SLAEV2( A, B, C, RT1, RT2, CS1, SN1 )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      REAL               A, B, C, CS1, RT1, RT2, SN1
+*     ..
+*
+* =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE
+      PARAMETER          ( ONE = 1.0E0 )
+      REAL               TWO
+      PARAMETER          ( TWO = 2.0E0 )
+      REAL               ZERO
+      PARAMETER          ( ZERO = 0.0E0 )
+      REAL               HALF
+      PARAMETER          ( HALF = 0.5E0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            SGN1, SGN2
+      REAL               AB, ACMN, ACMX, ACS, ADF, CS, CT, DF, RT, SM,
+     $                   TB, TN
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, SQRT
+*     ..
+*     .. Executable Statements ..
+*
+*     Compute the eigenvalues
+*
+      SM = A + C
+      DF = A - C
+      ADF = ABS( DF )
+      TB = B + B
+      AB = ABS( TB )
+      IF( ABS( A ).GT.ABS( C ) ) THEN
+         ACMX = A
+         ACMN = C
+      ELSE
+         ACMX = C
+         ACMN = A
+      END IF
+      IF( ADF.GT.AB ) THEN
+         RT = ADF*SQRT( ONE+( AB / ADF )**2 )
+      ELSE IF( ADF.LT.AB ) THEN
+         RT = AB*SQRT( ONE+( ADF / AB )**2 )
+      ELSE
+*
+*        Includes case AB=ADF=0
+*
+         RT = AB*SQRT( TWO )
+      END IF
+      IF( SM.LT.ZERO ) THEN
+         RT1 = HALF*( SM-RT )
+         SGN1 = -1
+*
+*        Order of execution important.
+*        To get fully accurate smaller eigenvalue,
+*        next line needs to be executed in higher precision.
+*
+         RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B
+      ELSE IF( SM.GT.ZERO ) THEN
+         RT1 = HALF*( SM+RT )
+         SGN1 = 1
+*
+*        Order of execution important.
+*        To get fully accurate smaller eigenvalue,
+*        next line needs to be executed in higher precision.
+*
+         RT2 = ( ACMX / RT1 )*ACMN - ( B / RT1 )*B
+      ELSE
+*
+*        Includes case RT1 = RT2 = 0
+*
+         RT1 = HALF*RT
+         RT2 = -HALF*RT
+         SGN1 = 1
+      END IF
+*
+*     Compute the eigenvector
+*
+      IF( DF.GE.ZERO ) THEN
+         CS = DF + RT
+         SGN2 = 1
+      ELSE
+         CS = DF - RT
+         SGN2 = -1
+      END IF
+      ACS = ABS( CS )
+      IF( ACS.GT.AB ) THEN
+         CT = -TB / CS
+         SN1 = ONE / SQRT( ONE+CT*CT )
+         CS1 = CT*SN1
+      ELSE
+         IF( AB.EQ.ZERO ) THEN
+            CS1 = ONE
+            SN1 = ZERO
+         ELSE
+            TN = -CS / TB
+            CS1 = ONE / SQRT( ONE+TN*TN )
+            SN1 = TN*CS1
+         END IF
+      END IF
+      IF( SGN1.EQ.SGN2 ) THEN
+         TN = CS1
+         CS1 = -SN1
+         SN1 = TN
+      END IF
+      RETURN
+*
+*     End of SLAEV2
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slagtf.f AmberTools/src/quick/src/blas/slagtf.f
--- AmberTools/src/quick/src/blas/slagtf.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slagtf.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,266 @@
+*> \brief \b SLAGTF computes an LU factorization of a matrix T-λI, where T is a general tridiagonal matrix, and λ a scalar, using partial pivoting with row interchanges.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLAGTF + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slagtf.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slagtf.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slagtf.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLAGTF( N, A, LAMBDA, B, C, TOL, D, IN, INFO )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            INFO, N
+*       REAL               LAMBDA, TOL
+*       ..
+*       .. Array Arguments ..
+*       INTEGER            IN( * )
+*       REAL               A( * ), B( * ), C( * ), D( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLAGTF factorizes the matrix (T - lambda*I), where T is an n by n
+*> tridiagonal matrix and lambda is a scalar, as
+*>
+*>    T - lambda*I = PLU,
+*>
+*> where P is a permutation matrix, L is a unit lower tridiagonal matrix
+*> with at most one non-zero sub-diagonal elements per column and U is
+*> an upper triangular matrix with at most two non-zero super-diagonal
+*> elements per column.
+*>
+*> The factorization is obtained by Gaussian elimination with partial
+*> pivoting and implicit row scaling.
+*>
+*> The parameter LAMBDA is included in the routine so that SLAGTF may
+*> be used, in conjunction with SLAGTS, to obtain eigenvectors of T by
+*> inverse iteration.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the matrix T.
+*> \endverbatim
+*>
+*> \param[in,out] A
+*> \verbatim
+*>          A is REAL array, dimension (N)
+*>          On entry, A must contain the diagonal elements of T.
+*>
+*>          On exit, A is overwritten by the n diagonal elements of the
+*>          upper triangular matrix U of the factorization of T.
+*> \endverbatim
+*>
+*> \param[in] LAMBDA
+*> \verbatim
+*>          LAMBDA is REAL
+*>          On entry, the scalar lambda.
+*> \endverbatim
+*>
+*> \param[in,out] B
+*> \verbatim
+*>          B is REAL array, dimension (N-1)
+*>          On entry, B must contain the (n-1) super-diagonal elements of
+*>          T.
+*>
+*>          On exit, B is overwritten by the (n-1) super-diagonal
+*>          elements of the matrix U of the factorization of T.
+*> \endverbatim
+*>
+*> \param[in,out] C
+*> \verbatim
+*>          C is REAL array, dimension (N-1)
+*>          On entry, C must contain the (n-1) sub-diagonal elements of
+*>          T.
+*>
+*>          On exit, C is overwritten by the (n-1) sub-diagonal elements
+*>          of the matrix L of the factorization of T.
+*> \endverbatim
+*>
+*> \param[in] TOL
+*> \verbatim
+*>          TOL is REAL
+*>          On entry, a relative tolerance used to indicate whether or
+*>          not the matrix (T - lambda*I) is nearly singular. TOL should
+*>          normally be chose as approximately the largest relative error
+*>          in the elements of T. For example, if the elements of T are
+*>          correct to about 4 significant figures, then TOL should be
+*>          set to about 5*10**(-4). If TOL is supplied as less than eps,
+*>          where eps is the relative machine precision, then the value
+*>          eps is used in place of TOL.
+*> \endverbatim
+*>
+*> \param[out] D
+*> \verbatim
+*>          D is REAL array, dimension (N-2)
+*>          On exit, D is overwritten by the (n-2) second super-diagonal
+*>          elements of the matrix U of the factorization of T.
+*> \endverbatim
+*>
+*> \param[out] IN
+*> \verbatim
+*>          IN is INTEGER array, dimension (N)
+*>          On exit, IN contains details of the permutation matrix P. If
+*>          an interchange occurred at the kth step of the elimination,
+*>          then IN(k) = 1, otherwise IN(k) = 0. The element IN(n)
+*>          returns the smallest positive integer j such that
+*>
+*>             abs( u(j,j) ) <= norm( (T - lambda*I)(j) )*TOL,
+*>
+*>          where norm( A(j) ) denotes the sum of the absolute values of
+*>          the jth row of the matrix A. If no such j exists then IN(n)
+*>          is returned as zero. If IN(n) is returned as positive, then a
+*>          diagonal element of U is small, indicating that
+*>          (T - lambda*I) is singular or nearly singular,
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0: successful exit
+*>          < 0: if INFO = -k, the kth argument had an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup auxOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SLAGTF( N, A, LAMBDA, B, C, TOL, D, IN, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      INTEGER            INFO, N
+      REAL               LAMBDA, TOL
+*     ..
+*     .. Array Arguments ..
+      INTEGER            IN( * )
+      REAL               A( * ), B( * ), C( * ), D( * )
+*     ..
+*
+* =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO
+      PARAMETER          ( ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            K
+      REAL               EPS, MULT, PIV1, PIV2, SCALE1, SCALE2, TEMP, TL
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, MAX
+*     ..
+*     .. External Functions ..
+      REAL               SLAMCH
+      EXTERNAL           SLAMCH
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           XERBLA
+*     ..
+*     .. Executable Statements ..
+*
+      INFO = 0
+      IF( N.LT.0 ) THEN
+         INFO = -1
+         CALL XERBLA( 'SLAGTF', -INFO )
+         RETURN
+      END IF
+*
+      IF( N.EQ.0 )
+     $   RETURN
+*
+      A( 1 ) = A( 1 ) - LAMBDA
+      IN( N ) = 0
+      IF( N.EQ.1 ) THEN
+         IF( A( 1 ).EQ.ZERO )
+     $      IN( 1 ) = 1
+         RETURN
+      END IF
+*
+      EPS = SLAMCH( 'Epsilon' )
+*
+      TL = MAX( TOL, EPS )
+      SCALE1 = ABS( A( 1 ) ) + ABS( B( 1 ) )
+      DO 10 K = 1, N - 1
+         A( K+1 ) = A( K+1 ) - LAMBDA
+         SCALE2 = ABS( C( K ) ) + ABS( A( K+1 ) )
+         IF( K.LT.( N-1 ) )
+     $      SCALE2 = SCALE2 + ABS( B( K+1 ) )
+         IF( A( K ).EQ.ZERO ) THEN
+            PIV1 = ZERO
+         ELSE
+            PIV1 = ABS( A( K ) ) / SCALE1
+         END IF
+         IF( C( K ).EQ.ZERO ) THEN
+            IN( K ) = 0
+            PIV2 = ZERO
+            SCALE1 = SCALE2
+            IF( K.LT.( N-1 ) )
+     $         D( K ) = ZERO
+         ELSE
+            PIV2 = ABS( C( K ) ) / SCALE2
+            IF( PIV2.LE.PIV1 ) THEN
+               IN( K ) = 0
+               SCALE1 = SCALE2
+               C( K ) = C( K ) / A( K )
+               A( K+1 ) = A( K+1 ) - C( K )*B( K )
+               IF( K.LT.( N-1 ) )
+     $            D( K ) = ZERO
+            ELSE
+               IN( K ) = 1
+               MULT = A( K ) / C( K )
+               A( K ) = C( K )
+               TEMP = A( K+1 )
+               A( K+1 ) = B( K ) - MULT*TEMP
+               IF( K.LT.( N-1 ) ) THEN
+                  D( K ) = B( K+1 )
+                  B( K+1 ) = -MULT*D( K )
+               END IF
+               B( K ) = TEMP
+               C( K ) = MULT
+            END IF
+         END IF
+         IF( ( MAX( PIV1, PIV2 ).LE.TL ) .AND. ( IN( N ).EQ.0 ) )
+     $      IN( N ) = K
+   10 CONTINUE
+      IF( ( ABS( A( N ) ).LE.SCALE1*TL ) .AND. ( IN( N ).EQ.0 ) )
+     $   IN( N ) = N
+*
+      RETURN
+*
+*     End of SLAGTF
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slagts.f AmberTools/src/quick/src/blas/slagts.f
--- AmberTools/src/quick/src/blas/slagts.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slagts.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,383 @@
+*> \brief \b SLAGTS solves the system of equations (T-λI)x = y or (T-λI)Tx = y,where T is a general tridiagonal matrix and λ a scalar, using the LU factorization computed by slagtf.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLAGTS + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slagts.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slagts.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slagts.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLAGTS( JOB, N, A, B, C, D, IN, Y, TOL, INFO )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            INFO, JOB, N
+*       REAL               TOL
+*       ..
+*       .. Array Arguments ..
+*       INTEGER            IN( * )
+*       REAL               A( * ), B( * ), C( * ), D( * ), Y( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLAGTS may be used to solve one of the systems of equations
+*>
+*>    (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,
+*>
+*> where T is an n by n tridiagonal matrix, for x, following the
+*> factorization of (T - lambda*I) as
+*>
+*>    (T - lambda*I) = P*L*U ,
+*>
+*> by routine SLAGTF. The choice of equation to be solved is
+*> controlled by the argument JOB, and in each case there is an option
+*> to perturb zero or very small diagonal elements of U, this option
+*> being intended for use in applications such as inverse iteration.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] JOB
+*> \verbatim
+*>          JOB is INTEGER
+*>          Specifies the job to be performed by SLAGTS as follows:
+*>          =  1: The equations  (T - lambda*I)x = y  are to be solved,
+*>                but diagonal elements of U are not to be perturbed.
+*>          = -1: The equations  (T - lambda*I)x = y  are to be solved
+*>                and, if overflow would otherwise occur, the diagonal
+*>                elements of U are to be perturbed. See argument TOL
+*>                below.
+*>          =  2: The equations  (T - lambda*I)**Tx = y  are to be solved,
+*>                but diagonal elements of U are not to be perturbed.
+*>          = -2: The equations  (T - lambda*I)**Tx = y  are to be solved
+*>                and, if overflow would otherwise occur, the diagonal
+*>                elements of U are to be perturbed. See argument TOL
+*>                below.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the matrix T.
+*> \endverbatim
+*>
+*> \param[in] A
+*> \verbatim
+*>          A is REAL array, dimension (N)
+*>          On entry, A must contain the diagonal elements of U as
+*>          returned from SLAGTF.
+*> \endverbatim
+*>
+*> \param[in] B
+*> \verbatim
+*>          B is REAL array, dimension (N-1)
+*>          On entry, B must contain the first super-diagonal elements of
+*>          U as returned from SLAGTF.
+*> \endverbatim
+*>
+*> \param[in] C
+*> \verbatim
+*>          C is REAL array, dimension (N-1)
+*>          On entry, C must contain the sub-diagonal elements of L as
+*>          returned from SLAGTF.
+*> \endverbatim
+*>
+*> \param[in] D
+*> \verbatim
+*>          D is REAL array, dimension (N-2)
+*>          On entry, D must contain the second super-diagonal elements
+*>          of U as returned from SLAGTF.
+*> \endverbatim
+*>
+*> \param[in] IN
+*> \verbatim
+*>          IN is INTEGER array, dimension (N)
+*>          On entry, IN must contain details of the matrix P as returned
+*>          from SLAGTF.
+*> \endverbatim
+*>
+*> \param[in,out] Y
+*> \verbatim
+*>          Y is REAL array, dimension (N)
+*>          On entry, the right hand side vector y.
+*>          On exit, Y is overwritten by the solution vector x.
+*> \endverbatim
+*>
+*> \param[in,out] TOL
+*> \verbatim
+*>          TOL is REAL
+*>          On entry, with  JOB < 0, TOL should be the minimum
+*>          perturbation to be made to very small diagonal elements of U.
+*>          TOL should normally be chosen as about eps*norm(U), where eps
+*>          is the relative machine precision, but if TOL is supplied as
+*>          non-positive, then it is reset to eps*max( abs( u(i,j) ) ).
+*>          If  JOB > 0  then TOL is not referenced.
+*>
+*>          On exit, TOL is changed as described above, only if TOL is
+*>          non-positive on entry. Otherwise TOL is unchanged.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0: successful exit
+*>          < 0: if INFO = -i, the i-th argument had an illegal value
+*>          > 0: overflow would occur when computing the INFO(th)
+*>               element of the solution vector x. This can only occur
+*>               when JOB is supplied as positive and either means
+*>               that a diagonal element of U is very small, or that
+*>               the elements of the right-hand side vector y are very
+*>               large.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup OTHERauxiliary
+*
+*  =====================================================================
+      SUBROUTINE SLAGTS( JOB, N, A, B, C, D, IN, Y, TOL, INFO )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      INTEGER            INFO, JOB, N
+      REAL               TOL
+*     ..
+*     .. Array Arguments ..
+      INTEGER            IN( * )
+      REAL               A( * ), B( * ), C( * ), D( * ), Y( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE, ZERO
+      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            K
+      REAL               ABSAK, AK, BIGNUM, EPS, PERT, SFMIN, TEMP
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, MAX, SIGN
+*     ..
+*     .. External Functions ..
+      REAL               SLAMCH
+      EXTERNAL           SLAMCH
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           XERBLA
+*     ..
+*     .. Executable Statements ..
+*
+      INFO = 0
+      IF( ( ABS( JOB ).GT.2 ) .OR. ( JOB.EQ.0 ) ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -2
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SLAGTS', -INFO )
+         RETURN
+      END IF
+*
+      IF( N.EQ.0 )
+     $   RETURN
+*
+      EPS = SLAMCH( 'Epsilon' )
+      SFMIN = SLAMCH( 'Safe minimum' )
+      BIGNUM = ONE / SFMIN
+*
+      IF( JOB.LT.0 ) THEN
+         IF( TOL.LE.ZERO ) THEN
+            TOL = ABS( A( 1 ) )
+            IF( N.GT.1 )
+     $         TOL = MAX( TOL, ABS( A( 2 ) ), ABS( B( 1 ) ) )
+            DO 10 K = 3, N
+               TOL = MAX( TOL, ABS( A( K ) ), ABS( B( K-1 ) ),
+     $               ABS( D( K-2 ) ) )
+   10       CONTINUE
+            TOL = TOL*EPS
+            IF( TOL.EQ.ZERO )
+     $         TOL = EPS
+         END IF
+      END IF
+*
+      IF( ABS( JOB ).EQ.1 ) THEN
+         DO 20 K = 2, N
+            IF( IN( K-1 ).EQ.0 ) THEN
+               Y( K ) = Y( K ) - C( K-1 )*Y( K-1 )
+            ELSE
+               TEMP = Y( K-1 )
+               Y( K-1 ) = Y( K )
+               Y( K ) = TEMP - C( K-1 )*Y( K )
+            END IF
+   20    CONTINUE
+         IF( JOB.EQ.1 ) THEN
+            DO 30 K = N, 1, -1
+               IF( K.LE.N-2 ) THEN
+                  TEMP = Y( K ) - B( K )*Y( K+1 ) - D( K )*Y( K+2 )
+               ELSE IF( K.EQ.N-1 ) THEN
+                  TEMP = Y( K ) - B( K )*Y( K+1 )
+               ELSE
+                  TEMP = Y( K )
+               END IF
+               AK = A( K )
+               ABSAK = ABS( AK )
+               IF( ABSAK.LT.ONE ) THEN
+                  IF( ABSAK.LT.SFMIN ) THEN
+                     IF( ABSAK.EQ.ZERO .OR. ABS( TEMP )*SFMIN.GT.ABSAK )
+     $                    THEN
+                        INFO = K
+                        RETURN
+                     ELSE
+                        TEMP = TEMP*BIGNUM
+                        AK = AK*BIGNUM
+                     END IF
+                  ELSE IF( ABS( TEMP ).GT.ABSAK*BIGNUM ) THEN
+                     INFO = K
+                     RETURN
+                  END IF
+               END IF
+               Y( K ) = TEMP / AK
+   30       CONTINUE
+         ELSE
+            DO 50 K = N, 1, -1
+               IF( K.LE.N-2 ) THEN
+                  TEMP = Y( K ) - B( K )*Y( K+1 ) - D( K )*Y( K+2 )
+               ELSE IF( K.EQ.N-1 ) THEN
+                  TEMP = Y( K ) - B( K )*Y( K+1 )
+               ELSE
+                  TEMP = Y( K )
+               END IF
+               AK = A( K )
+               PERT = SIGN( TOL, AK )
+   40          CONTINUE
+               ABSAK = ABS( AK )
+               IF( ABSAK.LT.ONE ) THEN
+                  IF( ABSAK.LT.SFMIN ) THEN
+                     IF( ABSAK.EQ.ZERO .OR. ABS( TEMP )*SFMIN.GT.ABSAK )
+     $                    THEN
+                        AK = AK + PERT
+                        PERT = 2*PERT
+                        GO TO 40
+                     ELSE
+                        TEMP = TEMP*BIGNUM
+                        AK = AK*BIGNUM
+                     END IF
+                  ELSE IF( ABS( TEMP ).GT.ABSAK*BIGNUM ) THEN
+                     AK = AK + PERT
+                     PERT = 2*PERT
+                     GO TO 40
+                  END IF
+               END IF
+               Y( K ) = TEMP / AK
+   50       CONTINUE
+         END IF
+      ELSE
+*
+*        Come to here if  JOB = 2 or -2
+*
+         IF( JOB.EQ.2 ) THEN
+            DO 60 K = 1, N
+               IF( K.GE.3 ) THEN
+                  TEMP = Y( K ) - B( K-1 )*Y( K-1 ) - D( K-2 )*Y( K-2 )
+               ELSE IF( K.EQ.2 ) THEN
+                  TEMP = Y( K ) - B( K-1 )*Y( K-1 )
+               ELSE
+                  TEMP = Y( K )
+               END IF
+               AK = A( K )
+               ABSAK = ABS( AK )
+               IF( ABSAK.LT.ONE ) THEN
+                  IF( ABSAK.LT.SFMIN ) THEN
+                     IF( ABSAK.EQ.ZERO .OR. ABS( TEMP )*SFMIN.GT.ABSAK )
+     $                    THEN
+                        INFO = K
+                        RETURN
+                     ELSE
+                        TEMP = TEMP*BIGNUM
+                        AK = AK*BIGNUM
+                     END IF
+                  ELSE IF( ABS( TEMP ).GT.ABSAK*BIGNUM ) THEN
+                     INFO = K
+                     RETURN
+                  END IF
+               END IF
+               Y( K ) = TEMP / AK
+   60       CONTINUE
+         ELSE
+            DO 80 K = 1, N
+               IF( K.GE.3 ) THEN
+                  TEMP = Y( K ) - B( K-1 )*Y( K-1 ) - D( K-2 )*Y( K-2 )
+               ELSE IF( K.EQ.2 ) THEN
+                  TEMP = Y( K ) - B( K-1 )*Y( K-1 )
+               ELSE
+                  TEMP = Y( K )
+               END IF
+               AK = A( K )
+               PERT = SIGN( TOL, AK )
+   70          CONTINUE
+               ABSAK = ABS( AK )
+               IF( ABSAK.LT.ONE ) THEN
+                  IF( ABSAK.LT.SFMIN ) THEN
+                     IF( ABSAK.EQ.ZERO .OR. ABS( TEMP )*SFMIN.GT.ABSAK )
+     $                    THEN
+                        AK = AK + PERT
+                        PERT = 2*PERT
+                        GO TO 70
+                     ELSE
+                        TEMP = TEMP*BIGNUM
+                        AK = AK*BIGNUM
+                     END IF
+                  ELSE IF( ABS( TEMP ).GT.ABSAK*BIGNUM ) THEN
+                     AK = AK + PERT
+                     PERT = 2*PERT
+                     GO TO 70
+                  END IF
+               END IF
+               Y( K ) = TEMP / AK
+   80       CONTINUE
+         END IF
+*
+         DO 90 K = N, 2, -1
+            IF( IN( K-1 ).EQ.0 ) THEN
+               Y( K-1 ) = Y( K-1 ) - C( K-1 )*Y( K )
+            ELSE
+               TEMP = Y( K-1 )
+               Y( K-1 ) = Y( K )
+               Y( K ) = TEMP - C( K-1 )*Y( K )
+            END IF
+   90    CONTINUE
+      END IF
+*
+*     End of SLAGTS
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slaisnan.f AmberTools/src/quick/src/blas/slaisnan.f
--- AmberTools/src/quick/src/blas/slaisnan.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slaisnan.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,91 @@
+*> \brief \b SLAISNAN tests input for NaN by comparing two arguments for inequality.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLAISNAN + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slaisnan.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slaisnan.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaisnan.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       LOGICAL FUNCTION SLAISNAN( SIN1, SIN2 )
+*
+*       .. Scalar Arguments ..
+*       REAL, INTENT(IN) :: SIN1, SIN2
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> This routine is not for general use.  It exists solely to avoid
+*> over-optimization in SISNAN.
+*>
+*> SLAISNAN checks for NaNs by comparing its two arguments for
+*> inequality.  NaN is the only floating-point value where NaN != NaN
+*> returns .TRUE.  To check for NaNs, pass the same variable as both
+*> arguments.
+*>
+*> A compiler must assume that the two arguments are
+*> not the same variable, and the test will not be optimized away.
+*> Interprocedural or whole-program optimization may delete this
+*> test.  The ISNAN functions will be replaced by the correct
+*> Fortran 03 intrinsic once the intrinsic is widely available.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] SIN1
+*> \verbatim
+*>          SIN1 is REAL
+*> \endverbatim
+*>
+*> \param[in] SIN2
+*> \verbatim
+*>          SIN2 is REAL
+*>          Two numbers to compare for inequality.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date June 2017
+*
+*> \ingroup OTHERauxiliary
+*
+*  =====================================================================
+      LOGICAL FUNCTION SLAISNAN( SIN1, SIN2 )
+*
+*  -- LAPACK auxiliary routine (version 3.7.1) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     June 2017
+*
+*     .. Scalar Arguments ..
+      REAL, INTENT(IN) :: SIN1, SIN2
+*     ..
+*
+*  =====================================================================
+*
+*  .. Executable Statements ..
+      SLAISNAN = (SIN1.NE.SIN2)
+      RETURN
+      END
diff -uN AmberTools/src/quick/src/blas/slamch.f AmberTools/src/quick/src/blas/slamch.f
--- AmberTools/src/quick/src/blas/slamch.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slamch.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,193 @@
+*> \brief \b SLAMCH
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*  Definition:
+*  ===========
+*
+*      REAL             FUNCTION SLAMCH( CMACH )
+*
+*     .. Scalar Arguments ..
+*      CHARACTER          CMACH
+*     ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLAMCH determines single precision machine parameters.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] CMACH
+*> \verbatim
+*>          CMACH is CHARACTER*1
+*>          Specifies the value to be returned by SLAMCH:
+*>          = 'E' or 'e',   SLAMCH := eps
+*>          = 'S' or 's ,   SLAMCH := sfmin
+*>          = 'B' or 'b',   SLAMCH := base
+*>          = 'P' or 'p',   SLAMCH := eps*base
+*>          = 'N' or 'n',   SLAMCH := t
+*>          = 'R' or 'r',   SLAMCH := rnd
+*>          = 'M' or 'm',   SLAMCH := emin
+*>          = 'U' or 'u',   SLAMCH := rmin
+*>          = 'L' or 'l',   SLAMCH := emax
+*>          = 'O' or 'o',   SLAMCH := rmax
+*>          where
+*>          eps   = relative machine precision
+*>          sfmin = safe minimum, such that 1/sfmin does not overflow
+*>          base  = base of the machine
+*>          prec  = eps*base
+*>          t     = number of (base) digits in the mantissa
+*>          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
+*>          emin  = minimum exponent before (gradual) underflow
+*>          rmin  = underflow threshold - base**(emin-1)
+*>          emax  = largest exponent before overflow
+*>          rmax  = overflow threshold  - (base**emax)*(1-eps)
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup auxOTHERauxiliary
+*
+*  =====================================================================
+      REAL             FUNCTION SLAMCH( CMACH )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          CMACH
+*     ..
+*
+* =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE, ZERO
+      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      REAL               RND, EPS, SFMIN, SMALL, RMACH
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      EXTERNAL           LSAME
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          DIGITS, EPSILON, HUGE, MAXEXPONENT,
+     $                   MINEXPONENT, RADIX, TINY
+*     ..
+*     .. Executable Statements ..
+*
+*
+*     Assume rounding, not chopping. Always.
+*
+      RND = ONE
+*
+      IF( ONE.EQ.RND ) THEN
+         EPS = EPSILON(ZERO) * 0.5
+      ELSE
+         EPS = EPSILON(ZERO)
+      END IF
+*
+      IF( LSAME( CMACH, 'E' ) ) THEN
+         RMACH = EPS
+      ELSE IF( LSAME( CMACH, 'S' ) ) THEN
+         SFMIN = TINY(ZERO)
+         SMALL = ONE / HUGE(ZERO)
+         IF( SMALL.GE.SFMIN ) THEN
+*
+*           Use SMALL plus a bit, to avoid the possibility of rounding
+*           causing overflow when computing  1/sfmin.
+*
+            SFMIN = SMALL*( ONE+EPS )
+         END IF
+         RMACH = SFMIN
+      ELSE IF( LSAME( CMACH, 'B' ) ) THEN
+         RMACH = RADIX(ZERO)
+      ELSE IF( LSAME( CMACH, 'P' ) ) THEN
+         RMACH = EPS * RADIX(ZERO)
+      ELSE IF( LSAME( CMACH, 'N' ) ) THEN
+         RMACH = DIGITS(ZERO)
+      ELSE IF( LSAME( CMACH, 'R' ) ) THEN
+         RMACH = RND
+      ELSE IF( LSAME( CMACH, 'M' ) ) THEN
+         RMACH = MINEXPONENT(ZERO)
+      ELSE IF( LSAME( CMACH, 'U' ) ) THEN
+         RMACH = tiny(zero)
+      ELSE IF( LSAME( CMACH, 'L' ) ) THEN
+         RMACH = MAXEXPONENT(ZERO)
+      ELSE IF( LSAME( CMACH, 'O' ) ) THEN
+         RMACH = HUGE(ZERO)
+      ELSE
+         RMACH = ZERO
+      END IF
+*
+      SLAMCH = RMACH
+      RETURN
+*
+*     End of SLAMCH
+*
+      END
+************************************************************************
+*> \brief \b SLAMC3
+*> \details
+*> \b Purpose:
+*> \verbatim
+*> SLAMC3  is intended to force  A  and  B  to be stored prior to doing
+*> the addition of  A  and  B ,  for use in situations where optimizers
+*> might hold one of these in a register.
+*> \endverbatim
+*> \author LAPACK is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..
+*> \date December 2016
+*> \ingroup auxOTHERauxiliary
+*>
+*> \param[in] A
+*> \verbatim
+*> \endverbatim
+*>
+*> \param[in] B
+*> \verbatim
+*>          The values A and B.
+*> \endverbatim
+*>
+*
+      REAL             FUNCTION SLAMC3( A, B )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
+*     November 2010
+*
+*     .. Scalar Arguments ..
+      REAL               A, B
+*     ..
+* =====================================================================
+*
+*     .. Executable Statements ..
+*
+      SLAMC3 = A + B
+*
+      RETURN
+*
+*     End of SLAMC3
+*
+      END
+*
+************************************************************************
diff -uN AmberTools/src/quick/src/blas/slanst.f AmberTools/src/quick/src/blas/slanst.f
--- AmberTools/src/quick/src/blas/slanst.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slanst.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,186 @@
+*> \brief \b SLANST returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real symmetric tridiagonal matrix.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLANST + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slanst.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slanst.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slanst.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       REAL             FUNCTION SLANST( NORM, N, D, E )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          NORM
+*       INTEGER            N
+*       ..
+*       .. Array Arguments ..
+*       REAL               D( * ), E( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLANST  returns the value of the one norm,  or the Frobenius norm, or
+*> the  infinity norm,  or the  element of  largest absolute value  of a
+*> real symmetric tridiagonal matrix A.
+*> \endverbatim
+*>
+*> \return SLANST
+*> \verbatim
+*>
+*>    SLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'
+*>             (
+*>             ( norm1(A),         NORM = '1', 'O' or 'o'
+*>             (
+*>             ( normI(A),         NORM = 'I' or 'i'
+*>             (
+*>             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
+*>
+*> where  norm1  denotes the  one norm of a matrix (maximum column sum),
+*> normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
+*> normF  denotes the  Frobenius norm of a matrix (square root of sum of
+*> squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] NORM
+*> \verbatim
+*>          NORM is CHARACTER*1
+*>          Specifies the value to be returned in SLANST as described
+*>          above.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the matrix A.  N >= 0.  When N = 0, SLANST is
+*>          set to zero.
+*> \endverbatim
+*>
+*> \param[in] D
+*> \verbatim
+*>          D is REAL array, dimension (N)
+*>          The diagonal elements of A.
+*> \endverbatim
+*>
+*> \param[in] E
+*> \verbatim
+*>          E is REAL array, dimension (N-1)
+*>          The (n-1) sub-diagonal or super-diagonal elements of A.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup OTHERauxiliary
+*
+*  =====================================================================
+      REAL             FUNCTION SLANST( NORM, N, D, E )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          NORM
+      INTEGER            N
+*     ..
+*     .. Array Arguments ..
+      REAL               D( * ), E( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE, ZERO
+      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I
+      REAL               ANORM, SCALE, SUM
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME, SISNAN
+      EXTERNAL           LSAME, SISNAN
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLASSQ
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, SQRT
+*     ..
+*     .. Executable Statements ..
+*
+      IF( N.LE.0 ) THEN
+         ANORM = ZERO
+      ELSE IF( LSAME( NORM, 'M' ) ) THEN
+*
+*        Find max(abs(A(i,j))).
+*
+         ANORM = ABS( D( N ) )
+         DO 10 I = 1, N - 1
+            SUM = ABS( D( I ) )
+            IF( ANORM .LT. SUM .OR. SISNAN( SUM ) ) ANORM = SUM
+            SUM = ABS( E( I ) )
+            IF( ANORM .LT. SUM .OR. SISNAN( SUM ) ) ANORM = SUM
+   10    CONTINUE
+      ELSE IF( LSAME( NORM, 'O' ) .OR. NORM.EQ.'1' .OR.
+     $         LSAME( NORM, 'I' ) ) THEN
+*
+*        Find norm1(A).
+*
+         IF( N.EQ.1 ) THEN
+            ANORM = ABS( D( 1 ) )
+         ELSE
+            ANORM = ABS( D( 1 ) )+ABS( E( 1 ) )
+            SUM = ABS( E( N-1 ) )+ABS( D( N ) )
+            IF( ANORM .LT. SUM .OR. SISNAN( SUM ) ) ANORM = SUM
+            DO 20 I = 2, N - 1
+               SUM = ABS( D( I ) )+ABS( E( I ) )+ABS( E( I-1 ) )
+               IF( ANORM .LT. SUM .OR. SISNAN( SUM ) ) ANORM = SUM
+   20       CONTINUE
+         END IF
+      ELSE IF( ( LSAME( NORM, 'F' ) ) .OR. ( LSAME( NORM, 'E' ) ) ) THEN
+*
+*        Find normF(A).
+*
+         SCALE = ZERO
+         SUM = ONE
+         IF( N.GT.1 ) THEN
+            CALL SLASSQ( N-1, E, 1, SCALE, SUM )
+            SUM = 2*SUM
+         END IF
+         CALL SLASSQ( N, D, 1, SCALE, SUM )
+         ANORM = SCALE*SQRT( SUM )
+      END IF
+*
+      SLANST = ANORM
+      RETURN
+*
+*     End of SLANST
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slansy.f AmberTools/src/quick/src/blas/slansy.f
--- AmberTools/src/quick/src/blas/slansy.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slansy.f	2022-08-30 19:15:50.000000000 +0900
@@ -0,0 +1,263 @@
+*> \brief \b SLANSY returns the value of the 1-norm, or the Frobenius norm, or the infinity norm, or the element of largest absolute value of a real symmetric matrix.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLANSY + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slansy.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slansy.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slansy.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       REAL             FUNCTION SLANSY( NORM, UPLO, N, A, LDA, WORK )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          NORM, UPLO
+*       INTEGER            LDA, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLANSY  returns the value of the one norm,  or the Frobenius norm, or
+*> the  infinity norm,  or the  element of  largest absolute value  of a
+*> real symmetric matrix A.
+*> \endverbatim
+*>
+*> \return SLANSY
+*> \verbatim
+*>
+*>    SLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
+*>             (
+*>             ( norm1(A),         NORM = '1', 'O' or 'o'
+*>             (
+*>             ( normI(A),         NORM = 'I' or 'i'
+*>             (
+*>             ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
+*>
+*> where  norm1  denotes the  one norm of a matrix (maximum column sum),
+*> normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
+*> normF  denotes the  Frobenius norm of a matrix (square root of sum of
+*> squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] NORM
+*> \verbatim
+*>          NORM is CHARACTER*1
+*>          Specifies the value to be returned in SLANSY as described
+*>          above.
+*> \endverbatim
+*>
+*> \param[in] UPLO
+*> \verbatim
+*>          UPLO is CHARACTER*1
+*>          Specifies whether the upper or lower triangular part of the
+*>          symmetric matrix A is to be referenced.
+*>          = 'U':  Upper triangular part of A is referenced
+*>          = 'L':  Lower triangular part of A is referenced
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the matrix A.  N >= 0.  When N = 0, SLANSY is
+*>          set to zero.
+*> \endverbatim
+*>
+*> \param[in] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          The symmetric matrix A.  If UPLO = 'U', the leading n by n
+*>          upper triangular part of A contains the upper triangular part
+*>          of the matrix A, and the strictly lower triangular part of A
+*>          is not referenced.  If UPLO = 'L', the leading n by n lower
+*>          triangular part of A contains the lower triangular part of
+*>          the matrix A, and the strictly upper triangular part of A is
+*>          not referenced.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A.  LDA >= max(N,1).
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (MAX(1,LWORK)),
+*>          where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
+*>          WORK is not referenced.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realSYauxiliary
+*
+*  =====================================================================
+      REAL             FUNCTION SLANSY( NORM, UPLO, N, A, LDA, WORK )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+      IMPLICIT NONE
+*     .. Scalar Arguments ..
+      CHARACTER          NORM, UPLO
+      INTEGER            LDA, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), WORK( * )
+*     ..
+*
+* =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE, ZERO
+      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, J
+      REAL               ABSA, SUM, VALUE
+*     ..
+*     .. Local Arrays ..
+      REAL               SSQ( 2 ), COLSSQ( 2 )
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME, SISNAN
+      EXTERNAL           LSAME, SISNAN
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLASSQ, SCOMBSSQ
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, SQRT
+*     ..
+*     .. Executable Statements ..
+*
+      IF( N.EQ.0 ) THEN
+         VALUE = ZERO
+      ELSE IF( LSAME( NORM, 'M' ) ) THEN
+*
+*        Find max(abs(A(i,j))).
+*
+         VALUE = ZERO
+         IF( LSAME( UPLO, 'U' ) ) THEN
+            DO 20 J = 1, N
+               DO 10 I = 1, J
+                  SUM = ABS( A( I, J ) )
+                  IF( VALUE .LT. SUM .OR. SISNAN( SUM ) ) VALUE = SUM
+   10          CONTINUE
+   20       CONTINUE
+         ELSE
+            DO 40 J = 1, N
+               DO 30 I = J, N
+                  SUM = ABS( A( I, J ) )
+                  IF( VALUE .LT. SUM .OR. SISNAN( SUM ) ) VALUE = SUM
+   30          CONTINUE
+   40       CONTINUE
+         END IF
+      ELSE IF( ( LSAME( NORM, 'I' ) ) .OR. ( LSAME( NORM, 'O' ) ) .OR.
+     $         ( NORM.EQ.'1' ) ) THEN
+*
+*        Find normI(A) ( = norm1(A), since A is symmetric).
+*
+         VALUE = ZERO
+         IF( LSAME( UPLO, 'U' ) ) THEN
+            DO 60 J = 1, N
+               SUM = ZERO
+               DO 50 I = 1, J - 1
+                  ABSA = ABS( A( I, J ) )
+                  SUM = SUM + ABSA
+                  WORK( I ) = WORK( I ) + ABSA
+   50          CONTINUE
+               WORK( J ) = SUM + ABS( A( J, J ) )
+   60       CONTINUE
+            DO 70 I = 1, N
+               SUM = WORK( I )
+               IF( VALUE .LT. SUM .OR. SISNAN( SUM ) ) VALUE = SUM
+   70       CONTINUE
+         ELSE
+            DO 80 I = 1, N
+               WORK( I ) = ZERO
+   80       CONTINUE
+            DO 100 J = 1, N
+               SUM = WORK( J ) + ABS( A( J, J ) )
+               DO 90 I = J + 1, N
+                  ABSA = ABS( A( I, J ) )
+                  SUM = SUM + ABSA
+                  WORK( I ) = WORK( I ) + ABSA
+   90          CONTINUE
+               IF( VALUE .LT. SUM .OR. SISNAN( SUM ) ) VALUE = SUM
+  100       CONTINUE
+         END IF
+      ELSE IF( ( LSAME( NORM, 'F' ) ) .OR. ( LSAME( NORM, 'E' ) ) ) THEN
+*
+*        Find normF(A).
+*        SSQ(1) is scale
+*        SSQ(2) is sum-of-squares
+*        For better accuracy, sum each column separately.
+*
+         SSQ( 1 ) = ZERO
+         SSQ( 2 ) = ONE
+*
+*        Sum off-diagonals
+*
+         IF( LSAME( UPLO, 'U' ) ) THEN
+            DO 110 J = 2, N
+               COLSSQ( 1 ) = ZERO
+               COLSSQ( 2 ) = ONE
+               CALL SLASSQ( J-1, A( 1, J ), 1, COLSSQ(1), COLSSQ(2) )
+               CALL SCOMBSSQ( SSQ, COLSSQ )
+  110       CONTINUE
+         ELSE
+            DO 120 J = 1, N - 1
+               COLSSQ( 1 ) = ZERO
+               COLSSQ( 2 ) = ONE
+               CALL SLASSQ( N-J, A( J+1, J ), 1, COLSSQ(1), COLSSQ(2) )
+               CALL SCOMBSSQ( SSQ, COLSSQ )
+  120       CONTINUE
+         END IF
+         SSQ( 2 ) = 2*SSQ( 2 )
+*
+*        Sum diagonal
+*
+         COLSSQ( 1 ) = ZERO
+         COLSSQ( 2 ) = ONE
+         CALL SLASSQ( N, A, LDA+1, COLSSQ( 1 ), COLSSQ( 2 ) )
+         CALL SCOMBSSQ( SSQ, COLSSQ )
+         VALUE = SSQ( 1 )*SQRT( SSQ( 2 ) )
+      END IF
+*
+      SLANSY = VALUE
+      RETURN
+*
+*     End of SLANSY
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slapy2.f AmberTools/src/quick/src/blas/slapy2.f
--- AmberTools/src/quick/src/blas/slapy2.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slapy2.f	2022-08-30 19:19:40.000000000 +0900
@@ -0,0 +1,119 @@
+*> \brief \b SLAPY2 returns sqrt(x2+y2).
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLAPY2 + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slapy2.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slapy2.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slapy2.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       REAL             FUNCTION SLAPY2( X, Y )
+*
+*       .. Scalar Arguments ..
+*       REAL               X, Y
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary
+*> overflow.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] X
+*> \verbatim
+*>          X is REAL
+*> \endverbatim
+*>
+*> \param[in] Y
+*> \verbatim
+*>          Y is REAL
+*>          X and Y specify the values x and y.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date June 2017
+*
+*> \ingroup OTHERauxiliary
+*
+*  =====================================================================
+      REAL             FUNCTION SLAPY2( X, Y )
+*
+*  -- LAPACK auxiliary routine (version 3.7.1) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     June 2017
+*
+*     .. Scalar Arguments ..
+      REAL               X, Y
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO
+      PARAMETER          ( ZERO = 0.0E0 )
+      REAL               ONE
+      PARAMETER          ( ONE = 1.0E0 )
+*     ..
+*     .. Local Scalars ..
+      REAL               W, XABS, YABS, Z
+      LOGICAL            X_IS_NAN, Y_IS_NAN
+*     ..
+*     .. External Functions ..
+      LOGICAL            SISNAN
+      EXTERNAL           SISNAN
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, MAX, MIN, SQRT
+*     ..
+*     .. Executable Statements ..
+*
+*     ..
+*     .. Executable Statements ..
+*
+      X_IS_NAN = SISNAN( X )
+      Y_IS_NAN = SISNAN( Y )
+      IF ( X_IS_NAN ) SLAPY2 = X
+      IF ( Y_IS_NAN ) SLAPY2 = Y
+*
+      IF ( .NOT.( X_IS_NAN.OR.Y_IS_NAN ) ) THEN
+         XABS = ABS( X )
+         YABS = ABS( Y )
+         W = MAX( XABS, YABS )
+         Z = MIN( XABS, YABS )
+         IF( Z.EQ.ZERO ) THEN
+            SLAPY2 = W
+         ELSE
+            SLAPY2 = W*SQRT( ONE+( Z / W )**2 )
+         END IF
+      END IF
+      RETURN
+*
+*     End of SLAPY2
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slarf.f AmberTools/src/quick/src/blas/slarf.f
--- AmberTools/src/quick/src/blas/slarf.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slarf.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,227 @@
+*> \brief \b SLARF applies an elementary reflector to a general rectangular matrix.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLARF + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarf.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarf.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarf.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          SIDE
+*       INTEGER            INCV, LDC, M, N
+*       REAL               TAU
+*       ..
+*       .. Array Arguments ..
+*       REAL               C( LDC, * ), V( * ), WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLARF applies a real elementary reflector H to a real m by n matrix
+*> C, from either the left or the right. H is represented in the form
+*>
+*>       H = I - tau * v * v**T
+*>
+*> where tau is a real scalar and v is a real vector.
+*>
+*> If tau = 0, then H is taken to be the unit matrix.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] SIDE
+*> \verbatim
+*>          SIDE is CHARACTER*1
+*>          = 'L': form  H * C
+*>          = 'R': form  C * H
+*> \endverbatim
+*>
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix C.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix C.
+*> \endverbatim
+*>
+*> \param[in] V
+*> \verbatim
+*>          V is REAL array, dimension
+*>                     (1 + (M-1)*abs(INCV)) if SIDE = 'L'
+*>                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
+*>          The vector v in the representation of H. V is not used if
+*>          TAU = 0.
+*> \endverbatim
+*>
+*> \param[in] INCV
+*> \verbatim
+*>          INCV is INTEGER
+*>          The increment between elements of v. INCV <> 0.
+*> \endverbatim
+*>
+*> \param[in] TAU
+*> \verbatim
+*>          TAU is REAL
+*>          The value tau in the representation of H.
+*> \endverbatim
+*>
+*> \param[in,out] C
+*> \verbatim
+*>          C is REAL array, dimension (LDC,N)
+*>          On entry, the m by n matrix C.
+*>          On exit, C is overwritten by the matrix H * C if SIDE = 'L',
+*>          or C * H if SIDE = 'R'.
+*> \endverbatim
+*>
+*> \param[in] LDC
+*> \verbatim
+*>          LDC is INTEGER
+*>          The leading dimension of the array C. LDC >= max(1,M).
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension
+*>                         (N) if SIDE = 'L'
+*>                      or (M) if SIDE = 'R'
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERauxiliary
+*
+*  =====================================================================
+      SUBROUTINE SLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          SIDE
+      INTEGER            INCV, LDC, M, N
+      REAL               TAU
+*     ..
+*     .. Array Arguments ..
+      REAL               C( LDC, * ), V( * ), WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE, ZERO
+      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            APPLYLEFT
+      INTEGER            I, LASTV, LASTC
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SGEMV, SGER
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      INTEGER            ILASLR, ILASLC
+      EXTERNAL           LSAME, ILASLR, ILASLC
+*     ..
+*     .. Executable Statements ..
+*
+      APPLYLEFT = LSAME( SIDE, 'L' )
+      LASTV = 0
+      LASTC = 0
+      IF( TAU.NE.ZERO ) THEN
+!     Set up variables for scanning V.  LASTV begins pointing to the end
+!     of V.
+         IF( APPLYLEFT ) THEN
+            LASTV = M
+         ELSE
+            LASTV = N
+         END IF
+         IF( INCV.GT.0 ) THEN
+            I = 1 + (LASTV-1) * INCV
+         ELSE
+            I = 1
+         END IF
+!     Look for the last non-zero row in V.
+         DO WHILE( LASTV.GT.0 .AND. V( I ).EQ.ZERO )
+            LASTV = LASTV - 1
+            I = I - INCV
+         END DO
+         IF( APPLYLEFT ) THEN
+!     Scan for the last non-zero column in C(1:lastv,:).
+            LASTC = ILASLC(LASTV, N, C, LDC)
+         ELSE
+!     Scan for the last non-zero row in C(:,1:lastv).
+            LASTC = ILASLR(M, LASTV, C, LDC)
+         END IF
+      END IF
+!     Note that lastc.eq.0 renders the BLAS operations null; no special
+!     case is needed at this level.
+      IF( APPLYLEFT ) THEN
+*
+*        Form  H * C
+*
+         IF( LASTV.GT.0 ) THEN
+*
+*           w(1:lastc,1) := C(1:lastv,1:lastc)**T * v(1:lastv,1)
+*
+            CALL SGEMV( 'Transpose', LASTV, LASTC, ONE, C, LDC, V, INCV,
+     $           ZERO, WORK, 1 )
+*
+*           C(1:lastv,1:lastc) := C(...) - v(1:lastv,1) * w(1:lastc,1)**T
+*
+            CALL SGER( LASTV, LASTC, -TAU, V, INCV, WORK, 1, C, LDC )
+         END IF
+      ELSE
+*
+*        Form  C * H
+*
+         IF( LASTV.GT.0 ) THEN
+*
+*           w(1:lastc,1) := C(1:lastc,1:lastv) * v(1:lastv,1)
+*
+            CALL SGEMV( 'No transpose', LASTC, LASTV, ONE, C, LDC,
+     $           V, INCV, ZERO, WORK, 1 )
+*
+*           C(1:lastc,1:lastv) := C(...) - w(1:lastc,1) * v(1:lastv,1)**T
+*
+            CALL SGER( LASTC, LASTV, -TAU, WORK, 1, V, INCV, C, LDC )
+         END IF
+      END IF
+      RETURN
+*
+*     End of SLARF
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slarfb.f AmberTools/src/quick/src/blas/slarfb.f
--- AmberTools/src/quick/src/blas/slarfb.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slarfb.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,712 @@
+*> \brief \b SLARFB applies a block reflector or its transpose to a general rectangular matrix.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLARFB + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarfb.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarfb.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarfb.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV,
+*                          T, LDT, C, LDC, WORK, LDWORK )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          DIRECT, SIDE, STOREV, TRANS
+*       INTEGER            K, LDC, LDT, LDV, LDWORK, M, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               C( LDC, * ), T( LDT, * ), V( LDV, * ),
+*      $                   WORK( LDWORK, * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLARFB applies a real block reflector H or its transpose H**T to a
+*> real m by n matrix C, from either the left or the right.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] SIDE
+*> \verbatim
+*>          SIDE is CHARACTER*1
+*>          = 'L': apply H or H**T from the Left
+*>          = 'R': apply H or H**T from the Right
+*> \endverbatim
+*>
+*> \param[in] TRANS
+*> \verbatim
+*>          TRANS is CHARACTER*1
+*>          = 'N': apply H (No transpose)
+*>          = 'T': apply H**T (Transpose)
+*> \endverbatim
+*>
+*> \param[in] DIRECT
+*> \verbatim
+*>          DIRECT is CHARACTER*1
+*>          Indicates how H is formed from a product of elementary
+*>          reflectors
+*>          = 'F': H = H(1) H(2) . . . H(k) (Forward)
+*>          = 'B': H = H(k) . . . H(2) H(1) (Backward)
+*> \endverbatim
+*>
+*> \param[in] STOREV
+*> \verbatim
+*>          STOREV is CHARACTER*1
+*>          Indicates how the vectors which define the elementary
+*>          reflectors are stored:
+*>          = 'C': Columnwise
+*>          = 'R': Rowwise
+*> \endverbatim
+*>
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix C.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix C.
+*> \endverbatim
+*>
+*> \param[in] K
+*> \verbatim
+*>          K is INTEGER
+*>          The order of the matrix T (= the number of elementary
+*>          reflectors whose product defines the block reflector).
+*>          If SIDE = 'L', M >= K >= 0;
+*>          if SIDE = 'R', N >= K >= 0.
+*> \endverbatim
+*>
+*> \param[in] V
+*> \verbatim
+*>          V is REAL array, dimension
+*>                                (LDV,K) if STOREV = 'C'
+*>                                (LDV,M) if STOREV = 'R' and SIDE = 'L'
+*>                                (LDV,N) if STOREV = 'R' and SIDE = 'R'
+*>          The matrix V. See Further Details.
+*> \endverbatim
+*>
+*> \param[in] LDV
+*> \verbatim
+*>          LDV is INTEGER
+*>          The leading dimension of the array V.
+*>          If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
+*>          if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
+*>          if STOREV = 'R', LDV >= K.
+*> \endverbatim
+*>
+*> \param[in] T
+*> \verbatim
+*>          T is REAL array, dimension (LDT,K)
+*>          The triangular k by k matrix T in the representation of the
+*>          block reflector.
+*> \endverbatim
+*>
+*> \param[in] LDT
+*> \verbatim
+*>          LDT is INTEGER
+*>          The leading dimension of the array T. LDT >= K.
+*> \endverbatim
+*>
+*> \param[in,out] C
+*> \verbatim
+*>          C is REAL array, dimension (LDC,N)
+*>          On entry, the m by n matrix C.
+*>          On exit, C is overwritten by H*C or H**T*C or C*H or C*H**T.
+*> \endverbatim
+*>
+*> \param[in] LDC
+*> \verbatim
+*>          LDC is INTEGER
+*>          The leading dimension of the array C. LDC >= max(1,M).
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (LDWORK,K)
+*> \endverbatim
+*>
+*> \param[in] LDWORK
+*> \verbatim
+*>          LDWORK is INTEGER
+*>          The leading dimension of the array WORK.
+*>          If SIDE = 'L', LDWORK >= max(1,N);
+*>          if SIDE = 'R', LDWORK >= max(1,M).
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date June 2013
+*
+*> \ingroup realOTHERauxiliary
+*
+*> \par Further Details:
+*  =====================
+*>
+*> \verbatim
+*>
+*>  The shape of the matrix V and the storage of the vectors which define
+*>  the H(i) is best illustrated by the following example with n = 5 and
+*>  k = 3. The elements equal to 1 are not stored; the corresponding
+*>  array elements are modified but restored on exit. The rest of the
+*>  array is not used.
+*>
+*>  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
+*>
+*>               V = (  1       )                 V = (  1 v1 v1 v1 v1 )
+*>                   ( v1  1    )                     (     1 v2 v2 v2 )
+*>                   ( v1 v2  1 )                     (        1 v3 v3 )
+*>                   ( v1 v2 v3 )
+*>                   ( v1 v2 v3 )
+*>
+*>  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
+*>
+*>               V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
+*>                   ( v1 v2 v3 )                     ( v2 v2 v2  1    )
+*>                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
+*>                   (     1 v3 )
+*>                   (        1 )
+*> \endverbatim
+*>
+*  =====================================================================
+      SUBROUTINE SLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV,
+     $                   T, LDT, C, LDC, WORK, LDWORK )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     June 2013
+*
+*     .. Scalar Arguments ..
+      CHARACTER          DIRECT, SIDE, STOREV, TRANS
+      INTEGER            K, LDC, LDT, LDV, LDWORK, M, N
+*     ..
+*     .. Array Arguments ..
+      REAL               C( LDC, * ), T( LDT, * ), V( LDV, * ),
+     $                   WORK( LDWORK, * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE
+      PARAMETER          ( ONE = 1.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      CHARACTER          TRANST
+      INTEGER            I, J
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      EXTERNAL           LSAME
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SCOPY, SGEMM, STRMM
+*     ..
+*     .. Executable Statements ..
+*
+*     Quick return if possible
+*
+      IF( M.LE.0 .OR. N.LE.0 )
+     $   RETURN
+*
+      IF( LSAME( TRANS, 'N' ) ) THEN
+         TRANST = 'T'
+      ELSE
+         TRANST = 'N'
+      END IF
+*
+      IF( LSAME( STOREV, 'C' ) ) THEN
+*
+         IF( LSAME( DIRECT, 'F' ) ) THEN
+*
+*           Let  V =  ( V1 )    (first K rows)
+*                     ( V2 )
+*           where  V1  is unit lower triangular.
+*
+            IF( LSAME( SIDE, 'L' ) ) THEN
+*
+*              Form  H * C  or  H**T * C  where  C = ( C1 )
+*                                                    ( C2 )
+*
+*              W := C**T * V  =  (C1**T * V1 + C2**T * V2)  (stored in WORK)
+*
+*              W := C1**T
+*
+               DO 10 J = 1, K
+                  CALL SCOPY( N, C( J, 1 ), LDC, WORK( 1, J ), 1 )
+   10          CONTINUE
+*
+*              W := W * V1
+*
+               CALL STRMM( 'Right', 'Lower', 'No transpose', 'Unit', N,
+     $                     K, ONE, V, LDV, WORK, LDWORK )
+               IF( M.GT.K ) THEN
+*
+*                 W := W + C2**T * V2
+*
+                  CALL SGEMM( 'Transpose', 'No transpose', N, K, M-K,
+     $                        ONE, C( K+1, 1 ), LDC, V( K+1, 1 ), LDV,
+     $                        ONE, WORK, LDWORK )
+               END IF
+*
+*              W := W * T**T  or  W * T
+*
+               CALL STRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K,
+     $                     ONE, T, LDT, WORK, LDWORK )
+*
+*              C := C - V * W**T
+*
+               IF( M.GT.K ) THEN
+*
+*                 C2 := C2 - V2 * W**T
+*
+                  CALL SGEMM( 'No transpose', 'Transpose', M-K, N, K,
+     $                        -ONE, V( K+1, 1 ), LDV, WORK, LDWORK, ONE,
+     $                        C( K+1, 1 ), LDC )
+               END IF
+*
+*              W := W * V1**T
+*
+               CALL STRMM( 'Right', 'Lower', 'Transpose', 'Unit', N, K,
+     $                     ONE, V, LDV, WORK, LDWORK )
+*
+*              C1 := C1 - W**T
+*
+               DO 30 J = 1, K
+                  DO 20 I = 1, N
+                     C( J, I ) = C( J, I ) - WORK( I, J )
+   20             CONTINUE
+   30          CONTINUE
+*
+            ELSE IF( LSAME( SIDE, 'R' ) ) THEN
+*
+*              Form  C * H  or  C * H**T  where  C = ( C1  C2 )
+*
+*              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
+*
+*              W := C1
+*
+               DO 40 J = 1, K
+                  CALL SCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 )
+   40          CONTINUE
+*
+*              W := W * V1
+*
+               CALL STRMM( 'Right', 'Lower', 'No transpose', 'Unit', M,
+     $                     K, ONE, V, LDV, WORK, LDWORK )
+               IF( N.GT.K ) THEN
+*
+*                 W := W + C2 * V2
+*
+                  CALL SGEMM( 'No transpose', 'No transpose', M, K, N-K,
+     $                        ONE, C( 1, K+1 ), LDC, V( K+1, 1 ), LDV,
+     $                        ONE, WORK, LDWORK )
+               END IF
+*
+*              W := W * T  or  W * T**T
+*
+               CALL STRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K,
+     $                     ONE, T, LDT, WORK, LDWORK )
+*
+*              C := C - W * V**T
+*
+               IF( N.GT.K ) THEN
+*
+*                 C2 := C2 - W * V2**T
+*
+                  CALL SGEMM( 'No transpose', 'Transpose', M, N-K, K,
+     $                        -ONE, WORK, LDWORK, V( K+1, 1 ), LDV, ONE,
+     $                        C( 1, K+1 ), LDC )
+               END IF
+*
+*              W := W * V1**T
+*
+               CALL STRMM( 'Right', 'Lower', 'Transpose', 'Unit', M, K,
+     $                     ONE, V, LDV, WORK, LDWORK )
+*
+*              C1 := C1 - W
+*
+               DO 60 J = 1, K
+                  DO 50 I = 1, M
+                     C( I, J ) = C( I, J ) - WORK( I, J )
+   50             CONTINUE
+   60          CONTINUE
+            END IF
+*
+         ELSE
+*
+*           Let  V =  ( V1 )
+*                     ( V2 )    (last K rows)
+*           where  V2  is unit upper triangular.
+*
+            IF( LSAME( SIDE, 'L' ) ) THEN
+*
+*              Form  H * C  or  H**T * C  where  C = ( C1 )
+*                                                    ( C2 )
+*
+*              W := C**T * V  =  (C1**T * V1 + C2**T * V2)  (stored in WORK)
+*
+*              W := C2**T
+*
+               DO 70 J = 1, K
+                  CALL SCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 )
+   70          CONTINUE
+*
+*              W := W * V2
+*
+               CALL STRMM( 'Right', 'Upper', 'No transpose', 'Unit', N,
+     $                     K, ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )
+               IF( M.GT.K ) THEN
+*
+*                 W := W + C1**T * V1
+*
+                  CALL SGEMM( 'Transpose', 'No transpose', N, K, M-K,
+     $                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
+               END IF
+*
+*              W := W * T**T  or  W * T
+*
+               CALL STRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K,
+     $                     ONE, T, LDT, WORK, LDWORK )
+*
+*              C := C - V * W**T
+*
+               IF( M.GT.K ) THEN
+*
+*                 C1 := C1 - V1 * W**T
+*
+                  CALL SGEMM( 'No transpose', 'Transpose', M-K, N, K,
+     $                        -ONE, V, LDV, WORK, LDWORK, ONE, C, LDC )
+               END IF
+*
+*              W := W * V2**T
+*
+               CALL STRMM( 'Right', 'Upper', 'Transpose', 'Unit', N, K,
+     $                     ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )
+*
+*              C2 := C2 - W**T
+*
+               DO 90 J = 1, K
+                  DO 80 I = 1, N
+                     C( M-K+J, I ) = C( M-K+J, I ) - WORK( I, J )
+   80             CONTINUE
+   90          CONTINUE
+*
+            ELSE IF( LSAME( SIDE, 'R' ) ) THEN
+*
+*              Form  C * H  or  C * H'  where  C = ( C1  C2 )
+*
+*              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)
+*
+*              W := C2
+*
+               DO 100 J = 1, K
+                  CALL SCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 )
+  100          CONTINUE
+*
+*              W := W * V2
+*
+               CALL STRMM( 'Right', 'Upper', 'No transpose', 'Unit', M,
+     $                     K, ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )
+               IF( N.GT.K ) THEN
+*
+*                 W := W + C1 * V1
+*
+                  CALL SGEMM( 'No transpose', 'No transpose', M, K, N-K,
+     $                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
+               END IF
+*
+*              W := W * T  or  W * T**T
+*
+               CALL STRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K,
+     $                     ONE, T, LDT, WORK, LDWORK )
+*
+*              C := C - W * V**T
+*
+               IF( N.GT.K ) THEN
+*
+*                 C1 := C1 - W * V1**T
+*
+                  CALL SGEMM( 'No transpose', 'Transpose', M, N-K, K,
+     $                        -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC )
+               END IF
+*
+*              W := W * V2**T
+*
+               CALL STRMM( 'Right', 'Upper', 'Transpose', 'Unit', M, K,
+     $                     ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )
+*
+*              C2 := C2 - W
+*
+               DO 120 J = 1, K
+                  DO 110 I = 1, M
+                     C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J )
+  110             CONTINUE
+  120          CONTINUE
+            END IF
+         END IF
+*
+      ELSE IF( LSAME( STOREV, 'R' ) ) THEN
+*
+         IF( LSAME( DIRECT, 'F' ) ) THEN
+*
+*           Let  V =  ( V1  V2 )    (V1: first K columns)
+*           where  V1  is unit upper triangular.
+*
+            IF( LSAME( SIDE, 'L' ) ) THEN
+*
+*              Form  H * C  or  H**T * C  where  C = ( C1 )
+*                                                    ( C2 )
+*
+*              W := C**T * V**T  =  (C1**T * V1**T + C2**T * V2**T) (stored in WORK)
+*
+*              W := C1**T
+*
+               DO 130 J = 1, K
+                  CALL SCOPY( N, C( J, 1 ), LDC, WORK( 1, J ), 1 )
+  130          CONTINUE
+*
+*              W := W * V1**T
+*
+               CALL STRMM( 'Right', 'Upper', 'Transpose', 'Unit', N, K,
+     $                     ONE, V, LDV, WORK, LDWORK )
+               IF( M.GT.K ) THEN
+*
+*                 W := W + C2**T * V2**T
+*
+                  CALL SGEMM( 'Transpose', 'Transpose', N, K, M-K, ONE,
+     $                        C( K+1, 1 ), LDC, V( 1, K+1 ), LDV, ONE,
+     $                        WORK, LDWORK )
+               END IF
+*
+*              W := W * T**T  or  W * T
+*
+               CALL STRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K,
+     $                     ONE, T, LDT, WORK, LDWORK )
+*
+*              C := C - V**T * W**T
+*
+               IF( M.GT.K ) THEN
+*
+*                 C2 := C2 - V2**T * W**T
+*
+                  CALL SGEMM( 'Transpose', 'Transpose', M-K, N, K, -ONE,
+     $                        V( 1, K+1 ), LDV, WORK, LDWORK, ONE,
+     $                        C( K+1, 1 ), LDC )
+               END IF
+*
+*              W := W * V1
+*
+               CALL STRMM( 'Right', 'Upper', 'No transpose', 'Unit', N,
+     $                     K, ONE, V, LDV, WORK, LDWORK )
+*
+*              C1 := C1 - W**T
+*
+               DO 150 J = 1, K
+                  DO 140 I = 1, N
+                     C( J, I ) = C( J, I ) - WORK( I, J )
+  140             CONTINUE
+  150          CONTINUE
+*
+            ELSE IF( LSAME( SIDE, 'R' ) ) THEN
+*
+*              Form  C * H  or  C * H**T  where  C = ( C1  C2 )
+*
+*              W := C * V**T  =  (C1*V1**T + C2*V2**T)  (stored in WORK)
+*
+*              W := C1
+*
+               DO 160 J = 1, K
+                  CALL SCOPY( M, C( 1, J ), 1, WORK( 1, J ), 1 )
+  160          CONTINUE
+*
+*              W := W * V1**T
+*
+               CALL STRMM( 'Right', 'Upper', 'Transpose', 'Unit', M, K,
+     $                     ONE, V, LDV, WORK, LDWORK )
+               IF( N.GT.K ) THEN
+*
+*                 W := W + C2 * V2**T
+*
+                  CALL SGEMM( 'No transpose', 'Transpose', M, K, N-K,
+     $                        ONE, C( 1, K+1 ), LDC, V( 1, K+1 ), LDV,
+     $                        ONE, WORK, LDWORK )
+               END IF
+*
+*              W := W * T  or  W * T**T
+*
+               CALL STRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K,
+     $                     ONE, T, LDT, WORK, LDWORK )
+*
+*              C := C - W * V
+*
+               IF( N.GT.K ) THEN
+*
+*                 C2 := C2 - W * V2
+*
+                  CALL SGEMM( 'No transpose', 'No transpose', M, N-K, K,
+     $                        -ONE, WORK, LDWORK, V( 1, K+1 ), LDV, ONE,
+     $                        C( 1, K+1 ), LDC )
+               END IF
+*
+*              W := W * V1
+*
+               CALL STRMM( 'Right', 'Upper', 'No transpose', 'Unit', M,
+     $                     K, ONE, V, LDV, WORK, LDWORK )
+*
+*              C1 := C1 - W
+*
+               DO 180 J = 1, K
+                  DO 170 I = 1, M
+                     C( I, J ) = C( I, J ) - WORK( I, J )
+  170             CONTINUE
+  180          CONTINUE
+*
+            END IF
+*
+         ELSE
+*
+*           Let  V =  ( V1  V2 )    (V2: last K columns)
+*           where  V2  is unit lower triangular.
+*
+            IF( LSAME( SIDE, 'L' ) ) THEN
+*
+*              Form  H * C  or  H**T * C  where  C = ( C1 )
+*                                                    ( C2 )
+*
+*              W := C**T * V**T  =  (C1**T * V1**T + C2**T * V2**T) (stored in WORK)
+*
+*              W := C2**T
+*
+               DO 190 J = 1, K
+                  CALL SCOPY( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 )
+  190          CONTINUE
+*
+*              W := W * V2**T
+*
+               CALL STRMM( 'Right', 'Lower', 'Transpose', 'Unit', N, K,
+     $                     ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )
+               IF( M.GT.K ) THEN
+*
+*                 W := W + C1**T * V1**T
+*
+                  CALL SGEMM( 'Transpose', 'Transpose', N, K, M-K, ONE,
+     $                        C, LDC, V, LDV, ONE, WORK, LDWORK )
+               END IF
+*
+*              W := W * T**T  or  W * T
+*
+               CALL STRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K,
+     $                     ONE, T, LDT, WORK, LDWORK )
+*
+*              C := C - V**T * W**T
+*
+               IF( M.GT.K ) THEN
+*
+*                 C1 := C1 - V1**T * W**T
+*
+                  CALL SGEMM( 'Transpose', 'Transpose', M-K, N, K, -ONE,
+     $                        V, LDV, WORK, LDWORK, ONE, C, LDC )
+               END IF
+*
+*              W := W * V2
+*
+               CALL STRMM( 'Right', 'Lower', 'No transpose', 'Unit', N,
+     $                     K, ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )
+*
+*              C2 := C2 - W**T
+*
+               DO 210 J = 1, K
+                  DO 200 I = 1, N
+                     C( M-K+J, I ) = C( M-K+J, I ) - WORK( I, J )
+  200             CONTINUE
+  210          CONTINUE
+*
+            ELSE IF( LSAME( SIDE, 'R' ) ) THEN
+*
+*              Form  C * H  or  C * H**T  where  C = ( C1  C2 )
+*
+*              W := C * V**T  =  (C1*V1**T + C2*V2**T)  (stored in WORK)
+*
+*              W := C2
+*
+               DO 220 J = 1, K
+                  CALL SCOPY( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 )
+  220          CONTINUE
+*
+*              W := W * V2**T
+*
+               CALL STRMM( 'Right', 'Lower', 'Transpose', 'Unit', M, K,
+     $                     ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )
+               IF( N.GT.K ) THEN
+*
+*                 W := W + C1 * V1**T
+*
+                  CALL SGEMM( 'No transpose', 'Transpose', M, K, N-K,
+     $                        ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )
+               END IF
+*
+*              W := W * T  or  W * T**T
+*
+               CALL STRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K,
+     $                     ONE, T, LDT, WORK, LDWORK )
+*
+*              C := C - W * V
+*
+               IF( N.GT.K ) THEN
+*
+*                 C1 := C1 - W * V1
+*
+                  CALL SGEMM( 'No transpose', 'No transpose', M, N-K, K,
+     $                        -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC )
+               END IF
+*
+*              W := W * V2
+*
+               CALL STRMM( 'Right', 'Lower', 'No transpose', 'Unit', M,
+     $                     K, ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )
+*
+*              C1 := C1 - W
+*
+               DO 240 J = 1, K
+                  DO 230 I = 1, M
+                     C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J )
+  230             CONTINUE
+  240          CONTINUE
+*
+            END IF
+*
+         END IF
+      END IF
+*
+      RETURN
+*
+*     End of SLARFB
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slarfg.f AmberTools/src/quick/src/blas/slarfg.f
--- AmberTools/src/quick/src/blas/slarfg.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slarfg.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,196 @@
+*> \brief \b SLARFG generates an elementary reflector (Householder matrix).
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLARFG + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarfg.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarfg.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarfg.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLARFG( N, ALPHA, X, INCX, TAU )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            INCX, N
+*       REAL               ALPHA, TAU
+*       ..
+*       .. Array Arguments ..
+*       REAL               X( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLARFG generates a real elementary reflector H of order n, such
+*> that
+*>
+*>       H * ( alpha ) = ( beta ),   H**T * H = I.
+*>           (   x   )   (   0  )
+*>
+*> where alpha and beta are scalars, and x is an (n-1)-element real
+*> vector. H is represented in the form
+*>
+*>       H = I - tau * ( 1 ) * ( 1 v**T ) ,
+*>                     ( v )
+*>
+*> where tau is a real scalar and v is a real (n-1)-element
+*> vector.
+*>
+*> If the elements of x are all zero, then tau = 0 and H is taken to be
+*> the unit matrix.
+*>
+*> Otherwise  1 <= tau <= 2.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the elementary reflector.
+*> \endverbatim
+*>
+*> \param[in,out] ALPHA
+*> \verbatim
+*>          ALPHA is REAL
+*>          On entry, the value alpha.
+*>          On exit, it is overwritten with the value beta.
+*> \endverbatim
+*>
+*> \param[in,out] X
+*> \verbatim
+*>          X is REAL array, dimension
+*>                         (1+(N-2)*abs(INCX))
+*>          On entry, the vector x.
+*>          On exit, it is overwritten with the vector v.
+*> \endverbatim
+*>
+*> \param[in] INCX
+*> \verbatim
+*>          INCX is INTEGER
+*>          The increment between elements of X. INCX > 0.
+*> \endverbatim
+*>
+*> \param[out] TAU
+*> \verbatim
+*>          TAU is REAL
+*>          The value tau.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date November 2017
+*
+*> \ingroup realOTHERauxiliary
+*
+*  =====================================================================
+      SUBROUTINE SLARFG( N, ALPHA, X, INCX, TAU )
+*
+*  -- LAPACK auxiliary routine (version 3.8.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     November 2017
+*
+*     .. Scalar Arguments ..
+      INTEGER            INCX, N
+      REAL               ALPHA, TAU
+*     ..
+*     .. Array Arguments ..
+      REAL               X( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE, ZERO
+      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            J, KNT
+      REAL               BETA, RSAFMN, SAFMIN, XNORM
+*     ..
+*     .. External Functions ..
+      REAL               SLAMCH, SLAPY2, SNRM2
+      EXTERNAL           SLAMCH, SLAPY2, SNRM2
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, SIGN
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SSCAL
+*     ..
+*     .. Executable Statements ..
+*
+      IF( N.LE.1 ) THEN
+         TAU = ZERO
+         RETURN
+      END IF
+*
+      XNORM = SNRM2( N-1, X, INCX )
+*
+      IF( XNORM.EQ.ZERO ) THEN
+*
+*        H  =  I
+*
+         TAU = ZERO
+      ELSE
+*
+*        general case
+*
+         BETA = -SIGN( SLAPY2( ALPHA, XNORM ), ALPHA )
+         SAFMIN = SLAMCH( 'S' ) / SLAMCH( 'E' )
+         KNT = 0
+         IF( ABS( BETA ).LT.SAFMIN ) THEN
+*
+*           XNORM, BETA may be inaccurate; scale X and recompute them
+*
+            RSAFMN = ONE / SAFMIN
+   10       CONTINUE
+            KNT = KNT + 1
+            CALL SSCAL( N-1, RSAFMN, X, INCX )
+            BETA = BETA*RSAFMN
+            ALPHA = ALPHA*RSAFMN
+            IF( (ABS( BETA ).LT.SAFMIN) .AND. (KNT .LT. 20) )
+     $         GO TO 10
+*
+*           New BETA is at most 1, at least SAFMIN
+*
+            XNORM = SNRM2( N-1, X, INCX )
+            BETA = -SIGN( SLAPY2( ALPHA, XNORM ), ALPHA )
+         END IF
+         TAU = ( BETA-ALPHA ) / BETA
+         CALL SSCAL( N-1, ONE / ( ALPHA-BETA ), X, INCX )
+*
+*        If ALPHA is subnormal, it may lose relative accuracy
+*
+         DO 20 J = 1, KNT
+            BETA = BETA*SAFMIN
+ 20      CONTINUE
+         ALPHA = BETA
+      END IF
+*
+      RETURN
+*
+*     End of SLARFG
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slarft.f AmberTools/src/quick/src/blas/slarft.f
--- AmberTools/src/quick/src/blas/slarft.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slarft.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,326 @@
+*> \brief \b SLARFT forms the triangular factor T of a block reflector H = I - vtvH
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLARFT + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarft.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarft.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarft.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          DIRECT, STOREV
+*       INTEGER            K, LDT, LDV, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               T( LDT, * ), TAU( * ), V( LDV, * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLARFT forms the triangular factor T of a real block reflector H
+*> of order n, which is defined as a product of k elementary reflectors.
+*>
+*> If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
+*>
+*> If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
+*>
+*> If STOREV = 'C', the vector which defines the elementary reflector
+*> H(i) is stored in the i-th column of the array V, and
+*>
+*>    H  =  I - V * T * V**T
+*>
+*> If STOREV = 'R', the vector which defines the elementary reflector
+*> H(i) is stored in the i-th row of the array V, and
+*>
+*>    H  =  I - V**T * T * V
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] DIRECT
+*> \verbatim
+*>          DIRECT is CHARACTER*1
+*>          Specifies the order in which the elementary reflectors are
+*>          multiplied to form the block reflector:
+*>          = 'F': H = H(1) H(2) . . . H(k) (Forward)
+*>          = 'B': H = H(k) . . . H(2) H(1) (Backward)
+*> \endverbatim
+*>
+*> \param[in] STOREV
+*> \verbatim
+*>          STOREV is CHARACTER*1
+*>          Specifies how the vectors which define the elementary
+*>          reflectors are stored (see also Further Details):
+*>          = 'C': columnwise
+*>          = 'R': rowwise
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the block reflector H. N >= 0.
+*> \endverbatim
+*>
+*> \param[in] K
+*> \verbatim
+*>          K is INTEGER
+*>          The order of the triangular factor T (= the number of
+*>          elementary reflectors). K >= 1.
+*> \endverbatim
+*>
+*> \param[in] V
+*> \verbatim
+*>          V is REAL array, dimension
+*>                               (LDV,K) if STOREV = 'C'
+*>                               (LDV,N) if STOREV = 'R'
+*>          The matrix V. See further details.
+*> \endverbatim
+*>
+*> \param[in] LDV
+*> \verbatim
+*>          LDV is INTEGER
+*>          The leading dimension of the array V.
+*>          If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
+*> \endverbatim
+*>
+*> \param[in] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension (K)
+*>          TAU(i) must contain the scalar factor of the elementary
+*>          reflector H(i).
+*> \endverbatim
+*>
+*> \param[out] T
+*> \verbatim
+*>          T is REAL array, dimension (LDT,K)
+*>          The k by k triangular factor T of the block reflector.
+*>          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
+*>          lower triangular. The rest of the array is not used.
+*> \endverbatim
+*>
+*> \param[in] LDT
+*> \verbatim
+*>          LDT is INTEGER
+*>          The leading dimension of the array T. LDT >= K.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERauxiliary
+*
+*> \par Further Details:
+*  =====================
+*>
+*> \verbatim
+*>
+*>  The shape of the matrix V and the storage of the vectors which define
+*>  the H(i) is best illustrated by the following example with n = 5 and
+*>  k = 3. The elements equal to 1 are not stored.
+*>
+*>  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
+*>
+*>               V = (  1       )                 V = (  1 v1 v1 v1 v1 )
+*>                   ( v1  1    )                     (     1 v2 v2 v2 )
+*>                   ( v1 v2  1 )                     (        1 v3 v3 )
+*>                   ( v1 v2 v3 )
+*>                   ( v1 v2 v3 )
+*>
+*>  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
+*>
+*>               V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
+*>                   ( v1 v2 v3 )                     ( v2 v2 v2  1    )
+*>                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
+*>                   (     1 v3 )
+*>                   (        1 )
+*> \endverbatim
+*>
+*  =====================================================================
+      SUBROUTINE SLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          DIRECT, STOREV
+      INTEGER            K, LDT, LDV, N
+*     ..
+*     .. Array Arguments ..
+      REAL               T( LDT, * ), TAU( * ), V( LDV, * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE, ZERO
+      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, J, PREVLASTV, LASTV
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SGEMV, STRMV
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      EXTERNAL           LSAME
+*     ..
+*     .. Executable Statements ..
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 )
+     $   RETURN
+*
+      IF( LSAME( DIRECT, 'F' ) ) THEN
+         PREVLASTV = N
+         DO I = 1, K
+            PREVLASTV = MAX( I, PREVLASTV )
+            IF( TAU( I ).EQ.ZERO ) THEN
+*
+*              H(i)  =  I
+*
+               DO J = 1, I
+                  T( J, I ) = ZERO
+               END DO
+            ELSE
+*
+*              general case
+*
+               IF( LSAME( STOREV, 'C' ) ) THEN
+*                 Skip any trailing zeros.
+                  DO LASTV = N, I+1, -1
+                     IF( V( LASTV, I ).NE.ZERO ) EXIT
+                  END DO
+                  DO J = 1, I-1
+                     T( J, I ) = -TAU( I ) * V( I , J )
+                  END DO
+                  J = MIN( LASTV, PREVLASTV )
+*
+*                 T(1:i-1,i) := - tau(i) * V(i:j,1:i-1)**T * V(i:j,i)
+*
+                  CALL SGEMV( 'Transpose', J-I, I-1, -TAU( I ),
+     $                        V( I+1, 1 ), LDV, V( I+1, I ), 1, ONE,
+     $                        T( 1, I ), 1 )
+               ELSE
+*                 Skip any trailing zeros.
+                  DO LASTV = N, I+1, -1
+                     IF( V( I, LASTV ).NE.ZERO ) EXIT
+                  END DO
+                  DO J = 1, I-1
+                     T( J, I ) = -TAU( I ) * V( J , I )
+                  END DO
+                  J = MIN( LASTV, PREVLASTV )
+*
+*                 T(1:i-1,i) := - tau(i) * V(1:i-1,i:j) * V(i,i:j)**T
+*
+                  CALL SGEMV( 'No transpose', I-1, J-I, -TAU( I ),
+     $                        V( 1, I+1 ), LDV, V( I, I+1 ), LDV,
+     $                        ONE, T( 1, I ), 1 )
+               END IF
+*
+*              T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i)
+*
+               CALL STRMV( 'Upper', 'No transpose', 'Non-unit', I-1, T,
+     $                     LDT, T( 1, I ), 1 )
+               T( I, I ) = TAU( I )
+               IF( I.GT.1 ) THEN
+                  PREVLASTV = MAX( PREVLASTV, LASTV )
+               ELSE
+                  PREVLASTV = LASTV
+               END IF
+            END IF
+         END DO
+      ELSE
+         PREVLASTV = 1
+         DO I = K, 1, -1
+            IF( TAU( I ).EQ.ZERO ) THEN
+*
+*              H(i)  =  I
+*
+               DO J = I, K
+                  T( J, I ) = ZERO
+               END DO
+            ELSE
+*
+*              general case
+*
+               IF( I.LT.K ) THEN
+                  IF( LSAME( STOREV, 'C' ) ) THEN
+*                    Skip any leading zeros.
+                     DO LASTV = 1, I-1
+                        IF( V( LASTV, I ).NE.ZERO ) EXIT
+                     END DO
+                     DO J = I+1, K
+                        T( J, I ) = -TAU( I ) * V( N-K+I , J )
+                     END DO
+                     J = MAX( LASTV, PREVLASTV )
+*
+*                    T(i+1:k,i) = -tau(i) * V(j:n-k+i,i+1:k)**T * V(j:n-k+i,i)
+*
+                     CALL SGEMV( 'Transpose', N-K+I-J, K-I, -TAU( I ),
+     $                           V( J, I+1 ), LDV, V( J, I ), 1, ONE,
+     $                           T( I+1, I ), 1 )
+                  ELSE
+*                    Skip any leading zeros.
+                     DO LASTV = 1, I-1
+                        IF( V( I, LASTV ).NE.ZERO ) EXIT
+                     END DO
+                     DO J = I+1, K
+                        T( J, I ) = -TAU( I ) * V( J, N-K+I )
+                     END DO
+                     J = MAX( LASTV, PREVLASTV )
+*
+*                    T(i+1:k,i) = -tau(i) * V(i+1:k,j:n-k+i) * V(i,j:n-k+i)**T
+*
+                     CALL SGEMV( 'No transpose', K-I, N-K+I-J,
+     $                    -TAU( I ), V( I+1, J ), LDV, V( I, J ), LDV,
+     $                    ONE, T( I+1, I ), 1 )
+                  END IF
+*
+*                 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i)
+*
+                  CALL STRMV( 'Lower', 'No transpose', 'Non-unit', K-I,
+     $                        T( I+1, I+1 ), LDT, T( I+1, I ), 1 )
+                  IF( I.GT.1 ) THEN
+                     PREVLASTV = MIN( PREVLASTV, LASTV )
+                  ELSE
+                     PREVLASTV = LASTV
+                  END IF
+               END IF
+               T( I, I ) = TAU( I )
+            END IF
+         END DO
+      END IF
+      RETURN
+*
+*     End of SLARFT
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slarnv.f AmberTools/src/quick/src/blas/slarnv.f
--- AmberTools/src/quick/src/blas/slarnv.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slarnv.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,178 @@
+*> \brief \b SLARNV returns a vector of random numbers from a uniform or normal distribution.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLARNV + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slarnv.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slarnv.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slarnv.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLARNV( IDIST, ISEED, N, X )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            IDIST, N
+*       ..
+*       .. Array Arguments ..
+*       INTEGER            ISEED( 4 )
+*       REAL               X( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLARNV returns a vector of n random real numbers from a uniform or
+*> normal distribution.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] IDIST
+*> \verbatim
+*>          IDIST is INTEGER
+*>          Specifies the distribution of the random numbers:
+*>          = 1:  uniform (0,1)
+*>          = 2:  uniform (-1,1)
+*>          = 3:  normal (0,1)
+*> \endverbatim
+*>
+*> \param[in,out] ISEED
+*> \verbatim
+*>          ISEED is INTEGER array, dimension (4)
+*>          On entry, the seed of the random number generator; the array
+*>          elements must be between 0 and 4095, and ISEED(4) must be
+*>          odd.
+*>          On exit, the seed is updated.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of random numbers to be generated.
+*> \endverbatim
+*>
+*> \param[out] X
+*> \verbatim
+*>          X is REAL array, dimension (N)
+*>          The generated random numbers.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup OTHERauxiliary
+*
+*> \par Further Details:
+*  =====================
+*>
+*> \verbatim
+*>
+*>  This routine calls the auxiliary routine SLARUV to generate random
+*>  real numbers from a uniform (0,1) distribution, in batches of up to
+*>  128 using vectorisable code. The Box-Muller method is used to
+*>  transform numbers from a uniform to a normal distribution.
+*> \endverbatim
+*>
+*  =====================================================================
+      SUBROUTINE SLARNV( IDIST, ISEED, N, X )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      INTEGER            IDIST, N
+*     ..
+*     .. Array Arguments ..
+      INTEGER            ISEED( 4 )
+      REAL               X( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE, TWO
+      PARAMETER          ( ONE = 1.0E+0, TWO = 2.0E+0 )
+      INTEGER            LV
+      PARAMETER          ( LV = 128 )
+      REAL               TWOPI
+      PARAMETER          ( TWOPI = 6.2831853071795864769252867663E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, IL, IL2, IV
+*     ..
+*     .. Local Arrays ..
+      REAL               U( LV )
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          COS, LOG, MIN, SQRT
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLARUV
+*     ..
+*     .. Executable Statements ..
+*
+      DO 40 IV = 1, N, LV / 2
+         IL = MIN( LV / 2, N-IV+1 )
+         IF( IDIST.EQ.3 ) THEN
+            IL2 = 2*IL
+         ELSE
+            IL2 = IL
+         END IF
+*
+*        Call SLARUV to generate IL2 numbers from a uniform (0,1)
+*        distribution (IL2 <= LV)
+*
+         CALL SLARUV( ISEED, IL2, U )
+*
+         IF( IDIST.EQ.1 ) THEN
+*
+*           Copy generated numbers
+*
+            DO 10 I = 1, IL
+               X( IV+I-1 ) = U( I )
+   10       CONTINUE
+         ELSE IF( IDIST.EQ.2 ) THEN
+*
+*           Convert generated numbers to uniform (-1,1) distribution
+*
+            DO 20 I = 1, IL
+               X( IV+I-1 ) = TWO*U( I ) - ONE
+   20       CONTINUE
+         ELSE IF( IDIST.EQ.3 ) THEN
+*
+*           Convert generated numbers to normal (0,1) distribution
+*
+            DO 30 I = 1, IL
+               X( IV+I-1 ) = SQRT( -TWO*LOG( U( 2*I-1 ) ) )*
+     $                       COS( TWOPI*U( 2*I ) )
+   30       CONTINUE
+         END IF
+   40 CONTINUE
+      RETURN
+*
+*     End of SLARNV
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slartg.f AmberTools/src/quick/src/blas/slartg.f
--- AmberTools/src/quick/src/blas/slartg.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slartg.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,204 @@
+*> \brief \b SLARTG generates a plane rotation with real cosine and real sine.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLARTG + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slartg.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slartg.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slartg.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLARTG( F, G, CS, SN, R )
+*
+*       .. Scalar Arguments ..
+*       REAL               CS, F, G, R, SN
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLARTG generate a plane rotation so that
+*>
+*>    [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
+*>    [ -SN  CS  ]     [ G ]     [ 0 ]
+*>
+*> This is a slower, more accurate version of the BLAS1 routine SROTG,
+*> with the following other differences:
+*>    F and G are unchanged on return.
+*>    If G=0, then CS=1 and SN=0.
+*>    If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
+*>       floating point operations (saves work in SBDSQR when
+*>       there are zeros on the diagonal).
+*>
+*> If F exceeds G in magnitude, CS will be positive.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] F
+*> \verbatim
+*>          F is REAL
+*>          The first component of vector to be rotated.
+*> \endverbatim
+*>
+*> \param[in] G
+*> \verbatim
+*>          G is REAL
+*>          The second component of vector to be rotated.
+*> \endverbatim
+*>
+*> \param[out] CS
+*> \verbatim
+*>          CS is REAL
+*>          The cosine of the rotation.
+*> \endverbatim
+*>
+*> \param[out] SN
+*> \verbatim
+*>          SN is REAL
+*>          The sine of the rotation.
+*> \endverbatim
+*>
+*> \param[out] R
+*> \verbatim
+*>          R is REAL
+*>          The nonzero component of the rotated vector.
+*>
+*>  This version has a few statements commented out for thread safety
+*>  (machine parameters are computed on each entry). 10 feb 03, SJH.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup OTHERauxiliary
+*
+*  =====================================================================
+      SUBROUTINE SLARTG( F, G, CS, SN, R )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      REAL               CS, F, G, R, SN
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO
+      PARAMETER          ( ZERO = 0.0E0 )
+      REAL               ONE
+      PARAMETER          ( ONE = 1.0E0 )
+      REAL               TWO
+      PARAMETER          ( TWO = 2.0E0 )
+*     ..
+*     .. Local Scalars ..
+*     LOGICAL            FIRST
+      INTEGER            COUNT, I
+      REAL               EPS, F1, G1, SAFMIN, SAFMN2, SAFMX2, SCALE
+*     ..
+*     .. External Functions ..
+      REAL               SLAMCH
+      EXTERNAL           SLAMCH
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, INT, LOG, MAX, SQRT
+*     ..
+*     .. Save statement ..
+*     SAVE               FIRST, SAFMX2, SAFMIN, SAFMN2
+*     ..
+*     .. Data statements ..
+*     DATA               FIRST / .TRUE. /
+*     ..
+*     .. Executable Statements ..
+*
+*     IF( FIRST ) THEN
+         SAFMIN = SLAMCH( 'S' )
+         EPS = SLAMCH( 'E' )
+         SAFMN2 = SLAMCH( 'B' )**INT( LOG( SAFMIN / EPS ) /
+     $            LOG( SLAMCH( 'B' ) ) / TWO )
+         SAFMX2 = ONE / SAFMN2
+*        FIRST = .FALSE.
+*     END IF
+      IF( G.EQ.ZERO ) THEN
+         CS = ONE
+         SN = ZERO
+         R = F
+      ELSE IF( F.EQ.ZERO ) THEN
+         CS = ZERO
+         SN = ONE
+         R = G
+      ELSE
+         F1 = F
+         G1 = G
+         SCALE = MAX( ABS( F1 ), ABS( G1 ) )
+         IF( SCALE.GE.SAFMX2 ) THEN
+            COUNT = 0
+   10       CONTINUE
+            COUNT = COUNT + 1
+            F1 = F1*SAFMN2
+            G1 = G1*SAFMN2
+            SCALE = MAX( ABS( F1 ), ABS( G1 ) )
+            IF( SCALE.GE.SAFMX2 .AND. COUNT .LT. 20)
+     $         GO TO 10
+            R = SQRT( F1**2+G1**2 )
+            CS = F1 / R
+            SN = G1 / R
+            DO 20 I = 1, COUNT
+               R = R*SAFMX2
+   20       CONTINUE
+         ELSE IF( SCALE.LE.SAFMN2 ) THEN
+            COUNT = 0
+   30       CONTINUE
+            COUNT = COUNT + 1
+            F1 = F1*SAFMX2
+            G1 = G1*SAFMX2
+            SCALE = MAX( ABS( F1 ), ABS( G1 ) )
+            IF( SCALE.LE.SAFMN2 )
+     $         GO TO 30
+            R = SQRT( F1**2+G1**2 )
+            CS = F1 / R
+            SN = G1 / R
+            DO 40 I = 1, COUNT
+               R = R*SAFMN2
+   40       CONTINUE
+         ELSE
+            R = SQRT( F1**2+G1**2 )
+            CS = F1 / R
+            SN = G1 / R
+         END IF
+         IF( ABS( F ).GT.ABS( G ) .AND. CS.LT.ZERO ) THEN
+            CS = -CS
+            SN = -SN
+            R = -R
+         END IF
+      END IF
+      RETURN
+*
+*     End of SLARTG
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slaruv.f AmberTools/src/quick/src/blas/slaruv.f
--- AmberTools/src/quick/src/blas/slaruv.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slaruv.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,447 @@
+*> \brief \b SLARUV returns a vector of n random real numbers from a uniform distribution.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLARUV + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slaruv.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slaruv.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaruv.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLARUV( ISEED, N, X )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            N
+*       ..
+*       .. Array Arguments ..
+*       INTEGER            ISEED( 4 )
+*       REAL               X( N )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLARUV returns a vector of n random real numbers from a uniform (0,1)
+*> distribution (n <= 128).
+*>
+*> This is an auxiliary routine called by SLARNV and CLARNV.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in,out] ISEED
+*> \verbatim
+*>          ISEED is INTEGER array, dimension (4)
+*>          On entry, the seed of the random number generator; the array
+*>          elements must be between 0 and 4095, and ISEED(4) must be
+*>          odd.
+*>          On exit, the seed is updated.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of random numbers to be generated. N <= 128.
+*> \endverbatim
+*>
+*> \param[out] X
+*> \verbatim
+*>          X is REAL array, dimension (N)
+*>          The generated random numbers.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup OTHERauxiliary
+*
+*> \par Further Details:
+*  =====================
+*>
+*> \verbatim
+*>
+*>  This routine uses a multiplicative congruential method with modulus
+*>  2**48 and multiplier 33952834046453 (see G.S.Fishman,
+*>  'Multiplicative congruential random number generators with modulus
+*>  2**b: an exhaustive analysis for b = 32 and a partial analysis for
+*>  b = 48', Math. Comp. 189, pp 331-344, 1990).
+*>
+*>  48-bit integers are stored in 4 integer array elements with 12 bits
+*>  per element. Hence the routine is portable across machines with
+*>  integers of 32 bits or more.
+*> \endverbatim
+*>
+*  =====================================================================
+      SUBROUTINE SLARUV( ISEED, N, X )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      INTEGER            N
+*     ..
+*     .. Array Arguments ..
+      INTEGER            ISEED( 4 )
+      REAL               X( N )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE
+      PARAMETER          ( ONE = 1.0E0 )
+      INTEGER            LV, IPW2
+      REAL               R
+      PARAMETER          ( LV = 128, IPW2 = 4096, R = ONE / IPW2 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, I1, I2, I3, I4, IT1, IT2, IT3, IT4, J
+*     ..
+*     .. Local Arrays ..
+      INTEGER            MM( LV, 4 )
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MIN, MOD, REAL
+*     ..
+*     .. Data statements ..
+      DATA               ( MM( 1, J ), J = 1, 4 ) / 494, 322, 2508,
+     $                   2549 /
+      DATA               ( MM( 2, J ), J = 1, 4 ) / 2637, 789, 3754,
+     $                   1145 /
+      DATA               ( MM( 3, J ), J = 1, 4 ) / 255, 1440, 1766,
+     $                   2253 /
+      DATA               ( MM( 4, J ), J = 1, 4 ) / 2008, 752, 3572,
+     $                   305 /
+      DATA               ( MM( 5, J ), J = 1, 4 ) / 1253, 2859, 2893,
+     $                   3301 /
+      DATA               ( MM( 6, J ), J = 1, 4 ) / 3344, 123, 307,
+     $                   1065 /
+      DATA               ( MM( 7, J ), J = 1, 4 ) / 4084, 1848, 1297,
+     $                   3133 /
+      DATA               ( MM( 8, J ), J = 1, 4 ) / 1739, 643, 3966,
+     $                   2913 /
+      DATA               ( MM( 9, J ), J = 1, 4 ) / 3143, 2405, 758,
+     $                   3285 /
+      DATA               ( MM( 10, J ), J = 1, 4 ) / 3468, 2638, 2598,
+     $                   1241 /
+      DATA               ( MM( 11, J ), J = 1, 4 ) / 688, 2344, 3406,
+     $                   1197 /
+      DATA               ( MM( 12, J ), J = 1, 4 ) / 1657, 46, 2922,
+     $                   3729 /
+      DATA               ( MM( 13, J ), J = 1, 4 ) / 1238, 3814, 1038,
+     $                   2501 /
+      DATA               ( MM( 14, J ), J = 1, 4 ) / 3166, 913, 2934,
+     $                   1673 /
+      DATA               ( MM( 15, J ), J = 1, 4 ) / 1292, 3649, 2091,
+     $                   541 /
+      DATA               ( MM( 16, J ), J = 1, 4 ) / 3422, 339, 2451,
+     $                   2753 /
+      DATA               ( MM( 17, J ), J = 1, 4 ) / 1270, 3808, 1580,
+     $                   949 /
+      DATA               ( MM( 18, J ), J = 1, 4 ) / 2016, 822, 1958,
+     $                   2361 /
+      DATA               ( MM( 19, J ), J = 1, 4 ) / 154, 2832, 2055,
+     $                   1165 /
+      DATA               ( MM( 20, J ), J = 1, 4 ) / 2862, 3078, 1507,
+     $                   4081 /
+      DATA               ( MM( 21, J ), J = 1, 4 ) / 697, 3633, 1078,
+     $                   2725 /
+      DATA               ( MM( 22, J ), J = 1, 4 ) / 1706, 2970, 3273,
+     $                   3305 /
+      DATA               ( MM( 23, J ), J = 1, 4 ) / 491, 637, 17,
+     $                   3069 /
+      DATA               ( MM( 24, J ), J = 1, 4 ) / 931, 2249, 854,
+     $                   3617 /
+      DATA               ( MM( 25, J ), J = 1, 4 ) / 1444, 2081, 2916,
+     $                   3733 /
+      DATA               ( MM( 26, J ), J = 1, 4 ) / 444, 4019, 3971,
+     $                   409 /
+      DATA               ( MM( 27, J ), J = 1, 4 ) / 3577, 1478, 2889,
+     $                   2157 /
+      DATA               ( MM( 28, J ), J = 1, 4 ) / 3944, 242, 3831,
+     $                   1361 /
+      DATA               ( MM( 29, J ), J = 1, 4 ) / 2184, 481, 2621,
+     $                   3973 /
+      DATA               ( MM( 30, J ), J = 1, 4 ) / 1661, 2075, 1541,
+     $                   1865 /
+      DATA               ( MM( 31, J ), J = 1, 4 ) / 3482, 4058, 893,
+     $                   2525 /
+      DATA               ( MM( 32, J ), J = 1, 4 ) / 657, 622, 736,
+     $                   1409 /
+      DATA               ( MM( 33, J ), J = 1, 4 ) / 3023, 3376, 3992,
+     $                   3445 /
+      DATA               ( MM( 34, J ), J = 1, 4 ) / 3618, 812, 787,
+     $                   3577 /
+      DATA               ( MM( 35, J ), J = 1, 4 ) / 1267, 234, 2125,
+     $                   77 /
+      DATA               ( MM( 36, J ), J = 1, 4 ) / 1828, 641, 2364,
+     $                   3761 /
+      DATA               ( MM( 37, J ), J = 1, 4 ) / 164, 4005, 2460,
+     $                   2149 /
+      DATA               ( MM( 38, J ), J = 1, 4 ) / 3798, 1122, 257,
+     $                   1449 /
+      DATA               ( MM( 39, J ), J = 1, 4 ) / 3087, 3135, 1574,
+     $                   3005 /
+      DATA               ( MM( 40, J ), J = 1, 4 ) / 2400, 2640, 3912,
+     $                   225 /
+      DATA               ( MM( 41, J ), J = 1, 4 ) / 2870, 2302, 1216,
+     $                   85 /
+      DATA               ( MM( 42, J ), J = 1, 4 ) / 3876, 40, 3248,
+     $                   3673 /
+      DATA               ( MM( 43, J ), J = 1, 4 ) / 1905, 1832, 3401,
+     $                   3117 /
+      DATA               ( MM( 44, J ), J = 1, 4 ) / 1593, 2247, 2124,
+     $                   3089 /
+      DATA               ( MM( 45, J ), J = 1, 4 ) / 1797, 2034, 2762,
+     $                   1349 /
+      DATA               ( MM( 46, J ), J = 1, 4 ) / 1234, 2637, 149,
+     $                   2057 /
+      DATA               ( MM( 47, J ), J = 1, 4 ) / 3460, 1287, 2245,
+     $                   413 /
+      DATA               ( MM( 48, J ), J = 1, 4 ) / 328, 1691, 166,
+     $                   65 /
+      DATA               ( MM( 49, J ), J = 1, 4 ) / 2861, 496, 466,
+     $                   1845 /
+      DATA               ( MM( 50, J ), J = 1, 4 ) / 1950, 1597, 4018,
+     $                   697 /
+      DATA               ( MM( 51, J ), J = 1, 4 ) / 617, 2394, 1399,
+     $                   3085 /
+      DATA               ( MM( 52, J ), J = 1, 4 ) / 2070, 2584, 190,
+     $                   3441 /
+      DATA               ( MM( 53, J ), J = 1, 4 ) / 3331, 1843, 2879,
+     $                   1573 /
+      DATA               ( MM( 54, J ), J = 1, 4 ) / 769, 336, 153,
+     $                   3689 /
+      DATA               ( MM( 55, J ), J = 1, 4 ) / 1558, 1472, 2320,
+     $                   2941 /
+      DATA               ( MM( 56, J ), J = 1, 4 ) / 2412, 2407, 18,
+     $                   929 /
+      DATA               ( MM( 57, J ), J = 1, 4 ) / 2800, 433, 712,
+     $                   533 /
+      DATA               ( MM( 58, J ), J = 1, 4 ) / 189, 2096, 2159,
+     $                   2841 /
+      DATA               ( MM( 59, J ), J = 1, 4 ) / 287, 1761, 2318,
+     $                   4077 /
+      DATA               ( MM( 60, J ), J = 1, 4 ) / 2045, 2810, 2091,
+     $                   721 /
+      DATA               ( MM( 61, J ), J = 1, 4 ) / 1227, 566, 3443,
+     $                   2821 /
+      DATA               ( MM( 62, J ), J = 1, 4 ) / 2838, 442, 1510,
+     $                   2249 /
+      DATA               ( MM( 63, J ), J = 1, 4 ) / 209, 41, 449,
+     $                   2397 /
+      DATA               ( MM( 64, J ), J = 1, 4 ) / 2770, 1238, 1956,
+     $                   2817 /
+      DATA               ( MM( 65, J ), J = 1, 4 ) / 3654, 1086, 2201,
+     $                   245 /
+      DATA               ( MM( 66, J ), J = 1, 4 ) / 3993, 603, 3137,
+     $                   1913 /
+      DATA               ( MM( 67, J ), J = 1, 4 ) / 192, 840, 3399,
+     $                   1997 /
+      DATA               ( MM( 68, J ), J = 1, 4 ) / 2253, 3168, 1321,
+     $                   3121 /
+      DATA               ( MM( 69, J ), J = 1, 4 ) / 3491, 1499, 2271,
+     $                   997 /
+      DATA               ( MM( 70, J ), J = 1, 4 ) / 2889, 1084, 3667,
+     $                   1833 /
+      DATA               ( MM( 71, J ), J = 1, 4 ) / 2857, 3438, 2703,
+     $                   2877 /
+      DATA               ( MM( 72, J ), J = 1, 4 ) / 2094, 2408, 629,
+     $                   1633 /
+      DATA               ( MM( 73, J ), J = 1, 4 ) / 1818, 1589, 2365,
+     $                   981 /
+      DATA               ( MM( 74, J ), J = 1, 4 ) / 688, 2391, 2431,
+     $                   2009 /
+      DATA               ( MM( 75, J ), J = 1, 4 ) / 1407, 288, 1113,
+     $                   941 /
+      DATA               ( MM( 76, J ), J = 1, 4 ) / 634, 26, 3922,
+     $                   2449 /
+      DATA               ( MM( 77, J ), J = 1, 4 ) / 3231, 512, 2554,
+     $                   197 /
+      DATA               ( MM( 78, J ), J = 1, 4 ) / 815, 1456, 184,
+     $                   2441 /
+      DATA               ( MM( 79, J ), J = 1, 4 ) / 3524, 171, 2099,
+     $                   285 /
+      DATA               ( MM( 80, J ), J = 1, 4 ) / 1914, 1677, 3228,
+     $                   1473 /
+      DATA               ( MM( 81, J ), J = 1, 4 ) / 516, 2657, 4012,
+     $                   2741 /
+      DATA               ( MM( 82, J ), J = 1, 4 ) / 164, 2270, 1921,
+     $                   3129 /
+      DATA               ( MM( 83, J ), J = 1, 4 ) / 303, 2587, 3452,
+     $                   909 /
+      DATA               ( MM( 84, J ), J = 1, 4 ) / 2144, 2961, 3901,
+     $                   2801 /
+      DATA               ( MM( 85, J ), J = 1, 4 ) / 3480, 1970, 572,
+     $                   421 /
+      DATA               ( MM( 86, J ), J = 1, 4 ) / 119, 1817, 3309,
+     $                   4073 /
+      DATA               ( MM( 87, J ), J = 1, 4 ) / 3357, 676, 3171,
+     $                   2813 /
+      DATA               ( MM( 88, J ), J = 1, 4 ) / 837, 1410, 817,
+     $                   2337 /
+      DATA               ( MM( 89, J ), J = 1, 4 ) / 2826, 3723, 3039,
+     $                   1429 /
+      DATA               ( MM( 90, J ), J = 1, 4 ) / 2332, 2803, 1696,
+     $                   1177 /
+      DATA               ( MM( 91, J ), J = 1, 4 ) / 2089, 3185, 1256,
+     $                   1901 /
+      DATA               ( MM( 92, J ), J = 1, 4 ) / 3780, 184, 3715,
+     $                   81 /
+      DATA               ( MM( 93, J ), J = 1, 4 ) / 1700, 663, 2077,
+     $                   1669 /
+      DATA               ( MM( 94, J ), J = 1, 4 ) / 3712, 499, 3019,
+     $                   2633 /
+      DATA               ( MM( 95, J ), J = 1, 4 ) / 150, 3784, 1497,
+     $                   2269 /
+      DATA               ( MM( 96, J ), J = 1, 4 ) / 2000, 1631, 1101,
+     $                   129 /
+      DATA               ( MM( 97, J ), J = 1, 4 ) / 3375, 1925, 717,
+     $                   1141 /
+      DATA               ( MM( 98, J ), J = 1, 4 ) / 1621, 3912, 51,
+     $                   249 /
+      DATA               ( MM( 99, J ), J = 1, 4 ) / 3090, 1398, 981,
+     $                   3917 /
+      DATA               ( MM( 100, J ), J = 1, 4 ) / 3765, 1349, 1978,
+     $                   2481 /
+      DATA               ( MM( 101, J ), J = 1, 4 ) / 1149, 1441, 1813,
+     $                   3941 /
+      DATA               ( MM( 102, J ), J = 1, 4 ) / 3146, 2224, 3881,
+     $                   2217 /
+      DATA               ( MM( 103, J ), J = 1, 4 ) / 33, 2411, 76,
+     $                   2749 /
+      DATA               ( MM( 104, J ), J = 1, 4 ) / 3082, 1907, 3846,
+     $                   3041 /
+      DATA               ( MM( 105, J ), J = 1, 4 ) / 2741, 3192, 3694,
+     $                   1877 /
+      DATA               ( MM( 106, J ), J = 1, 4 ) / 359, 2786, 1682,
+     $                   345 /
+      DATA               ( MM( 107, J ), J = 1, 4 ) / 3316, 382, 124,
+     $                   2861 /
+      DATA               ( MM( 108, J ), J = 1, 4 ) / 1749, 37, 1660,
+     $                   1809 /
+      DATA               ( MM( 109, J ), J = 1, 4 ) / 185, 759, 3997,
+     $                   3141 /
+      DATA               ( MM( 110, J ), J = 1, 4 ) / 2784, 2948, 479,
+     $                   2825 /
+      DATA               ( MM( 111, J ), J = 1, 4 ) / 2202, 1862, 1141,
+     $                   157 /
+      DATA               ( MM( 112, J ), J = 1, 4 ) / 2199, 3802, 886,
+     $                   2881 /
+      DATA               ( MM( 113, J ), J = 1, 4 ) / 1364, 2423, 3514,
+     $                   3637 /
+      DATA               ( MM( 114, J ), J = 1, 4 ) / 1244, 2051, 1301,
+     $                   1465 /
+      DATA               ( MM( 115, J ), J = 1, 4 ) / 2020, 2295, 3604,
+     $                   2829 /
+      DATA               ( MM( 116, J ), J = 1, 4 ) / 3160, 1332, 1888,
+     $                   2161 /
+      DATA               ( MM( 117, J ), J = 1, 4 ) / 2785, 1832, 1836,
+     $                   3365 /
+      DATA               ( MM( 118, J ), J = 1, 4 ) / 2772, 2405, 1990,
+     $                   361 /
+      DATA               ( MM( 119, J ), J = 1, 4 ) / 1217, 3638, 2058,
+     $                   2685 /
+      DATA               ( MM( 120, J ), J = 1, 4 ) / 1822, 3661, 692,
+     $                   3745 /
+      DATA               ( MM( 121, J ), J = 1, 4 ) / 1245, 327, 1194,
+     $                   2325 /
+      DATA               ( MM( 122, J ), J = 1, 4 ) / 2252, 3660, 20,
+     $                   3609 /
+      DATA               ( MM( 123, J ), J = 1, 4 ) / 3904, 716, 3285,
+     $                   3821 /
+      DATA               ( MM( 124, J ), J = 1, 4 ) / 2774, 1842, 2046,
+     $                   3537 /
+      DATA               ( MM( 125, J ), J = 1, 4 ) / 997, 3987, 2107,
+     $                   517 /
+      DATA               ( MM( 126, J ), J = 1, 4 ) / 2573, 1368, 3508,
+     $                   3017 /
+      DATA               ( MM( 127, J ), J = 1, 4 ) / 1148, 1848, 3525,
+     $                   2141 /
+      DATA               ( MM( 128, J ), J = 1, 4 ) / 545, 2366, 3801,
+     $                   1537 /
+*     ..
+*     .. Executable Statements ..
+*
+      I1 = ISEED( 1 )
+      I2 = ISEED( 2 )
+      I3 = ISEED( 3 )
+      I4 = ISEED( 4 )
+*
+      DO 10 I = 1, MIN( N, LV )
+*
+  20     CONTINUE
+*
+*        Multiply the seed by i-th power of the multiplier modulo 2**48
+*
+         IT4 = I4*MM( I, 4 )
+         IT3 = IT4 / IPW2
+         IT4 = IT4 - IPW2*IT3
+         IT3 = IT3 + I3*MM( I, 4 ) + I4*MM( I, 3 )
+         IT2 = IT3 / IPW2
+         IT3 = IT3 - IPW2*IT2
+         IT2 = IT2 + I2*MM( I, 4 ) + I3*MM( I, 3 ) + I4*MM( I, 2 )
+         IT1 = IT2 / IPW2
+         IT2 = IT2 - IPW2*IT1
+         IT1 = IT1 + I1*MM( I, 4 ) + I2*MM( I, 3 ) + I3*MM( I, 2 ) +
+     $         I4*MM( I, 1 )
+         IT1 = MOD( IT1, IPW2 )
+*
+*        Convert 48-bit integer to a real number in the interval (0,1)
+*
+         X( I ) = R*( REAL( IT1 )+R*( REAL( IT2 )+R*( REAL( IT3 )+R*
+     $            REAL( IT4 ) ) ) )
+*
+         IF (X( I ).EQ.1.0) THEN
+*           If a real number has n bits of precision, and the first
+*           n bits of the 48-bit integer above happen to be all 1 (which
+*           will occur about once every 2**n calls), then X( I ) will
+*           be rounded to exactly 1.0. In IEEE single precision arithmetic,
+*           this will happen relatively often since n = 24.
+*           Since X( I ) is not supposed to return exactly 0.0 or 1.0,
+*           the statistically correct thing to do in this situation is
+*           simply to iterate again.
+*           N.B. the case X( I ) = 0.0 should not be possible.
+            I1 = I1 + 2
+            I2 = I2 + 2
+            I3 = I3 + 2
+            I4 = I4 + 2
+            GOTO 20
+         END IF
+*
+   10 CONTINUE
+*
+*     Return final value of seed
+*
+      ISEED( 1 ) = IT1
+      ISEED( 2 ) = IT2
+      ISEED( 3 ) = IT3
+      ISEED( 4 ) = IT4
+      RETURN
+*
+*     End of SLARUV
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slascl.f AmberTools/src/quick/src/blas/slascl.f
--- AmberTools/src/quick/src/blas/slascl.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slascl.f	2022-08-30 19:20:30.000000000 +0900
@@ -0,0 +1,368 @@
+*> \brief \b SLASCL multiplies a general rectangular matrix by a real scalar defined as cto/cfrom.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLASCL + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slascl.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slascl.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slascl.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLASCL( TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          TYPE
+*       INTEGER            INFO, KL, KU, LDA, M, N
+*       REAL               CFROM, CTO
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLASCL multiplies the M by N real matrix A by the real scalar
+*> CTO/CFROM.  This is done without over/underflow as long as the final
+*> result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
+*> A may be full, upper triangular, lower triangular, upper Hessenberg,
+*> or banded.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] TYPE
+*> \verbatim
+*>          TYPE is CHARACTER*1
+*>          TYPE indices the storage type of the input matrix.
+*>          = 'G':  A is a full matrix.
+*>          = 'L':  A is a lower triangular matrix.
+*>          = 'U':  A is an upper triangular matrix.
+*>          = 'H':  A is an upper Hessenberg matrix.
+*>          = 'B':  A is a symmetric band matrix with lower bandwidth KL
+*>                  and upper bandwidth KU and with the only the lower
+*>                  half stored.
+*>          = 'Q':  A is a symmetric band matrix with lower bandwidth KL
+*>                  and upper bandwidth KU and with the only the upper
+*>                  half stored.
+*>          = 'Z':  A is a band matrix with lower bandwidth KL and upper
+*>                  bandwidth KU. See SGBTRF for storage details.
+*> \endverbatim
+*>
+*> \param[in] KL
+*> \verbatim
+*>          KL is INTEGER
+*>          The lower bandwidth of A.  Referenced only if TYPE = 'B',
+*>          'Q' or 'Z'.
+*> \endverbatim
+*>
+*> \param[in] KU
+*> \verbatim
+*>          KU is INTEGER
+*>          The upper bandwidth of A.  Referenced only if TYPE = 'B',
+*>          'Q' or 'Z'.
+*> \endverbatim
+*>
+*> \param[in] CFROM
+*> \verbatim
+*>          CFROM is REAL
+*> \endverbatim
+*>
+*> \param[in] CTO
+*> \verbatim
+*>          CTO is REAL
+*>
+*>          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
+*>          without over/underflow if the final result CTO*A(I,J)/CFROM
+*>          can be represented without over/underflow.  CFROM must be
+*>          nonzero.
+*> \endverbatim
+*>
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix A.  M >= 0.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix A.  N >= 0.
+*> \endverbatim
+*>
+*> \param[in,out] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          The matrix to be multiplied by CTO/CFROM.  See TYPE for the
+*>          storage type.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A.
+*>          If TYPE = 'G', 'L', 'U', 'H', LDA >= max(1,M);
+*>             TYPE = 'B', LDA >= KL+1;
+*>             TYPE = 'Q', LDA >= KU+1;
+*>             TYPE = 'Z', LDA >= 2*KL+KU+1.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          0  - successful exit
+*>          <0 - if INFO = -i, the i-th argument had an illegal value.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date June 2016
+*
+*> \ingroup OTHERauxiliary
+*
+*  =====================================================================
+      SUBROUTINE SLASCL( TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     June 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          TYPE
+      INTEGER            INFO, KL, KU, LDA, M, N
+      REAL               CFROM, CTO
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO, ONE
+      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            DONE
+      INTEGER            I, ITYPE, J, K1, K2, K3, K4
+      REAL               BIGNUM, CFROM1, CFROMC, CTO1, CTOC, MUL, SMLNUM
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME, SISNAN
+      REAL               SLAMCH
+      EXTERNAL           LSAME, SLAMCH, SISNAN
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, MAX, MIN
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           XERBLA
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input arguments
+*
+      INFO = 0
+*
+      IF( LSAME( TYPE, 'G' ) ) THEN
+         ITYPE = 0
+      ELSE IF( LSAME( TYPE, 'L' ) ) THEN
+         ITYPE = 1
+      ELSE IF( LSAME( TYPE, 'U' ) ) THEN
+         ITYPE = 2
+      ELSE IF( LSAME( TYPE, 'H' ) ) THEN
+         ITYPE = 3
+      ELSE IF( LSAME( TYPE, 'B' ) ) THEN
+         ITYPE = 4
+      ELSE IF( LSAME( TYPE, 'Q' ) ) THEN
+         ITYPE = 5
+      ELSE IF( LSAME( TYPE, 'Z' ) ) THEN
+         ITYPE = 6
+      ELSE
+         ITYPE = -1
+      END IF
+*
+      IF( ITYPE.EQ.-1 ) THEN
+         INFO = -1
+      ELSE IF( CFROM.EQ.ZERO .OR. SISNAN(CFROM) ) THEN
+         INFO = -4
+      ELSE IF( SISNAN(CTO) ) THEN
+         INFO = -5
+      ELSE IF( M.LT.0 ) THEN
+         INFO = -6
+      ELSE IF( N.LT.0 .OR. ( ITYPE.EQ.4 .AND. N.NE.M ) .OR.
+     $         ( ITYPE.EQ.5 .AND. N.NE.M ) ) THEN
+         INFO = -7
+      ELSE IF( ITYPE.LE.3 .AND. LDA.LT.MAX( 1, M ) ) THEN
+         INFO = -9
+      ELSE IF( ITYPE.GE.4 ) THEN
+         IF( KL.LT.0 .OR. KL.GT.MAX( M-1, 0 ) ) THEN
+            INFO = -2
+         ELSE IF( KU.LT.0 .OR. KU.GT.MAX( N-1, 0 ) .OR.
+     $            ( ( ITYPE.EQ.4 .OR. ITYPE.EQ.5 ) .AND. KL.NE.KU ) )
+     $             THEN
+            INFO = -3
+         ELSE IF( ( ITYPE.EQ.4 .AND. LDA.LT.KL+1 ) .OR.
+     $            ( ITYPE.EQ.5 .AND. LDA.LT.KU+1 ) .OR.
+     $            ( ITYPE.EQ.6 .AND. LDA.LT.2*KL+KU+1 ) ) THEN
+            INFO = -9
+         END IF
+      END IF
+*
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SLASCL', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 .OR. M.EQ.0 )
+     $   RETURN
+*
+*     Get machine parameters
+*
+      SMLNUM = SLAMCH( 'S' )
+      BIGNUM = ONE / SMLNUM
+*
+      CFROMC = CFROM
+      CTOC = CTO
+*
+   10 CONTINUE
+      CFROM1 = CFROMC*SMLNUM
+      IF( CFROM1.EQ.CFROMC ) THEN
+!        CFROMC is an inf.  Multiply by a correctly signed zero for
+!        finite CTOC, or a NaN if CTOC is infinite.
+         MUL = CTOC / CFROMC
+         DONE = .TRUE.
+         CTO1 = CTOC
+      ELSE
+         CTO1 = CTOC / BIGNUM
+         IF( CTO1.EQ.CTOC ) THEN
+!           CTOC is either 0 or an inf.  In both cases, CTOC itself
+!           serves as the correct multiplication factor.
+            MUL = CTOC
+            DONE = .TRUE.
+            CFROMC = ONE
+         ELSE IF( ABS( CFROM1 ).GT.ABS( CTOC ) .AND. CTOC.NE.ZERO ) THEN
+            MUL = SMLNUM
+            DONE = .FALSE.
+            CFROMC = CFROM1
+         ELSE IF( ABS( CTO1 ).GT.ABS( CFROMC ) ) THEN
+            MUL = BIGNUM
+            DONE = .FALSE.
+            CTOC = CTO1
+         ELSE
+            MUL = CTOC / CFROMC
+            DONE = .TRUE.
+         END IF
+      END IF
+*
+      IF( ITYPE.EQ.0 ) THEN
+*
+*        Full matrix
+*
+         DO 30 J = 1, N
+            DO 20 I = 1, M
+               A( I, J ) = A( I, J )*MUL
+   20       CONTINUE
+   30    CONTINUE
+*
+      ELSE IF( ITYPE.EQ.1 ) THEN
+*
+*        Lower triangular matrix
+*
+         DO 50 J = 1, N
+            DO 40 I = J, M
+               A( I, J ) = A( I, J )*MUL
+   40       CONTINUE
+   50    CONTINUE
+*
+      ELSE IF( ITYPE.EQ.2 ) THEN
+*
+*        Upper triangular matrix
+*
+         DO 70 J = 1, N
+            DO 60 I = 1, MIN( J, M )
+               A( I, J ) = A( I, J )*MUL
+   60       CONTINUE
+   70    CONTINUE
+*
+      ELSE IF( ITYPE.EQ.3 ) THEN
+*
+*        Upper Hessenberg matrix
+*
+         DO 90 J = 1, N
+            DO 80 I = 1, MIN( J+1, M )
+               A( I, J ) = A( I, J )*MUL
+   80       CONTINUE
+   90    CONTINUE
+*
+      ELSE IF( ITYPE.EQ.4 ) THEN
+*
+*        Lower half of a symmetric band matrix
+*
+         K3 = KL + 1
+         K4 = N + 1
+         DO 110 J = 1, N
+            DO 100 I = 1, MIN( K3, K4-J )
+               A( I, J ) = A( I, J )*MUL
+  100       CONTINUE
+  110    CONTINUE
+*
+      ELSE IF( ITYPE.EQ.5 ) THEN
+*
+*        Upper half of a symmetric band matrix
+*
+         K1 = KU + 2
+         K3 = KU + 1
+         DO 130 J = 1, N
+            DO 120 I = MAX( K1-J, 1 ), K3
+               A( I, J ) = A( I, J )*MUL
+  120       CONTINUE
+  130    CONTINUE
+*
+      ELSE IF( ITYPE.EQ.6 ) THEN
+*
+*        Band matrix
+*
+         K1 = KL + KU + 2
+         K2 = KL + 1
+         K3 = 2*KL + KU + 1
+         K4 = KL + KU + 1 + M
+         DO 150 J = 1, N
+            DO 140 I = MAX( K1-J, K2 ), MIN( K3, K4-J )
+               A( I, J ) = A( I, J )*MUL
+  140       CONTINUE
+  150    CONTINUE
+*
+      END IF
+*
+      IF( .NOT.DONE )
+     $   GO TO 10
+*
+      RETURN
+*
+*     End of SLASCL
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slaset.f AmberTools/src/quick/src/blas/slaset.f
--- AmberTools/src/quick/src/blas/slaset.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slaset.f	2022-08-30 19:21:02.000000000 +0900
@@ -0,0 +1,184 @@
+*> \brief \b SLASET initializes the off-diagonal elements and the diagonal elements of a matrix to given values.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLASET + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slaset.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slaset.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slaset.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLASET( UPLO, M, N, ALPHA, BETA, A, LDA )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          UPLO
+*       INTEGER            LDA, M, N
+*       REAL               ALPHA, BETA
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLASET initializes an m-by-n matrix A to BETA on the diagonal and
+*> ALPHA on the offdiagonals.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] UPLO
+*> \verbatim
+*>          UPLO is CHARACTER*1
+*>          Specifies the part of the matrix A to be set.
+*>          = 'U':      Upper triangular part is set; the strictly lower
+*>                      triangular part of A is not changed.
+*>          = 'L':      Lower triangular part is set; the strictly upper
+*>                      triangular part of A is not changed.
+*>          Otherwise:  All of the matrix A is set.
+*> \endverbatim
+*>
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix A.  M >= 0.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix A.  N >= 0.
+*> \endverbatim
+*>
+*> \param[in] ALPHA
+*> \verbatim
+*>          ALPHA is REAL
+*>          The constant to which the offdiagonal elements are to be set.
+*> \endverbatim
+*>
+*> \param[in] BETA
+*> \verbatim
+*>          BETA is REAL
+*>          The constant to which the diagonal elements are to be set.
+*> \endverbatim
+*>
+*> \param[out] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          On exit, the leading m-by-n submatrix of A is set as follows:
+*>
+*>          if UPLO = 'U', A(i,j) = ALPHA, 1<=i<=j-1, 1<=j<=n,
+*>          if UPLO = 'L', A(i,j) = ALPHA, j+1<=i<=m, 1<=j<=n,
+*>          otherwise,     A(i,j) = ALPHA, 1<=i<=m, 1<=j<=n, i.ne.j,
+*>
+*>          and, for all UPLO, A(i,i) = BETA, 1<=i<=min(m,n).
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A.  LDA >= max(1,M).
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup OTHERauxiliary
+*
+*  =====================================================================
+      SUBROUTINE SLASET( UPLO, M, N, ALPHA, BETA, A, LDA )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          UPLO
+      INTEGER            LDA, M, N
+      REAL               ALPHA, BETA
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * )
+*     ..
+*
+* =====================================================================
+*
+*     .. Local Scalars ..
+      INTEGER            I, J
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      EXTERNAL           LSAME
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MIN
+*     ..
+*     .. Executable Statements ..
+*
+      IF( LSAME( UPLO, 'U' ) ) THEN
+*
+*        Set the strictly upper triangular or trapezoidal part of the
+*        array to ALPHA.
+*
+         DO 20 J = 2, N
+            DO 10 I = 1, MIN( J-1, M )
+               A( I, J ) = ALPHA
+   10       CONTINUE
+   20    CONTINUE
+*
+      ELSE IF( LSAME( UPLO, 'L' ) ) THEN
+*
+*        Set the strictly lower triangular or trapezoidal part of the
+*        array to ALPHA.
+*
+         DO 40 J = 1, MIN( M, N )
+            DO 30 I = J + 1, M
+               A( I, J ) = ALPHA
+   30       CONTINUE
+   40    CONTINUE
+*
+      ELSE
+*
+*        Set the leading m-by-n submatrix to ALPHA.
+*
+         DO 60 J = 1, N
+            DO 50 I = 1, M
+               A( I, J ) = ALPHA
+   50       CONTINUE
+   60    CONTINUE
+      END IF
+*
+*     Set the first min(M,N) diagonal elements to BETA.
+*
+      DO 70 I = 1, MIN( M, N )
+         A( I, I ) = BETA
+   70 CONTINUE
+*
+      RETURN
+*
+*     End of SLASET
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slasr.f AmberTools/src/quick/src/blas/slasr.f
--- AmberTools/src/quick/src/blas/slasr.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slasr.f	2022-08-30 19:18:39.000000000 +0900
@@ -0,0 +1,436 @@
+*> \brief \b SLASR applies a sequence of plane rotations to a general rectangular matrix.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLASR + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasr.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasr.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasr.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLASR( SIDE, PIVOT, DIRECT, M, N, C, S, A, LDA )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          DIRECT, PIVOT, SIDE
+*       INTEGER            LDA, M, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), C( * ), S( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLASR applies a sequence of plane rotations to a real matrix A,
+*> from either the left or the right.
+*>
+*> When SIDE = 'L', the transformation takes the form
+*>
+*>    A := P*A
+*>
+*> and when SIDE = 'R', the transformation takes the form
+*>
+*>    A := A*P**T
+*>
+*> where P is an orthogonal matrix consisting of a sequence of z plane
+*> rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
+*> and P**T is the transpose of P.
+*>
+*> When DIRECT = 'F' (Forward sequence), then
+*>
+*>    P = P(z-1) * ... * P(2) * P(1)
+*>
+*> and when DIRECT = 'B' (Backward sequence), then
+*>
+*>    P = P(1) * P(2) * ... * P(z-1)
+*>
+*> where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
+*>
+*>    R(k) = (  c(k)  s(k) )
+*>         = ( -s(k)  c(k) ).
+*>
+*> When PIVOT = 'V' (Variable pivot), the rotation is performed
+*> for the plane (k,k+1), i.e., P(k) has the form
+*>
+*>    P(k) = (  1                                            )
+*>           (       ...                                     )
+*>           (              1                                )
+*>           (                   c(k)  s(k)                  )
+*>           (                  -s(k)  c(k)                  )
+*>           (                                1              )
+*>           (                                     ...       )
+*>           (                                            1  )
+*>
+*> where R(k) appears as a rank-2 modification to the identity matrix in
+*> rows and columns k and k+1.
+*>
+*> When PIVOT = 'T' (Top pivot), the rotation is performed for the
+*> plane (1,k+1), so P(k) has the form
+*>
+*>    P(k) = (  c(k)                    s(k)                 )
+*>           (         1                                     )
+*>           (              ...                              )
+*>           (                     1                         )
+*>           ( -s(k)                    c(k)                 )
+*>           (                                 1             )
+*>           (                                      ...      )
+*>           (                                             1 )
+*>
+*> where R(k) appears in rows and columns 1 and k+1.
+*>
+*> Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
+*> performed for the plane (k,z), giving P(k) the form
+*>
+*>    P(k) = ( 1                                             )
+*>           (      ...                                      )
+*>           (             1                                 )
+*>           (                  c(k)                    s(k) )
+*>           (                         1                     )
+*>           (                              ...              )
+*>           (                                     1         )
+*>           (                 -s(k)                    c(k) )
+*>
+*> where R(k) appears in rows and columns k and z.  The rotations are
+*> performed without ever forming P(k) explicitly.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] SIDE
+*> \verbatim
+*>          SIDE is CHARACTER*1
+*>          Specifies whether the plane rotation matrix P is applied to
+*>          A on the left or the right.
+*>          = 'L':  Left, compute A := P*A
+*>          = 'R':  Right, compute A:= A*P**T
+*> \endverbatim
+*>
+*> \param[in] PIVOT
+*> \verbatim
+*>          PIVOT is CHARACTER*1
+*>          Specifies the plane for which P(k) is a plane rotation
+*>          matrix.
+*>          = 'V':  Variable pivot, the plane (k,k+1)
+*>          = 'T':  Top pivot, the plane (1,k+1)
+*>          = 'B':  Bottom pivot, the plane (k,z)
+*> \endverbatim
+*>
+*> \param[in] DIRECT
+*> \verbatim
+*>          DIRECT is CHARACTER*1
+*>          Specifies whether P is a forward or backward sequence of
+*>          plane rotations.
+*>          = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
+*>          = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)
+*> \endverbatim
+*>
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix A.  If m <= 1, an immediate
+*>          return is effected.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix A.  If n <= 1, an
+*>          immediate return is effected.
+*> \endverbatim
+*>
+*> \param[in] C
+*> \verbatim
+*>          C is REAL array, dimension
+*>                  (M-1) if SIDE = 'L'
+*>                  (N-1) if SIDE = 'R'
+*>          The cosines c(k) of the plane rotations.
+*> \endverbatim
+*>
+*> \param[in] S
+*> \verbatim
+*>          S is REAL array, dimension
+*>                  (M-1) if SIDE = 'L'
+*>                  (N-1) if SIDE = 'R'
+*>          The sines s(k) of the plane rotations.  The 2-by-2 plane
+*>          rotation part of the matrix P(k), R(k), has the form
+*>          R(k) = (  c(k)  s(k) )
+*>                 ( -s(k)  c(k) ).
+*> \endverbatim
+*>
+*> \param[in,out] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          The M-by-N matrix A.  On exit, A is overwritten by P*A if
+*>          SIDE = 'R' or by A*P**T if SIDE = 'L'.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A.  LDA >= max(1,M).
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup OTHERauxiliary
+*
+*  =====================================================================
+      SUBROUTINE SLASR( SIDE, PIVOT, DIRECT, M, N, C, S, A, LDA )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          DIRECT, PIVOT, SIDE
+      INTEGER            LDA, M, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), C( * ), S( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE, ZERO
+      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, INFO, J
+      REAL               CTEMP, STEMP, TEMP
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      EXTERNAL           LSAME
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters
+*
+      INFO = 0
+      IF( .NOT.( LSAME( SIDE, 'L' ) .OR. LSAME( SIDE, 'R' ) ) ) THEN
+         INFO = 1
+      ELSE IF( .NOT.( LSAME( PIVOT, 'V' ) .OR. LSAME( PIVOT,
+     $         'T' ) .OR. LSAME( PIVOT, 'B' ) ) ) THEN
+         INFO = 2
+      ELSE IF( .NOT.( LSAME( DIRECT, 'F' ) .OR. LSAME( DIRECT, 'B' ) ) )
+     $          THEN
+         INFO = 3
+      ELSE IF( M.LT.0 ) THEN
+         INFO = 4
+      ELSE IF( N.LT.0 ) THEN
+         INFO = 5
+      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
+         INFO = 9
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SLASR ', INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( ( M.EQ.0 ) .OR. ( N.EQ.0 ) )
+     $   RETURN
+      IF( LSAME( SIDE, 'L' ) ) THEN
+*
+*        Form  P * A
+*
+         IF( LSAME( PIVOT, 'V' ) ) THEN
+            IF( LSAME( DIRECT, 'F' ) ) THEN
+               DO 20 J = 1, M - 1
+                  CTEMP = C( J )
+                  STEMP = S( J )
+                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
+                     DO 10 I = 1, N
+                        TEMP = A( J+1, I )
+                        A( J+1, I ) = CTEMP*TEMP - STEMP*A( J, I )
+                        A( J, I ) = STEMP*TEMP + CTEMP*A( J, I )
+   10                CONTINUE
+                  END IF
+   20          CONTINUE
+            ELSE IF( LSAME( DIRECT, 'B' ) ) THEN
+               DO 40 J = M - 1, 1, -1
+                  CTEMP = C( J )
+                  STEMP = S( J )
+                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
+                     DO 30 I = 1, N
+                        TEMP = A( J+1, I )
+                        A( J+1, I ) = CTEMP*TEMP - STEMP*A( J, I )
+                        A( J, I ) = STEMP*TEMP + CTEMP*A( J, I )
+   30                CONTINUE
+                  END IF
+   40          CONTINUE
+            END IF
+         ELSE IF( LSAME( PIVOT, 'T' ) ) THEN
+            IF( LSAME( DIRECT, 'F' ) ) THEN
+               DO 60 J = 2, M
+                  CTEMP = C( J-1 )
+                  STEMP = S( J-1 )
+                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
+                     DO 50 I = 1, N
+                        TEMP = A( J, I )
+                        A( J, I ) = CTEMP*TEMP - STEMP*A( 1, I )
+                        A( 1, I ) = STEMP*TEMP + CTEMP*A( 1, I )
+   50                CONTINUE
+                  END IF
+   60          CONTINUE
+            ELSE IF( LSAME( DIRECT, 'B' ) ) THEN
+               DO 80 J = M, 2, -1
+                  CTEMP = C( J-1 )
+                  STEMP = S( J-1 )
+                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
+                     DO 70 I = 1, N
+                        TEMP = A( J, I )
+                        A( J, I ) = CTEMP*TEMP - STEMP*A( 1, I )
+                        A( 1, I ) = STEMP*TEMP + CTEMP*A( 1, I )
+   70                CONTINUE
+                  END IF
+   80          CONTINUE
+            END IF
+         ELSE IF( LSAME( PIVOT, 'B' ) ) THEN
+            IF( LSAME( DIRECT, 'F' ) ) THEN
+               DO 100 J = 1, M - 1
+                  CTEMP = C( J )
+                  STEMP = S( J )
+                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
+                     DO 90 I = 1, N
+                        TEMP = A( J, I )
+                        A( J, I ) = STEMP*A( M, I ) + CTEMP*TEMP
+                        A( M, I ) = CTEMP*A( M, I ) - STEMP*TEMP
+   90                CONTINUE
+                  END IF
+  100          CONTINUE
+            ELSE IF( LSAME( DIRECT, 'B' ) ) THEN
+               DO 120 J = M - 1, 1, -1
+                  CTEMP = C( J )
+                  STEMP = S( J )
+                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
+                     DO 110 I = 1, N
+                        TEMP = A( J, I )
+                        A( J, I ) = STEMP*A( M, I ) + CTEMP*TEMP
+                        A( M, I ) = CTEMP*A( M, I ) - STEMP*TEMP
+  110                CONTINUE
+                  END IF
+  120          CONTINUE
+            END IF
+         END IF
+      ELSE IF( LSAME( SIDE, 'R' ) ) THEN
+*
+*        Form A * P**T
+*
+         IF( LSAME( PIVOT, 'V' ) ) THEN
+            IF( LSAME( DIRECT, 'F' ) ) THEN
+               DO 140 J = 1, N - 1
+                  CTEMP = C( J )
+                  STEMP = S( J )
+                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
+                     DO 130 I = 1, M
+                        TEMP = A( I, J+1 )
+                        A( I, J+1 ) = CTEMP*TEMP - STEMP*A( I, J )
+                        A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )
+  130                CONTINUE
+                  END IF
+  140          CONTINUE
+            ELSE IF( LSAME( DIRECT, 'B' ) ) THEN
+               DO 160 J = N - 1, 1, -1
+                  CTEMP = C( J )
+                  STEMP = S( J )
+                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
+                     DO 150 I = 1, M
+                        TEMP = A( I, J+1 )
+                        A( I, J+1 ) = CTEMP*TEMP - STEMP*A( I, J )
+                        A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )
+  150                CONTINUE
+                  END IF
+  160          CONTINUE
+            END IF
+         ELSE IF( LSAME( PIVOT, 'T' ) ) THEN
+            IF( LSAME( DIRECT, 'F' ) ) THEN
+               DO 180 J = 2, N
+                  CTEMP = C( J-1 )
+                  STEMP = S( J-1 )
+                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
+                     DO 170 I = 1, M
+                        TEMP = A( I, J )
+                        A( I, J ) = CTEMP*TEMP - STEMP*A( I, 1 )
+                        A( I, 1 ) = STEMP*TEMP + CTEMP*A( I, 1 )
+  170                CONTINUE
+                  END IF
+  180          CONTINUE
+            ELSE IF( LSAME( DIRECT, 'B' ) ) THEN
+               DO 200 J = N, 2, -1
+                  CTEMP = C( J-1 )
+                  STEMP = S( J-1 )
+                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
+                     DO 190 I = 1, M
+                        TEMP = A( I, J )
+                        A( I, J ) = CTEMP*TEMP - STEMP*A( I, 1 )
+                        A( I, 1 ) = STEMP*TEMP + CTEMP*A( I, 1 )
+  190                CONTINUE
+                  END IF
+  200          CONTINUE
+            END IF
+         ELSE IF( LSAME( PIVOT, 'B' ) ) THEN
+            IF( LSAME( DIRECT, 'F' ) ) THEN
+               DO 220 J = 1, N - 1
+                  CTEMP = C( J )
+                  STEMP = S( J )
+                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
+                     DO 210 I = 1, M
+                        TEMP = A( I, J )
+                        A( I, J ) = STEMP*A( I, N ) + CTEMP*TEMP
+                        A( I, N ) = CTEMP*A( I, N ) - STEMP*TEMP
+  210                CONTINUE
+                  END IF
+  220          CONTINUE
+            ELSE IF( LSAME( DIRECT, 'B' ) ) THEN
+               DO 240 J = N - 1, 1, -1
+                  CTEMP = C( J )
+                  STEMP = S( J )
+                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN
+                     DO 230 I = 1, M
+                        TEMP = A( I, J )
+                        A( I, J ) = STEMP*A( I, N ) + CTEMP*TEMP
+                        A( I, N ) = CTEMP*A( I, N ) - STEMP*TEMP
+  230                CONTINUE
+                  END IF
+  240          CONTINUE
+            END IF
+         END IF
+      END IF
+*
+      RETURN
+*
+*     End of SLASR
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slasrt.f AmberTools/src/quick/src/blas/slasrt.f
--- AmberTools/src/quick/src/blas/slasrt.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slasrt.f	2022-08-30 19:17:53.000000000 +0900
@@ -0,0 +1,303 @@
+*> \brief \b SLASRT sorts numbers in increasing or decreasing order.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLASRT + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slasrt.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slasrt.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slasrt.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLASRT( ID, N, D, INFO )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          ID
+*       INTEGER            INFO, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               D( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> Sort the numbers in D in increasing order (if ID = 'I') or
+*> in decreasing order (if ID = 'D' ).
+*>
+*> Use Quick Sort, reverting to Insertion sort on arrays of
+*> size <= 20. Dimension of STACK limits N to about 2**32.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] ID
+*> \verbatim
+*>          ID is CHARACTER*1
+*>          = 'I': sort D in increasing order;
+*>          = 'D': sort D in decreasing order.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The length of the array D.
+*> \endverbatim
+*>
+*> \param[in,out] D
+*> \verbatim
+*>          D is REAL array, dimension (N)
+*>          On entry, the array to be sorted.
+*>          On exit, D has been sorted into increasing order
+*>          (D(1) <= ... <= D(N) ) or into decreasing order
+*>          (D(1) >= ... >= D(N) ), depending on ID.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument had an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date June 2016
+*
+*> \ingroup auxOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SLASRT( ID, N, D, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     June 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          ID
+      INTEGER            INFO, N
+*     ..
+*     .. Array Arguments ..
+      REAL               D( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      INTEGER            SELECT
+      PARAMETER          ( SELECT = 20 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            DIR, ENDD, I, J, START, STKPNT
+      REAL               D1, D2, D3, DMNMX, TMP
+*     ..
+*     .. Local Arrays ..
+      INTEGER            STACK( 2, 32 )
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      EXTERNAL           LSAME
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           XERBLA
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters.
+*
+      INFO = 0
+      DIR = -1
+      IF( LSAME( ID, 'D' ) ) THEN
+         DIR = 0
+      ELSE IF( LSAME( ID, 'I' ) ) THEN
+         DIR = 1
+      END IF
+      IF( DIR.EQ.-1 ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -2
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SLASRT', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.LE.1 )
+     $   RETURN
+*
+      STKPNT = 1
+      STACK( 1, 1 ) = 1
+      STACK( 2, 1 ) = N
+   10 CONTINUE
+      START = STACK( 1, STKPNT )
+      ENDD = STACK( 2, STKPNT )
+      STKPNT = STKPNT - 1
+      IF( ENDD-START.LE.SELECT .AND. ENDD-START.GT.0 ) THEN
+*
+*        Do Insertion sort on D( START:ENDD )
+*
+         IF( DIR.EQ.0 ) THEN
+*
+*           Sort into decreasing order
+*
+            DO 30 I = START + 1, ENDD
+               DO 20 J = I, START + 1, -1
+                  IF( D( J ).GT.D( J-1 ) ) THEN
+                     DMNMX = D( J )
+                     D( J ) = D( J-1 )
+                     D( J-1 ) = DMNMX
+                  ELSE
+                     GO TO 30
+                  END IF
+   20          CONTINUE
+   30       CONTINUE
+*
+         ELSE
+*
+*           Sort into increasing order
+*
+            DO 50 I = START + 1, ENDD
+               DO 40 J = I, START + 1, -1
+                  IF( D( J ).LT.D( J-1 ) ) THEN
+                     DMNMX = D( J )
+                     D( J ) = D( J-1 )
+                     D( J-1 ) = DMNMX
+                  ELSE
+                     GO TO 50
+                  END IF
+   40          CONTINUE
+   50       CONTINUE
+*
+         END IF
+*
+      ELSE IF( ENDD-START.GT.SELECT ) THEN
+*
+*        Partition D( START:ENDD ) and stack parts, largest one first
+*
+*        Choose partition entry as median of 3
+*
+         D1 = D( START )
+         D2 = D( ENDD )
+         I = ( START+ENDD ) / 2
+         D3 = D( I )
+         IF( D1.LT.D2 ) THEN
+            IF( D3.LT.D1 ) THEN
+               DMNMX = D1
+            ELSE IF( D3.LT.D2 ) THEN
+               DMNMX = D3
+            ELSE
+               DMNMX = D2
+            END IF
+         ELSE
+            IF( D3.LT.D2 ) THEN
+               DMNMX = D2
+            ELSE IF( D3.LT.D1 ) THEN
+               DMNMX = D3
+            ELSE
+               DMNMX = D1
+            END IF
+         END IF
+*
+         IF( DIR.EQ.0 ) THEN
+*
+*           Sort into decreasing order
+*
+            I = START - 1
+            J = ENDD + 1
+   60       CONTINUE
+   70       CONTINUE
+            J = J - 1
+            IF( D( J ).LT.DMNMX )
+     $         GO TO 70
+   80       CONTINUE
+            I = I + 1
+            IF( D( I ).GT.DMNMX )
+     $         GO TO 80
+            IF( I.LT.J ) THEN
+               TMP = D( I )
+               D( I ) = D( J )
+               D( J ) = TMP
+               GO TO 60
+            END IF
+            IF( J-START.GT.ENDD-J-1 ) THEN
+               STKPNT = STKPNT + 1
+               STACK( 1, STKPNT ) = START
+               STACK( 2, STKPNT ) = J
+               STKPNT = STKPNT + 1
+               STACK( 1, STKPNT ) = J + 1
+               STACK( 2, STKPNT ) = ENDD
+            ELSE
+               STKPNT = STKPNT + 1
+               STACK( 1, STKPNT ) = J + 1
+               STACK( 2, STKPNT ) = ENDD
+               STKPNT = STKPNT + 1
+               STACK( 1, STKPNT ) = START
+               STACK( 2, STKPNT ) = J
+            END IF
+         ELSE
+*
+*           Sort into increasing order
+*
+            I = START - 1
+            J = ENDD + 1
+   90       CONTINUE
+  100       CONTINUE
+            J = J - 1
+            IF( D( J ).GT.DMNMX )
+     $         GO TO 100
+  110       CONTINUE
+            I = I + 1
+            IF( D( I ).LT.DMNMX )
+     $         GO TO 110
+            IF( I.LT.J ) THEN
+               TMP = D( I )
+               D( I ) = D( J )
+               D( J ) = TMP
+               GO TO 90
+            END IF
+            IF( J-START.GT.ENDD-J-1 ) THEN
+               STKPNT = STKPNT + 1
+               STACK( 1, STKPNT ) = START
+               STACK( 2, STKPNT ) = J
+               STKPNT = STKPNT + 1
+               STACK( 1, STKPNT ) = J + 1
+               STACK( 2, STKPNT ) = ENDD
+            ELSE
+               STKPNT = STKPNT + 1
+               STACK( 1, STKPNT ) = J + 1
+               STACK( 2, STKPNT ) = ENDD
+               STKPNT = STKPNT + 1
+               STACK( 1, STKPNT ) = START
+               STACK( 2, STKPNT ) = J
+            END IF
+         END IF
+      END IF
+      IF( STKPNT.GT.0 )
+     $   GO TO 10
+      RETURN
+*
+*     End of SLASRT
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slassq.f AmberTools/src/quick/src/blas/slassq.f
--- AmberTools/src/quick/src/blas/slassq.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slassq.f	2022-08-30 19:20:05.000000000 +0900
@@ -0,0 +1,155 @@
+*> \brief \b SLASSQ updates a sum of squares represented in scaled form.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLASSQ + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slassq.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slassq.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slassq.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLASSQ( N, X, INCX, SCALE, SUMSQ )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            INCX, N
+*       REAL               SCALE, SUMSQ
+*       ..
+*       .. Array Arguments ..
+*       REAL               X( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLASSQ  returns the values  scl  and  smsq  such that
+*>
+*>    ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,
+*>
+*> where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
+*> assumed to be non-negative and  scl  returns the value
+*>
+*>    scl = max( scale, abs( x( i ) ) ).
+*>
+*> scale and sumsq must be supplied in SCALE and SUMSQ and
+*> scl and smsq are overwritten on SCALE and SUMSQ respectively.
+*>
+*> The routine makes only one pass through the vector x.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of elements to be used from the vector X.
+*> \endverbatim
+*>
+*> \param[in] X
+*> \verbatim
+*>          X is REAL array, dimension (1+(N-1)*INCX)
+*>          The vector for which a scaled sum of squares is computed.
+*>             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 <= i <= n.
+*> \endverbatim
+*>
+*> \param[in] INCX
+*> \verbatim
+*>          INCX is INTEGER
+*>          The increment between successive values of the vector X.
+*>          INCX > 0.
+*> \endverbatim
+*>
+*> \param[in,out] SCALE
+*> \verbatim
+*>          SCALE is REAL
+*>          On entry, the value  scale  in the equation above.
+*>          On exit, SCALE is overwritten with  scl , the scaling factor
+*>          for the sum of squares.
+*> \endverbatim
+*>
+*> \param[in,out] SUMSQ
+*> \verbatim
+*>          SUMSQ is REAL
+*>          On entry, the value  sumsq  in the equation above.
+*>          On exit, SUMSQ is overwritten with  smsq , the basic sum of
+*>          squares from which  scl  has been factored out.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup OTHERauxiliary
+*
+*  =====================================================================
+      SUBROUTINE SLASSQ( N, X, INCX, SCALE, SUMSQ )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      INTEGER            INCX, N
+      REAL               SCALE, SUMSQ
+*     ..
+*     .. Array Arguments ..
+      REAL               X( * )
+*     ..
+*
+* =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO
+      PARAMETER          ( ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            IX
+      REAL               ABSXI
+*     ..
+*     .. External Functions ..
+      LOGICAL            SISNAN
+      EXTERNAL           SISNAN
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS
+*     ..
+*     .. Executable Statements ..
+*
+      IF( N.GT.0 ) THEN
+         DO 10 IX = 1, 1 + ( N-1 )*INCX, INCX
+            ABSXI = ABS( X( IX ) )
+            IF( ABSXI.GT.ZERO.OR.SISNAN( ABSXI ) ) THEN
+               IF( SCALE.LT.ABSXI ) THEN
+                  SUMSQ = 1 + SUMSQ*( SCALE / ABSXI )**2
+                  SCALE = ABSXI
+               ELSE
+                  SUMSQ = SUMSQ + ( ABSXI / SCALE )**2
+               END IF
+            END IF
+   10    CONTINUE
+      END IF
+      RETURN
+*
+*     End of SLASSQ
+*
+      END
diff -uN AmberTools/src/quick/src/blas/slatrd.f AmberTools/src/quick/src/blas/slatrd.f
--- AmberTools/src/quick/src/blas/slatrd.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/slatrd.f	2022-08-30 19:21:50.000000000 +0900
@@ -0,0 +1,336 @@
+*> \brief \b SLATRD reduces the first nb rows and columns of a symmetric/Hermitian matrix A to real tridiagonal form by an orthogonal similarity transformation.
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SLATRD + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/slatrd.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/slatrd.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/slatrd.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SLATRD( UPLO, N, NB, A, LDA, E, TAU, W, LDW )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          UPLO
+*       INTEGER            LDA, LDW, N, NB
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), E( * ), TAU( * ), W( LDW, * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SLATRD reduces NB rows and columns of a real symmetric matrix A to
+*> symmetric tridiagonal form by an orthogonal similarity
+*> transformation Q**T * A * Q, and returns the matrices V and W which are
+*> needed to apply the transformation to the unreduced part of A.
+*>
+*> If UPLO = 'U', SLATRD reduces the last NB rows and columns of a
+*> matrix, of which the upper triangle is supplied;
+*> if UPLO = 'L', SLATRD reduces the first NB rows and columns of a
+*> matrix, of which the lower triangle is supplied.
+*>
+*> This is an auxiliary routine called by SSYTRD.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] UPLO
+*> \verbatim
+*>          UPLO is CHARACTER*1
+*>          Specifies whether the upper or lower triangular part of the
+*>          symmetric matrix A is stored:
+*>          = 'U': Upper triangular
+*>          = 'L': Lower triangular
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the matrix A.
+*> \endverbatim
+*>
+*> \param[in] NB
+*> \verbatim
+*>          NB is INTEGER
+*>          The number of rows and columns to be reduced.
+*> \endverbatim
+*>
+*> \param[in,out] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
+*>          n-by-n upper triangular part of A contains the upper
+*>          triangular part of the matrix A, and the strictly lower
+*>          triangular part of A is not referenced.  If UPLO = 'L', the
+*>          leading n-by-n lower triangular part of A contains the lower
+*>          triangular part of the matrix A, and the strictly upper
+*>          triangular part of A is not referenced.
+*>          On exit:
+*>          if UPLO = 'U', the last NB columns have been reduced to
+*>            tridiagonal form, with the diagonal elements overwriting
+*>            the diagonal elements of A; the elements above the diagonal
+*>            with the array TAU, represent the orthogonal matrix Q as a
+*>            product of elementary reflectors;
+*>          if UPLO = 'L', the first NB columns have been reduced to
+*>            tridiagonal form, with the diagonal elements overwriting
+*>            the diagonal elements of A; the elements below the diagonal
+*>            with the array TAU, represent the  orthogonal matrix Q as a
+*>            product of elementary reflectors.
+*>          See Further Details.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A.  LDA >= (1,N).
+*> \endverbatim
+*>
+*> \param[out] E
+*> \verbatim
+*>          E is REAL array, dimension (N-1)
+*>          If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
+*>          elements of the last NB columns of the reduced matrix;
+*>          if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
+*>          the first NB columns of the reduced matrix.
+*> \endverbatim
+*>
+*> \param[out] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension (N-1)
+*>          The scalar factors of the elementary reflectors, stored in
+*>          TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
+*>          See Further Details.
+*> \endverbatim
+*>
+*> \param[out] W
+*> \verbatim
+*>          W is REAL array, dimension (LDW,NB)
+*>          The n-by-nb matrix W required to update the unreduced part
+*>          of A.
+*> \endverbatim
+*>
+*> \param[in] LDW
+*> \verbatim
+*>          LDW is INTEGER
+*>          The leading dimension of the array W. LDW >= max(1,N).
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup doubleOTHERauxiliary
+*
+*> \par Further Details:
+*  =====================
+*>
+*> \verbatim
+*>
+*>  If UPLO = 'U', the matrix Q is represented as a product of elementary
+*>  reflectors
+*>
+*>     Q = H(n) H(n-1) . . . H(n-nb+1).
+*>
+*>  Each H(i) has the form
+*>
+*>     H(i) = I - tau * v * v**T
+*>
+*>  where tau is a real scalar, and v is a real vector with
+*>  v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
+*>  and tau in TAU(i-1).
+*>
+*>  If UPLO = 'L', the matrix Q is represented as a product of elementary
+*>  reflectors
+*>
+*>     Q = H(1) H(2) . . . H(nb).
+*>
+*>  Each H(i) has the form
+*>
+*>     H(i) = I - tau * v * v**T
+*>
+*>  where tau is a real scalar, and v is a real vector with
+*>  v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
+*>  and tau in TAU(i).
+*>
+*>  The elements of the vectors v together form the n-by-nb matrix V
+*>  which is needed, with W, to apply the transformation to the unreduced
+*>  part of the matrix, using a symmetric rank-2k update of the form:
+*>  A := A - V*W**T - W*V**T.
+*>
+*>  The contents of A on exit are illustrated by the following examples
+*>  with n = 5 and nb = 2:
+*>
+*>  if UPLO = 'U':                       if UPLO = 'L':
+*>
+*>    (  a   a   a   v4  v5 )              (  d                  )
+*>    (      a   a   v4  v5 )              (  1   d              )
+*>    (          a   1   v5 )              (  v1  1   a          )
+*>    (              d   1  )              (  v1  v2  a   a      )
+*>    (                  d  )              (  v1  v2  a   a   a  )
+*>
+*>  where d denotes a diagonal element of the reduced matrix, a denotes
+*>  an element of the original matrix that is unchanged, and vi denotes
+*>  an element of the vector defining H(i).
+*> \endverbatim
+*>
+*  =====================================================================
+      SUBROUTINE SLATRD( UPLO, N, NB, A, LDA, E, TAU, W, LDW )
+*
+*  -- LAPACK auxiliary routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          UPLO
+      INTEGER            LDA, LDW, N, NB
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), E( * ), TAU( * ), W( LDW, * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO, ONE, HALF
+      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0, HALF = 0.5E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, IW
+      REAL               ALPHA
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SAXPY, SGEMV, SLARFG, SSCAL, SSYMV
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      REAL               SDOT
+      EXTERNAL           LSAME, SDOT
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MIN
+*     ..
+*     .. Executable Statements ..
+*
+*     Quick return if possible
+*
+      IF( N.LE.0 )
+     $   RETURN
+*
+      IF( LSAME( UPLO, 'U' ) ) THEN
+*
+*        Reduce last NB columns of upper triangle
+*
+         DO 10 I = N, N - NB + 1, -1
+            IW = I - N + NB
+            IF( I.LT.N ) THEN
+*
+*              Update A(1:i,i)
+*
+               CALL SGEMV( 'No transpose', I, N-I, -ONE, A( 1, I+1 ),
+     $                     LDA, W( I, IW+1 ), LDW, ONE, A( 1, I ), 1 )
+               CALL SGEMV( 'No transpose', I, N-I, -ONE, W( 1, IW+1 ),
+     $                     LDW, A( I, I+1 ), LDA, ONE, A( 1, I ), 1 )
+            END IF
+            IF( I.GT.1 ) THEN
+*
+*              Generate elementary reflector H(i) to annihilate
+*              A(1:i-2,i)
+*
+               CALL SLARFG( I-1, A( I-1, I ), A( 1, I ), 1, TAU( I-1 ) )
+               E( I-1 ) = A( I-1, I )
+               A( I-1, I ) = ONE
+*
+*              Compute W(1:i-1,i)
+*
+               CALL SSYMV( 'Upper', I-1, ONE, A, LDA, A( 1, I ), 1,
+     $                     ZERO, W( 1, IW ), 1 )
+               IF( I.LT.N ) THEN
+                  CALL SGEMV( 'Transpose', I-1, N-I, ONE, W( 1, IW+1 ),
+     $                        LDW, A( 1, I ), 1, ZERO, W( I+1, IW ), 1 )
+                  CALL SGEMV( 'No transpose', I-1, N-I, -ONE,
+     $                        A( 1, I+1 ), LDA, W( I+1, IW ), 1, ONE,
+     $                        W( 1, IW ), 1 )
+                  CALL SGEMV( 'Transpose', I-1, N-I, ONE, A( 1, I+1 ),
+     $                        LDA, A( 1, I ), 1, ZERO, W( I+1, IW ), 1 )
+                  CALL SGEMV( 'No transpose', I-1, N-I, -ONE,
+     $                        W( 1, IW+1 ), LDW, W( I+1, IW ), 1, ONE,
+     $                        W( 1, IW ), 1 )
+               END IF
+               CALL SSCAL( I-1, TAU( I-1 ), W( 1, IW ), 1 )
+               ALPHA = -HALF*TAU( I-1 )*SDOT( I-1, W( 1, IW ), 1,
+     $                 A( 1, I ), 1 )
+               CALL SAXPY( I-1, ALPHA, A( 1, I ), 1, W( 1, IW ), 1 )
+            END IF
+*
+   10    CONTINUE
+      ELSE
+*
+*        Reduce first NB columns of lower triangle
+*
+         DO 20 I = 1, NB
+*
+*           Update A(i:n,i)
+*
+            CALL SGEMV( 'No transpose', N-I+1, I-1, -ONE, A( I, 1 ),
+     $                  LDA, W( I, 1 ), LDW, ONE, A( I, I ), 1 )
+            CALL SGEMV( 'No transpose', N-I+1, I-1, -ONE, W( I, 1 ),
+     $                  LDW, A( I, 1 ), LDA, ONE, A( I, I ), 1 )
+            IF( I.LT.N ) THEN
+*
+*              Generate elementary reflector H(i) to annihilate
+*              A(i+2:n,i)
+*
+               CALL SLARFG( N-I, A( I+1, I ), A( MIN( I+2, N ), I ), 1,
+     $                      TAU( I ) )
+               E( I ) = A( I+1, I )
+               A( I+1, I ) = ONE
+*
+*              Compute W(i+1:n,i)
+*
+               CALL SSYMV( 'Lower', N-I, ONE, A( I+1, I+1 ), LDA,
+     $                     A( I+1, I ), 1, ZERO, W( I+1, I ), 1 )
+               CALL SGEMV( 'Transpose', N-I, I-1, ONE, W( I+1, 1 ), LDW,
+     $                     A( I+1, I ), 1, ZERO, W( 1, I ), 1 )
+               CALL SGEMV( 'No transpose', N-I, I-1, -ONE, A( I+1, 1 ),
+     $                     LDA, W( 1, I ), 1, ONE, W( I+1, I ), 1 )
+               CALL SGEMV( 'Transpose', N-I, I-1, ONE, A( I+1, 1 ), LDA,
+     $                     A( I+1, I ), 1, ZERO, W( 1, I ), 1 )
+               CALL SGEMV( 'No transpose', N-I, I-1, -ONE, W( I+1, 1 ),
+     $                     LDW, W( 1, I ), 1, ONE, W( I+1, I ), 1 )
+               CALL SSCAL( N-I, TAU( I ), W( I+1, I ), 1 )
+               ALPHA = -HALF*TAU( I )*SDOT( N-I, W( I+1, I ), 1,
+     $                 A( I+1, I ), 1 )
+               CALL SAXPY( N-I, ALPHA, A( I+1, I ), 1, W( I+1, I ), 1 )
+            END IF
+*
+   20    CONTINUE
+      END IF
+*
+      RETURN
+*
+*     End of SLATRD
+*
+      END
diff -uN AmberTools/src/quick/src/blas/sorg2l.f AmberTools/src/quick/src/blas/sorg2l.f
--- AmberTools/src/quick/src/blas/sorg2l.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/sorg2l.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,198 @@
+*> \brief \b SORG2L generates all or part of the orthogonal matrix Q from a QL factorization determined by sgeqlf (unblocked algorithm).
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SORG2L + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sorg2l.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sorg2l.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorg2l.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SORG2L( M, N, K, A, LDA, TAU, WORK, INFO )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            INFO, K, LDA, M, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), TAU( * ), WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SORG2L generates an m by n real matrix Q with orthonormal columns,
+*> which is defined as the last n columns of a product of k elementary
+*> reflectors of order m
+*>
+*>       Q  =  H(k) . . . H(2) H(1)
+*>
+*> as returned by SGEQLF.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix Q. M >= 0.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix Q. M >= N >= 0.
+*> \endverbatim
+*>
+*> \param[in] K
+*> \verbatim
+*>          K is INTEGER
+*>          The number of elementary reflectors whose product defines the
+*>          matrix Q. N >= K >= 0.
+*> \endverbatim
+*>
+*> \param[in,out] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          On entry, the (n-k+i)-th column must contain the vector which
+*>          defines the elementary reflector H(i), for i = 1,2,...,k, as
+*>          returned by SGEQLF in the last k columns of its array
+*>          argument A.
+*>          On exit, the m by n matrix Q.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The first dimension of the array A. LDA >= max(1,M).
+*> \endverbatim
+*>
+*> \param[in] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension (K)
+*>          TAU(i) must contain the scalar factor of the elementary
+*>          reflector H(i), as returned by SGEQLF.
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (N)
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0: successful exit
+*>          < 0: if INFO = -i, the i-th argument has an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SORG2L( M, N, K, A, LDA, TAU, WORK, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      INTEGER            INFO, K, LDA, M, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), TAU( * ), WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE, ZERO
+      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, II, J, L
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLARF, SSCAL, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input arguments
+*
+      INFO = 0
+      IF( M.LT.0 ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 .OR. N.GT.M ) THEN
+         INFO = -2
+      ELSE IF( K.LT.0 .OR. K.GT.N ) THEN
+         INFO = -3
+      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
+         INFO = -5
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SORG2L', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.LE.0 )
+     $   RETURN
+*
+*     Initialise columns 1:n-k to columns of the unit matrix
+*
+      DO 20 J = 1, N - K
+         DO 10 L = 1, M
+            A( L, J ) = ZERO
+   10    CONTINUE
+         A( M-N+J, J ) = ONE
+   20 CONTINUE
+*
+      DO 40 I = 1, K
+         II = N - K + I
+*
+*        Apply H(i) to A(1:m-k+i,1:n-k+i) from the left
+*
+         A( M-N+II, II ) = ONE
+         CALL SLARF( 'Left', M-N+II, II-1, A( 1, II ), 1, TAU( I ), A,
+     $               LDA, WORK )
+         CALL SSCAL( M-N+II-1, -TAU( I ), A( 1, II ), 1 )
+         A( M-N+II, II ) = ONE - TAU( I )
+*
+*        Set A(m-k+i+1:m,n-k+i) to zero
+*
+         DO 30 L = M - N + II + 1, M
+            A( L, II ) = ZERO
+   30    CONTINUE
+   40 CONTINUE
+      RETURN
+*
+*     End of SORG2L
+*
+      END
diff -uN AmberTools/src/quick/src/blas/sorg2r.f AmberTools/src/quick/src/blas/sorg2r.f
--- AmberTools/src/quick/src/blas/sorg2r.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/sorg2r.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,200 @@
+*> \brief \b SORG2R generates all or part of the orthogonal matrix Q from a QR factorization determined by sgeqrf (unblocked algorithm).
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SORG2R + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sorg2r.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sorg2r.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorg2r.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SORG2R( M, N, K, A, LDA, TAU, WORK, INFO )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            INFO, K, LDA, M, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), TAU( * ), WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SORG2R generates an m by n real matrix Q with orthonormal columns,
+*> which is defined as the first n columns of a product of k elementary
+*> reflectors of order m
+*>
+*>       Q  =  H(1) H(2) . . . H(k)
+*>
+*> as returned by SGEQRF.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix Q. M >= 0.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix Q. M >= N >= 0.
+*> \endverbatim
+*>
+*> \param[in] K
+*> \verbatim
+*>          K is INTEGER
+*>          The number of elementary reflectors whose product defines the
+*>          matrix Q. N >= K >= 0.
+*> \endverbatim
+*>
+*> \param[in,out] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          On entry, the i-th column must contain the vector which
+*>          defines the elementary reflector H(i), for i = 1,2,...,k, as
+*>          returned by SGEQRF in the first k columns of its array
+*>          argument A.
+*>          On exit, the m-by-n matrix Q.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The first dimension of the array A. LDA >= max(1,M).
+*> \endverbatim
+*>
+*> \param[in] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension (K)
+*>          TAU(i) must contain the scalar factor of the elementary
+*>          reflector H(i), as returned by SGEQRF.
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (N)
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0: successful exit
+*>          < 0: if INFO = -i, the i-th argument has an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SORG2R( M, N, K, A, LDA, TAU, WORK, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      INTEGER            INFO, K, LDA, M, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), TAU( * ), WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE, ZERO
+      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, J, L
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLARF, SSCAL, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input arguments
+*
+      INFO = 0
+      IF( M.LT.0 ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 .OR. N.GT.M ) THEN
+         INFO = -2
+      ELSE IF( K.LT.0 .OR. K.GT.N ) THEN
+         INFO = -3
+      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
+         INFO = -5
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SORG2R', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.LE.0 )
+     $   RETURN
+*
+*     Initialise columns k+1:n to columns of the unit matrix
+*
+      DO 20 J = K + 1, N
+         DO 10 L = 1, M
+            A( L, J ) = ZERO
+   10    CONTINUE
+         A( J, J ) = ONE
+   20 CONTINUE
+*
+      DO 40 I = K, 1, -1
+*
+*        Apply H(i) to A(i:m,i:n) from the left
+*
+         IF( I.LT.N ) THEN
+            A( I, I ) = ONE
+            CALL SLARF( 'Left', M-I+1, N-I, A( I, I ), 1, TAU( I ),
+     $                  A( I, I+1 ), LDA, WORK )
+         END IF
+         IF( I.LT.M )
+     $      CALL SSCAL( M-I, -TAU( I ), A( I+1, I ), 1 )
+         A( I, I ) = ONE - TAU( I )
+*
+*        Set A(1:i-1,i) to zero
+*
+         DO 30 L = 1, I - 1
+            A( L, I ) = ZERO
+   30    CONTINUE
+   40 CONTINUE
+      RETURN
+*
+*     End of SORG2R
+*
+      END
diff -uN AmberTools/src/quick/src/blas/sorgql.f AmberTools/src/quick/src/blas/sorgql.f
--- AmberTools/src/quick/src/blas/sorgql.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/sorgql.f	2022-08-30 19:19:18.000000000 +0900
@@ -0,0 +1,296 @@
+*> \brief \b SORGQL
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SORGQL + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sorgql.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sorgql.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorgql.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SORGQL( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            INFO, K, LDA, LWORK, M, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), TAU( * ), WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SORGQL generates an M-by-N real matrix Q with orthonormal columns,
+*> which is defined as the last N columns of a product of K elementary
+*> reflectors of order M
+*>
+*>       Q  =  H(k) . . . H(2) H(1)
+*>
+*> as returned by SGEQLF.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix Q. M >= 0.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix Q. M >= N >= 0.
+*> \endverbatim
+*>
+*> \param[in] K
+*> \verbatim
+*>          K is INTEGER
+*>          The number of elementary reflectors whose product defines the
+*>          matrix Q. N >= K >= 0.
+*> \endverbatim
+*>
+*> \param[in,out] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          On entry, the (n-k+i)-th column must contain the vector which
+*>          defines the elementary reflector H(i), for i = 1,2,...,k, as
+*>          returned by SGEQLF in the last k columns of its array
+*>          argument A.
+*>          On exit, the M-by-N matrix Q.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The first dimension of the array A. LDA >= max(1,M).
+*> \endverbatim
+*>
+*> \param[in] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension (K)
+*>          TAU(i) must contain the scalar factor of the elementary
+*>          reflector H(i), as returned by SGEQLF.
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (MAX(1,LWORK))
+*>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
+*> \endverbatim
+*>
+*> \param[in] LWORK
+*> \verbatim
+*>          LWORK is INTEGER
+*>          The dimension of the array WORK. LWORK >= max(1,N).
+*>          For optimum performance LWORK >= N*NB, where NB is the
+*>          optimal blocksize.
+*>
+*>          If LWORK = -1, then a workspace query is assumed; the routine
+*>          only calculates the optimal size of the WORK array, returns
+*>          this value as the first entry of the WORK array, and no error
+*>          message related to LWORK is issued by XERBLA.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument has an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SORGQL( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      INTEGER            INFO, K, LDA, LWORK, M, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), TAU( * ), WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO
+      PARAMETER          ( ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            LQUERY
+      INTEGER            I, IB, IINFO, IWS, J, KK, L, LDWORK, LWKOPT,
+     $                   NB, NBMIN, NX
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLARFB, SLARFT, SORG2L, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX, MIN
+*     ..
+*     .. External Functions ..
+      INTEGER            ILAENV
+      EXTERNAL           ILAENV
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input arguments
+*
+      INFO = 0
+      LQUERY = ( LWORK.EQ.-1 )
+      IF( M.LT.0 ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 .OR. N.GT.M ) THEN
+         INFO = -2
+      ELSE IF( K.LT.0 .OR. K.GT.N ) THEN
+         INFO = -3
+      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
+         INFO = -5
+      END IF
+*
+      IF( INFO.EQ.0 ) THEN
+         IF( N.EQ.0 ) THEN
+            LWKOPT = 1
+         ELSE
+            NB = ILAENV( 1, 'SORGQL', ' ', M, N, K, -1 )
+            LWKOPT = N*NB
+         END IF
+         WORK( 1 ) = LWKOPT
+*
+         IF( LWORK.LT.MAX( 1, N ) .AND. .NOT.LQUERY ) THEN
+            INFO = -8
+         END IF
+      END IF
+*
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SORGQL', -INFO )
+         RETURN
+      ELSE IF( LQUERY ) THEN
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.LE.0 ) THEN
+         RETURN
+      END IF
+*
+      NBMIN = 2
+      NX = 0
+      IWS = N
+      IF( NB.GT.1 .AND. NB.LT.K ) THEN
+*
+*        Determine when to cross over from blocked to unblocked code.
+*
+         NX = MAX( 0, ILAENV( 3, 'SORGQL', ' ', M, N, K, -1 ) )
+         IF( NX.LT.K ) THEN
+*
+*           Determine if workspace is large enough for blocked code.
+*
+            LDWORK = N
+            IWS = LDWORK*NB
+            IF( LWORK.LT.IWS ) THEN
+*
+*              Not enough workspace to use optimal NB:  reduce NB and
+*              determine the minimum value of NB.
+*
+               NB = LWORK / LDWORK
+               NBMIN = MAX( 2, ILAENV( 2, 'SORGQL', ' ', M, N, K, -1 ) )
+            END IF
+         END IF
+      END IF
+*
+      IF( NB.GE.NBMIN .AND. NB.LT.K .AND. NX.LT.K ) THEN
+*
+*        Use blocked code after the first block.
+*        The last kk columns are handled by the block method.
+*
+         KK = MIN( K, ( ( K-NX+NB-1 ) / NB )*NB )
+*
+*        Set A(m-kk+1:m,1:n-kk) to zero.
+*
+         DO 20 J = 1, N - KK
+            DO 10 I = M - KK + 1, M
+               A( I, J ) = ZERO
+   10       CONTINUE
+   20    CONTINUE
+      ELSE
+         KK = 0
+      END IF
+*
+*     Use unblocked code for the first or only block.
+*
+      CALL SORG2L( M-KK, N-KK, K-KK, A, LDA, TAU, WORK, IINFO )
+*
+      IF( KK.GT.0 ) THEN
+*
+*        Use blocked code
+*
+         DO 50 I = K - KK + 1, K, NB
+            IB = MIN( NB, K-I+1 )
+            IF( N-K+I.GT.1 ) THEN
+*
+*              Form the triangular factor of the block reflector
+*              H = H(i+ib-1) . . . H(i+1) H(i)
+*
+               CALL SLARFT( 'Backward', 'Columnwise', M-K+I+IB-1, IB,
+     $                      A( 1, N-K+I ), LDA, TAU( I ), WORK, LDWORK )
+*
+*              Apply H to A(1:m-k+i+ib-1,1:n-k+i-1) from the left
+*
+               CALL SLARFB( 'Left', 'No transpose', 'Backward',
+     $                      'Columnwise', M-K+I+IB-1, N-K+I-1, IB,
+     $                      A( 1, N-K+I ), LDA, WORK, LDWORK, A, LDA,
+     $                      WORK( IB+1 ), LDWORK )
+            END IF
+*
+*           Apply H to rows 1:m-k+i+ib-1 of current block
+*
+            CALL SORG2L( M-K+I+IB-1, IB, IB, A( 1, N-K+I ), LDA,
+     $                   TAU( I ), WORK, IINFO )
+*
+*           Set rows m-k+i+ib:m of current block to zero
+*
+            DO 40 J = N - K + I, N - K + I + IB - 1
+               DO 30 L = M - K + I + IB, M
+                  A( L, J ) = ZERO
+   30          CONTINUE
+   40       CONTINUE
+   50    CONTINUE
+      END IF
+*
+      WORK( 1 ) = IWS
+      RETURN
+*
+*     End of SORGQL
+*
+      END
diff -uN AmberTools/src/quick/src/blas/sorgqr.f AmberTools/src/quick/src/blas/sorgqr.f
--- AmberTools/src/quick/src/blas/sorgqr.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/sorgqr.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,290 @@
+*> \brief \b SORGQR
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SORGQR + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sorgqr.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sorgqr.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorgqr.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SORGQR( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            INFO, K, LDA, LWORK, M, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), TAU( * ), WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SORGQR generates an M-by-N real matrix Q with orthonormal columns,
+*> which is defined as the first N columns of a product of K elementary
+*> reflectors of order M
+*>
+*>       Q  =  H(1) H(2) . . . H(k)
+*>
+*> as returned by SGEQRF.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix Q. M >= 0.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix Q. M >= N >= 0.
+*> \endverbatim
+*>
+*> \param[in] K
+*> \verbatim
+*>          K is INTEGER
+*>          The number of elementary reflectors whose product defines the
+*>          matrix Q. N >= K >= 0.
+*> \endverbatim
+*>
+*> \param[in,out] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          On entry, the i-th column must contain the vector which
+*>          defines the elementary reflector H(i), for i = 1,2,...,k, as
+*>          returned by SGEQRF in the first k columns of its array
+*>          argument A.
+*>          On exit, the M-by-N matrix Q.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The first dimension of the array A. LDA >= max(1,M).
+*> \endverbatim
+*>
+*> \param[in] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension (K)
+*>          TAU(i) must contain the scalar factor of the elementary
+*>          reflector H(i), as returned by SGEQRF.
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (MAX(1,LWORK))
+*>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
+*> \endverbatim
+*>
+*> \param[in] LWORK
+*> \verbatim
+*>          LWORK is INTEGER
+*>          The dimension of the array WORK. LWORK >= max(1,N).
+*>          For optimum performance LWORK >= N*NB, where NB is the
+*>          optimal blocksize.
+*>
+*>          If LWORK = -1, then a workspace query is assumed; the routine
+*>          only calculates the optimal size of the WORK array, returns
+*>          this value as the first entry of the WORK array, and no error
+*>          message related to LWORK is issued by XERBLA.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument has an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SORGQR( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      INTEGER            INFO, K, LDA, LWORK, M, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), TAU( * ), WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO
+      PARAMETER          ( ZERO = 0.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            LQUERY
+      INTEGER            I, IB, IINFO, IWS, J, KI, KK, L, LDWORK,
+     $                   LWKOPT, NB, NBMIN, NX
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLARFB, SLARFT, SORG2R, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX, MIN
+*     ..
+*     .. External Functions ..
+      INTEGER            ILAENV
+      EXTERNAL           ILAENV
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input arguments
+*
+      INFO = 0
+      NB = ILAENV( 1, 'SORGQR', ' ', M, N, K, -1 )
+      LWKOPT = MAX( 1, N )*NB
+      WORK( 1 ) = LWKOPT
+      LQUERY = ( LWORK.EQ.-1 )
+      IF( M.LT.0 ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 .OR. N.GT.M ) THEN
+         INFO = -2
+      ELSE IF( K.LT.0 .OR. K.GT.N ) THEN
+         INFO = -3
+      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
+         INFO = -5
+      ELSE IF( LWORK.LT.MAX( 1, N ) .AND. .NOT.LQUERY ) THEN
+         INFO = -8
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SORGQR', -INFO )
+         RETURN
+      ELSE IF( LQUERY ) THEN
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.LE.0 ) THEN
+         WORK( 1 ) = 1
+         RETURN
+      END IF
+*
+      NBMIN = 2
+      NX = 0
+      IWS = N
+      IF( NB.GT.1 .AND. NB.LT.K ) THEN
+*
+*        Determine when to cross over from blocked to unblocked code.
+*
+         NX = MAX( 0, ILAENV( 3, 'SORGQR', ' ', M, N, K, -1 ) )
+         IF( NX.LT.K ) THEN
+*
+*           Determine if workspace is large enough for blocked code.
+*
+            LDWORK = N
+            IWS = LDWORK*NB
+            IF( LWORK.LT.IWS ) THEN
+*
+*              Not enough workspace to use optimal NB:  reduce NB and
+*              determine the minimum value of NB.
+*
+               NB = LWORK / LDWORK
+               NBMIN = MAX( 2, ILAENV( 2, 'SORGQR', ' ', M, N, K, -1 ) )
+            END IF
+         END IF
+      END IF
+*
+      IF( NB.GE.NBMIN .AND. NB.LT.K .AND. NX.LT.K ) THEN
+*
+*        Use blocked code after the last block.
+*        The first kk columns are handled by the block method.
+*
+         KI = ( ( K-NX-1 ) / NB )*NB
+         KK = MIN( K, KI+NB )
+*
+*        Set A(1:kk,kk+1:n) to zero.
+*
+         DO 20 J = KK + 1, N
+            DO 10 I = 1, KK
+               A( I, J ) = ZERO
+   10       CONTINUE
+   20    CONTINUE
+      ELSE
+         KK = 0
+      END IF
+*
+*     Use unblocked code for the last or only block.
+*
+      IF( KK.LT.N )
+     $   CALL SORG2R( M-KK, N-KK, K-KK, A( KK+1, KK+1 ), LDA,
+     $                TAU( KK+1 ), WORK, IINFO )
+*
+      IF( KK.GT.0 ) THEN
+*
+*        Use blocked code
+*
+         DO 50 I = KI + 1, 1, -NB
+            IB = MIN( NB, K-I+1 )
+            IF( I+IB.LE.N ) THEN
+*
+*              Form the triangular factor of the block reflector
+*              H = H(i) H(i+1) . . . H(i+ib-1)
+*
+               CALL SLARFT( 'Forward', 'Columnwise', M-I+1, IB,
+     $                      A( I, I ), LDA, TAU( I ), WORK, LDWORK )
+*
+*              Apply H to A(i:m,i+ib:n) from the left
+*
+               CALL SLARFB( 'Left', 'No transpose', 'Forward',
+     $                      'Columnwise', M-I+1, N-I-IB+1, IB,
+     $                      A( I, I ), LDA, WORK, LDWORK, A( I, I+IB ),
+     $                      LDA, WORK( IB+1 ), LDWORK )
+            END IF
+*
+*           Apply H to rows i:m of current block
+*
+            CALL SORG2R( M-I+1, IB, IB, A( I, I ), LDA, TAU( I ), WORK,
+     $                   IINFO )
+*
+*           Set rows 1:i-1 of current block to zero
+*
+            DO 40 J = I, I + IB - 1
+               DO 30 L = 1, I - 1
+                  A( L, J ) = ZERO
+   30          CONTINUE
+   40       CONTINUE
+   50    CONTINUE
+      END IF
+*
+      WORK( 1 ) = IWS
+      RETURN
+*
+*     End of SORGQR
+*
+      END
diff -uN AmberTools/src/quick/src/blas/sorgtr.f AmberTools/src/quick/src/blas/sorgtr.f
--- AmberTools/src/quick/src/blas/sorgtr.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/sorgtr.f	2022-08-30 19:15:04.000000000 +0900
@@ -0,0 +1,255 @@
+*> \brief \b SORGTR
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SORGTR + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sorgtr.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sorgtr.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorgtr.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SORGTR( UPLO, N, A, LDA, TAU, WORK, LWORK, INFO )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          UPLO
+*       INTEGER            INFO, LDA, LWORK, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), TAU( * ), WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SORGTR generates a real orthogonal matrix Q which is defined as the
+*> product of n-1 elementary reflectors of order N, as returned by
+*> SSYTRD:
+*>
+*> if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
+*>
+*> if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] UPLO
+*> \verbatim
+*>          UPLO is CHARACTER*1
+*>          = 'U': Upper triangle of A contains elementary reflectors
+*>                 from SSYTRD;
+*>          = 'L': Lower triangle of A contains elementary reflectors
+*>                 from SSYTRD.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the matrix Q. N >= 0.
+*> \endverbatim
+*>
+*> \param[in,out] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          On entry, the vectors which define the elementary reflectors,
+*>          as returned by SSYTRD.
+*>          On exit, the N-by-N orthogonal matrix Q.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A. LDA >= max(1,N).
+*> \endverbatim
+*>
+*> \param[in] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension (N-1)
+*>          TAU(i) must contain the scalar factor of the elementary
+*>          reflector H(i), as returned by SSYTRD.
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (MAX(1,LWORK))
+*>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
+*> \endverbatim
+*>
+*> \param[in] LWORK
+*> \verbatim
+*>          LWORK is INTEGER
+*>          The dimension of the array WORK. LWORK >= max(1,N-1).
+*>          For optimum performance LWORK >= (N-1)*NB, where NB is
+*>          the optimal blocksize.
+*>
+*>          If LWORK = -1, then a workspace query is assumed; the routine
+*>          only calculates the optimal size of the WORK array, returns
+*>          this value as the first entry of the WORK array, and no error
+*>          message related to LWORK is issued by XERBLA.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument had an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SORGTR( UPLO, N, A, LDA, TAU, WORK, LWORK, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          UPLO
+      INTEGER            INFO, LDA, LWORK, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), TAU( * ), WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO, ONE
+      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            LQUERY, UPPER
+      INTEGER            I, IINFO, J, LWKOPT, NB
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      INTEGER            ILAENV
+      EXTERNAL           ILAENV, LSAME
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SORGQL, SORGQR, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input arguments
+*
+      INFO = 0
+      LQUERY = ( LWORK.EQ.-1 )
+      UPPER = LSAME( UPLO, 'U' )
+      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -2
+      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
+         INFO = -4
+      ELSE IF( LWORK.LT.MAX( 1, N-1 ) .AND. .NOT.LQUERY ) THEN
+         INFO = -7
+      END IF
+*
+      IF( INFO.EQ.0 ) THEN
+         IF ( UPPER ) THEN
+           NB = ILAENV( 1, 'SORGQL', ' ', N-1, N-1, N-1, -1 )
+         ELSE
+           NB = ILAENV( 1, 'SORGQR', ' ', N-1, N-1, N-1, -1 )
+         END IF
+         LWKOPT = MAX( 1, N-1 )*NB
+         WORK( 1 ) = LWKOPT
+      END IF
+*
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SORGTR', -INFO )
+         RETURN
+      ELSE IF( LQUERY ) THEN
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 ) THEN
+         WORK( 1 ) = 1
+         RETURN
+      END IF
+*
+      IF( UPPER ) THEN
+*
+*        Q was determined by a call to SSYTRD with UPLO = 'U'
+*
+*        Shift the vectors which define the elementary reflectors one
+*        column to the left, and set the last row and column of Q to
+*        those of the unit matrix
+*
+         DO 20 J = 1, N - 1
+            DO 10 I = 1, J - 1
+               A( I, J ) = A( I, J+1 )
+   10       CONTINUE
+            A( N, J ) = ZERO
+   20    CONTINUE
+         DO 30 I = 1, N - 1
+            A( I, N ) = ZERO
+   30    CONTINUE
+         A( N, N ) = ONE
+*
+*        Generate Q(1:n-1,1:n-1)
+*
+         CALL SORGQL( N-1, N-1, N-1, A, LDA, TAU, WORK, LWORK, IINFO )
+*
+      ELSE
+*
+*        Q was determined by a call to SSYTRD with UPLO = 'L'.
+*
+*        Shift the vectors which define the elementary reflectors one
+*        column to the right, and set the first row and column of Q to
+*        those of the unit matrix
+*
+         DO 50 J = N, 2, -1
+            A( 1, J ) = ZERO
+            DO 40 I = J + 1, N
+               A( I, J ) = A( I, J-1 )
+   40       CONTINUE
+   50    CONTINUE
+         A( 1, 1 ) = ONE
+         DO 60 I = 2, N
+            A( I, 1 ) = ZERO
+   60    CONTINUE
+         IF( N.GT.1 ) THEN
+*
+*           Generate Q(2:n,2:n)
+*
+            CALL SORGQR( N-1, N-1, N-1, A( 2, 2 ), LDA, TAU, WORK,
+     $                   LWORK, IINFO )
+         END IF
+      END IF
+      WORK( 1 ) = LWKOPT
+      RETURN
+*
+*     End of SORGTR
+*
+      END
diff -uN AmberTools/src/quick/src/blas/sorm2l.f AmberTools/src/quick/src/blas/sorm2l.f
--- AmberTools/src/quick/src/blas/sorm2l.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/sorm2l.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,278 @@
+*> \brief \b SORM2L multiplies a general matrix by the orthogonal matrix from a QL factorization determined by sgeqlf (unblocked algorithm).
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SORM2L + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sorm2l.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sorm2l.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorm2l.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SORM2L( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
+*                          WORK, INFO )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          SIDE, TRANS
+*       INTEGER            INFO, K, LDA, LDC, M, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SORM2L overwrites the general real m by n matrix C with
+*>
+*>       Q * C  if SIDE = 'L' and TRANS = 'N', or
+*>
+*>       Q**T * C  if SIDE = 'L' and TRANS = 'T', or
+*>
+*>       C * Q  if SIDE = 'R' and TRANS = 'N', or
+*>
+*>       C * Q**T if SIDE = 'R' and TRANS = 'T',
+*>
+*> where Q is a real orthogonal matrix defined as the product of k
+*> elementary reflectors
+*>
+*>       Q = H(k) . . . H(2) H(1)
+*>
+*> as returned by SGEQLF. Q is of order m if SIDE = 'L' and of order n
+*> if SIDE = 'R'.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] SIDE
+*> \verbatim
+*>          SIDE is CHARACTER*1
+*>          = 'L': apply Q or Q**T from the Left
+*>          = 'R': apply Q or Q**T from the Right
+*> \endverbatim
+*>
+*> \param[in] TRANS
+*> \verbatim
+*>          TRANS is CHARACTER*1
+*>          = 'N': apply Q  (No transpose)
+*>          = 'T': apply Q**T (Transpose)
+*> \endverbatim
+*>
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix C. M >= 0.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix C. N >= 0.
+*> \endverbatim
+*>
+*> \param[in] K
+*> \verbatim
+*>          K is INTEGER
+*>          The number of elementary reflectors whose product defines
+*>          the matrix Q.
+*>          If SIDE = 'L', M >= K >= 0;
+*>          if SIDE = 'R', N >= K >= 0.
+*> \endverbatim
+*>
+*> \param[in] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,K)
+*>          The i-th column must contain the vector which defines the
+*>          elementary reflector H(i), for i = 1,2,...,k, as returned by
+*>          SGEQLF in the last k columns of its array argument A.
+*>          A is modified by the routine but restored on exit.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A.
+*>          If SIDE = 'L', LDA >= max(1,M);
+*>          if SIDE = 'R', LDA >= max(1,N).
+*> \endverbatim
+*>
+*> \param[in] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension (K)
+*>          TAU(i) must contain the scalar factor of the elementary
+*>          reflector H(i), as returned by SGEQLF.
+*> \endverbatim
+*>
+*> \param[in,out] C
+*> \verbatim
+*>          C is REAL array, dimension (LDC,N)
+*>          On entry, the m by n matrix C.
+*>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
+*> \endverbatim
+*>
+*> \param[in] LDC
+*> \verbatim
+*>          LDC is INTEGER
+*>          The leading dimension of the array C. LDC >= max(1,M).
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension
+*>                                   (N) if SIDE = 'L',
+*>                                   (M) if SIDE = 'R'
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0: successful exit
+*>          < 0: if INFO = -i, the i-th argument had an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SORM2L( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
+     $                   WORK, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          SIDE, TRANS
+      INTEGER            INFO, K, LDA, LDC, M, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE
+      PARAMETER          ( ONE = 1.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            LEFT, NOTRAN
+      INTEGER            I, I1, I2, I3, MI, NI, NQ
+      REAL               AII
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      EXTERNAL           LSAME
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLARF, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input arguments
+*
+      INFO = 0
+      LEFT = LSAME( SIDE, 'L' )
+      NOTRAN = LSAME( TRANS, 'N' )
+*
+*     NQ is the order of Q
+*
+      IF( LEFT ) THEN
+         NQ = M
+      ELSE
+         NQ = N
+      END IF
+      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN
+         INFO = -1
+      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN
+         INFO = -2
+      ELSE IF( M.LT.0 ) THEN
+         INFO = -3
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -4
+      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN
+         INFO = -5
+      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN
+         INFO = -7
+      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN
+         INFO = -10
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SORM2L', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 )
+     $   RETURN
+*
+      IF( ( LEFT .AND. NOTRAN ) .OR. ( .NOT.LEFT .AND. .NOT.NOTRAN ) )
+     $     THEN
+         I1 = 1
+         I2 = K
+         I3 = 1
+      ELSE
+         I1 = K
+         I2 = 1
+         I3 = -1
+      END IF
+*
+      IF( LEFT ) THEN
+         NI = N
+      ELSE
+         MI = M
+      END IF
+*
+      DO 10 I = I1, I2, I3
+         IF( LEFT ) THEN
+*
+*           H(i) is applied to C(1:m-k+i,1:n)
+*
+            MI = M - K + I
+         ELSE
+*
+*           H(i) is applied to C(1:m,1:n-k+i)
+*
+            NI = N - K + I
+         END IF
+*
+*        Apply H(i)
+*
+         AII = A( NQ-K+I, I )
+         A( NQ-K+I, I ) = ONE
+         CALL SLARF( SIDE, MI, NI, A( 1, I ), 1, TAU( I ), C, LDC,
+     $               WORK )
+         A( NQ-K+I, I ) = AII
+   10 CONTINUE
+      RETURN
+*
+*     End of SORM2L
+*
+      END
diff -uN AmberTools/src/quick/src/blas/sorm2r.f AmberTools/src/quick/src/blas/sorm2r.f
--- AmberTools/src/quick/src/blas/sorm2r.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/sorm2r.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,282 @@
+*> \brief \b SORM2R multiplies a general matrix by the orthogonal matrix from a QR factorization determined by sgeqrf (unblocked algorithm).
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SORM2R + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sorm2r.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sorm2r.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sorm2r.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SORM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
+*                          WORK, INFO )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          SIDE, TRANS
+*       INTEGER            INFO, K, LDA, LDC, M, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SORM2R overwrites the general real m by n matrix C with
+*>
+*>       Q * C  if SIDE = 'L' and TRANS = 'N', or
+*>
+*>       Q**T* C  if SIDE = 'L' and TRANS = 'T', or
+*>
+*>       C * Q  if SIDE = 'R' and TRANS = 'N', or
+*>
+*>       C * Q**T if SIDE = 'R' and TRANS = 'T',
+*>
+*> where Q is a real orthogonal matrix defined as the product of k
+*> elementary reflectors
+*>
+*>       Q = H(1) H(2) . . . H(k)
+*>
+*> as returned by SGEQRF. Q is of order m if SIDE = 'L' and of order n
+*> if SIDE = 'R'.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] SIDE
+*> \verbatim
+*>          SIDE is CHARACTER*1
+*>          = 'L': apply Q or Q**T from the Left
+*>          = 'R': apply Q or Q**T from the Right
+*> \endverbatim
+*>
+*> \param[in] TRANS
+*> \verbatim
+*>          TRANS is CHARACTER*1
+*>          = 'N': apply Q  (No transpose)
+*>          = 'T': apply Q**T (Transpose)
+*> \endverbatim
+*>
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix C. M >= 0.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix C. N >= 0.
+*> \endverbatim
+*>
+*> \param[in] K
+*> \verbatim
+*>          K is INTEGER
+*>          The number of elementary reflectors whose product defines
+*>          the matrix Q.
+*>          If SIDE = 'L', M >= K >= 0;
+*>          if SIDE = 'R', N >= K >= 0.
+*> \endverbatim
+*>
+*> \param[in] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,K)
+*>          The i-th column must contain the vector which defines the
+*>          elementary reflector H(i), for i = 1,2,...,k, as returned by
+*>          SGEQRF in the first k columns of its array argument A.
+*>          A is modified by the routine but restored on exit.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A.
+*>          If SIDE = 'L', LDA >= max(1,M);
+*>          if SIDE = 'R', LDA >= max(1,N).
+*> \endverbatim
+*>
+*> \param[in] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension (K)
+*>          TAU(i) must contain the scalar factor of the elementary
+*>          reflector H(i), as returned by SGEQRF.
+*> \endverbatim
+*>
+*> \param[in,out] C
+*> \verbatim
+*>          C is REAL array, dimension (LDC,N)
+*>          On entry, the m by n matrix C.
+*>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
+*> \endverbatim
+*>
+*> \param[in] LDC
+*> \verbatim
+*>          LDC is INTEGER
+*>          The leading dimension of the array C. LDC >= max(1,M).
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension
+*>                                   (N) if SIDE = 'L',
+*>                                   (M) if SIDE = 'R'
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0: successful exit
+*>          < 0: if INFO = -i, the i-th argument had an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SORM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
+     $                   WORK, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          SIDE, TRANS
+      INTEGER            INFO, K, LDA, LDC, M, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE
+      PARAMETER          ( ONE = 1.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            LEFT, NOTRAN
+      INTEGER            I, I1, I2, I3, IC, JC, MI, NI, NQ
+      REAL               AII
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      EXTERNAL           LSAME
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLARF, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input arguments
+*
+      INFO = 0
+      LEFT = LSAME( SIDE, 'L' )
+      NOTRAN = LSAME( TRANS, 'N' )
+*
+*     NQ is the order of Q
+*
+      IF( LEFT ) THEN
+         NQ = M
+      ELSE
+         NQ = N
+      END IF
+      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN
+         INFO = -1
+      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN
+         INFO = -2
+      ELSE IF( M.LT.0 ) THEN
+         INFO = -3
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -4
+      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN
+         INFO = -5
+      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN
+         INFO = -7
+      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN
+         INFO = -10
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SORM2R', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 )
+     $   RETURN
+*
+      IF( ( LEFT .AND. .NOT.NOTRAN ) .OR. ( .NOT.LEFT .AND. NOTRAN ) )
+     $     THEN
+         I1 = 1
+         I2 = K
+         I3 = 1
+      ELSE
+         I1 = K
+         I2 = 1
+         I3 = -1
+      END IF
+*
+      IF( LEFT ) THEN
+         NI = N
+         JC = 1
+      ELSE
+         MI = M
+         IC = 1
+      END IF
+*
+      DO 10 I = I1, I2, I3
+         IF( LEFT ) THEN
+*
+*           H(i) is applied to C(i:m,1:n)
+*
+            MI = M - I + 1
+            IC = I
+         ELSE
+*
+*           H(i) is applied to C(1:m,i:n)
+*
+            NI = N - I + 1
+            JC = I
+         END IF
+*
+*        Apply H(i)
+*
+         AII = A( I, I )
+         A( I, I ) = ONE
+         CALL SLARF( SIDE, MI, NI, A( I, I ), 1, TAU( I ), C( IC, JC ),
+     $               LDC, WORK )
+         A( I, I ) = AII
+   10 CONTINUE
+      RETURN
+*
+*     End of SORM2R
+*
+      END
diff -uN AmberTools/src/quick/src/blas/sormql.f AmberTools/src/quick/src/blas/sormql.f
--- AmberTools/src/quick/src/blas/sormql.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/sormql.f	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,341 @@
+*> \brief \b SORMQL
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SORMQL + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sormql.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sormql.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sormql.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SORMQL( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
+*                          WORK, LWORK, INFO )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          SIDE, TRANS
+*       INTEGER            INFO, K, LDA, LDC, LWORK, M, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), C( LDC, * ), TAU( * ),
+*      $                   WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SORMQL overwrites the general real M-by-N matrix C with
+*>
+*>                 SIDE = 'L'     SIDE = 'R'
+*> TRANS = 'N':      Q * C          C * Q
+*> TRANS = 'T':      Q**T * C       C * Q**T
+*>
+*> where Q is a real orthogonal matrix defined as the product of k
+*> elementary reflectors
+*>
+*>       Q = H(k) . . . H(2) H(1)
+*>
+*> as returned by SGEQLF. Q is of order M if SIDE = 'L' and of order N
+*> if SIDE = 'R'.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] SIDE
+*> \verbatim
+*>          SIDE is CHARACTER*1
+*>          = 'L': apply Q or Q**T from the Left;
+*>          = 'R': apply Q or Q**T from the Right.
+*> \endverbatim
+*>
+*> \param[in] TRANS
+*> \verbatim
+*>          TRANS is CHARACTER*1
+*>          = 'N':  No transpose, apply Q;
+*>          = 'T':  Transpose, apply Q**T.
+*> \endverbatim
+*>
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix C. M >= 0.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix C. N >= 0.
+*> \endverbatim
+*>
+*> \param[in] K
+*> \verbatim
+*>          K is INTEGER
+*>          The number of elementary reflectors whose product defines
+*>          the matrix Q.
+*>          If SIDE = 'L', M >= K >= 0;
+*>          if SIDE = 'R', N >= K >= 0.
+*> \endverbatim
+*>
+*> \param[in] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,K)
+*>          The i-th column must contain the vector which defines the
+*>          elementary reflector H(i), for i = 1,2,...,k, as returned by
+*>          SGEQLF in the last k columns of its array argument A.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A.
+*>          If SIDE = 'L', LDA >= max(1,M);
+*>          if SIDE = 'R', LDA >= max(1,N).
+*> \endverbatim
+*>
+*> \param[in] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension (K)
+*>          TAU(i) must contain the scalar factor of the elementary
+*>          reflector H(i), as returned by SGEQLF.
+*> \endverbatim
+*>
+*> \param[in,out] C
+*> \verbatim
+*>          C is REAL array, dimension (LDC,N)
+*>          On entry, the M-by-N matrix C.
+*>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
+*> \endverbatim
+*>
+*> \param[in] LDC
+*> \verbatim
+*>          LDC is INTEGER
+*>          The leading dimension of the array C. LDC >= max(1,M).
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (MAX(1,LWORK))
+*>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
+*> \endverbatim
+*>
+*> \param[in] LWORK
+*> \verbatim
+*>          LWORK is INTEGER
+*>          The dimension of the array WORK.
+*>          If SIDE = 'L', LWORK >= max(1,N);
+*>          if SIDE = 'R', LWORK >= max(1,M).
+*>          For good performance, LWORK should generally be larger.
+*>
+*>          If LWORK = -1, then a workspace query is assumed; the routine
+*>          only calculates the optimal size of the WORK array, returns
+*>          this value as the first entry of the WORK array, and no error
+*>          message related to LWORK is issued by XERBLA.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument had an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SORMQL( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
+     $                   WORK, LWORK, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          SIDE, TRANS
+      INTEGER            INFO, K, LDA, LDC, LWORK, M, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), C( LDC, * ), TAU( * ),
+     $                   WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      INTEGER            NBMAX, LDT, TSIZE
+      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1,
+     $                     TSIZE = LDT*NBMAX )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            LEFT, LQUERY, NOTRAN
+      INTEGER            I, I1, I2, I3, IB, IINFO, IWT, LDWORK, LWKOPT,
+     $                   MI, NB, NBMIN, NI, NQ, NW
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      INTEGER            ILAENV
+      EXTERNAL           LSAME, ILAENV
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLARFB, SLARFT, SORM2L, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX, MIN
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input arguments
+*
+      INFO = 0
+      LEFT = LSAME( SIDE, 'L' )
+      NOTRAN = LSAME( TRANS, 'N' )
+      LQUERY = ( LWORK.EQ.-1 )
+*
+*     NQ is the order of Q and NW is the minimum dimension of WORK
+*
+      IF( LEFT ) THEN
+         NQ = M
+         NW = MAX( 1, N )
+      ELSE
+         NQ = N
+         NW = MAX( 1, M )
+      END IF
+      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN
+         INFO = -1
+      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN
+         INFO = -2
+      ELSE IF( M.LT.0 ) THEN
+         INFO = -3
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -4
+      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN
+         INFO = -5
+      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN
+         INFO = -7
+      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN
+         INFO = -10
+      ELSE IF( LWORK.LT.NW .AND. .NOT.LQUERY ) THEN
+         INFO = -12
+      END IF
+*
+      IF( INFO.EQ.0 ) THEN
+*
+*     Compute the workspace requirements
+*
+         IF( M.EQ.0 .OR. N.EQ.0 ) THEN
+            LWKOPT = 1
+         ELSE
+            NB = MIN( NBMAX, ILAENV( 1, 'SORMQL', SIDE // TRANS, M, N,
+     $                               K, -1 ) )
+            LWKOPT = NW*NB + TSIZE
+         END IF
+         WORK( 1 ) = LWKOPT
+      END IF
+*
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SORMQL', -INFO )
+         RETURN
+      ELSE IF( LQUERY ) THEN
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
+         RETURN
+      END IF
+*
+      NBMIN = 2
+      LDWORK = NW
+      IF( NB.GT.1 .AND. NB.LT.K ) THEN
+         IF( LWORK.LT.NW*NB+TSIZE ) THEN
+            NB = (LWORK-TSIZE) / LDWORK
+            NBMIN = MAX( 2, ILAENV( 2, 'SORMQL', SIDE // TRANS, M, N, K,
+     $              -1 ) )
+         END IF
+      END IF
+*
+      IF( NB.LT.NBMIN .OR. NB.GE.K ) THEN
+*
+*        Use unblocked code
+*
+         CALL SORM2L( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK,
+     $                IINFO )
+      ELSE
+*
+*        Use blocked code
+*
+         IWT = 1 + NW*NB
+         IF( ( LEFT .AND. NOTRAN ) .OR.
+     $       ( .NOT.LEFT .AND. .NOT.NOTRAN ) ) THEN
+            I1 = 1
+            I2 = K
+            I3 = NB
+         ELSE
+            I1 = ( ( K-1 ) / NB )*NB + 1
+            I2 = 1
+            I3 = -NB
+         END IF
+*
+         IF( LEFT ) THEN
+            NI = N
+         ELSE
+            MI = M
+         END IF
+*
+         DO 10 I = I1, I2, I3
+            IB = MIN( NB, K-I+1 )
+*
+*           Form the triangular factor of the block reflector
+*           H = H(i+ib-1) . . . H(i+1) H(i)
+*
+            CALL SLARFT( 'Backward', 'Columnwise', NQ-K+I+IB-1, IB,
+     $                   A( 1, I ), LDA, TAU( I ), WORK( IWT ), LDT )
+            IF( LEFT ) THEN
+*
+*              H or H**T is applied to C(1:m-k+i+ib-1,1:n)
+*
+               MI = M - K + I + IB - 1
+            ELSE
+*
+*              H or H**T is applied to C(1:m,1:n-k+i+ib-1)
+*
+               NI = N - K + I + IB - 1
+            END IF
+*
+*           Apply H or H**T
+*
+            CALL SLARFB( SIDE, TRANS, 'Backward', 'Columnwise', MI, NI,
+     $                   IB, A( 1, I ), LDA, WORK( IWT ), LDT, C, LDC,
+     $                   WORK, LDWORK )
+   10    CONTINUE
+      END IF
+      WORK( 1 ) = LWKOPT
+      RETURN
+*
+*     End of SORMQL
+*
+      END
diff -uN AmberTools/src/quick/src/blas/sormqr.f AmberTools/src/quick/src/blas/sormqr.f
--- AmberTools/src/quick/src/blas/sormqr.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/sormqr.f	2022-08-30 19:22:13.000000000 +0900
@@ -0,0 +1,342 @@
+*> \brief \b SORMQR
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SORMQR + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sormqr.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sormqr.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sormqr.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SORMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
+*                          WORK, LWORK, INFO )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          SIDE, TRANS
+*       INTEGER            INFO, K, LDA, LDC, LWORK, M, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), C( LDC, * ), TAU( * ),
+*      $                   WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SORMQR overwrites the general real M-by-N matrix C with
+*>
+*>                 SIDE = 'L'     SIDE = 'R'
+*> TRANS = 'N':      Q * C          C * Q
+*> TRANS = 'T':      Q**T * C       C * Q**T
+*>
+*> where Q is a real orthogonal matrix defined as the product of k
+*> elementary reflectors
+*>
+*>       Q = H(1) H(2) . . . H(k)
+*>
+*> as returned by SGEQRF. Q is of order M if SIDE = 'L' and of order N
+*> if SIDE = 'R'.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] SIDE
+*> \verbatim
+*>          SIDE is CHARACTER*1
+*>          = 'L': apply Q or Q**T from the Left;
+*>          = 'R': apply Q or Q**T from the Right.
+*> \endverbatim
+*>
+*> \param[in] TRANS
+*> \verbatim
+*>          TRANS is CHARACTER*1
+*>          = 'N':  No transpose, apply Q;
+*>          = 'T':  Transpose, apply Q**T.
+*> \endverbatim
+*>
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix C. M >= 0.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix C. N >= 0.
+*> \endverbatim
+*>
+*> \param[in] K
+*> \verbatim
+*>          K is INTEGER
+*>          The number of elementary reflectors whose product defines
+*>          the matrix Q.
+*>          If SIDE = 'L', M >= K >= 0;
+*>          if SIDE = 'R', N >= K >= 0.
+*> \endverbatim
+*>
+*> \param[in] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,K)
+*>          The i-th column must contain the vector which defines the
+*>          elementary reflector H(i), for i = 1,2,...,k, as returned by
+*>          SGEQRF in the first k columns of its array argument A.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A.
+*>          If SIDE = 'L', LDA >= max(1,M);
+*>          if SIDE = 'R', LDA >= max(1,N).
+*> \endverbatim
+*>
+*> \param[in] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension (K)
+*>          TAU(i) must contain the scalar factor of the elementary
+*>          reflector H(i), as returned by SGEQRF.
+*> \endverbatim
+*>
+*> \param[in,out] C
+*> \verbatim
+*>          C is REAL array, dimension (LDC,N)
+*>          On entry, the M-by-N matrix C.
+*>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
+*> \endverbatim
+*>
+*> \param[in] LDC
+*> \verbatim
+*>          LDC is INTEGER
+*>          The leading dimension of the array C. LDC >= max(1,M).
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (MAX(1,LWORK))
+*>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
+*> \endverbatim
+*>
+*> \param[in] LWORK
+*> \verbatim
+*>          LWORK is INTEGER
+*>          The dimension of the array WORK.
+*>          If SIDE = 'L', LWORK >= max(1,N);
+*>          if SIDE = 'R', LWORK >= max(1,M).
+*>          For good performance, LWORK should generally be larger.
+*>
+*>          If LWORK = -1, then a workspace query is assumed; the routine
+*>          only calculates the optimal size of the WORK array, returns
+*>          this value as the first entry of the WORK array, and no error
+*>          message related to LWORK is issued by XERBLA.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument had an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SORMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,
+     $                   WORK, LWORK, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          SIDE, TRANS
+      INTEGER            INFO, K, LDA, LDC, LWORK, M, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), C( LDC, * ), TAU( * ),
+     $                   WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      INTEGER            NBMAX, LDT, TSIZE
+      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1,
+     $                     TSIZE = LDT*NBMAX )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            LEFT, LQUERY, NOTRAN
+      INTEGER            I, I1, I2, I3, IB, IC, IINFO, IWT, JC, LDWORK,
+     $                   LWKOPT, MI, NB, NBMIN, NI, NQ, NW
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      INTEGER            ILAENV
+      EXTERNAL           LSAME, ILAENV
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLARFB, SLARFT, SORM2R, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX, MIN
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input arguments
+*
+      INFO = 0
+      LEFT = LSAME( SIDE, 'L' )
+      NOTRAN = LSAME( TRANS, 'N' )
+      LQUERY = ( LWORK.EQ.-1 )
+*
+*     NQ is the order of Q and NW is the minimum dimension of WORK
+*
+      IF( LEFT ) THEN
+         NQ = M
+         NW = N
+      ELSE
+         NQ = N
+         NW = M
+      END IF
+      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN
+         INFO = -1
+      ELSE IF( .NOT.NOTRAN .AND. .NOT.LSAME( TRANS, 'T' ) ) THEN
+         INFO = -2
+      ELSE IF( M.LT.0 ) THEN
+         INFO = -3
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -4
+      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN
+         INFO = -5
+      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN
+         INFO = -7
+      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN
+         INFO = -10
+      ELSE IF( LWORK.LT.MAX( 1, NW ) .AND. .NOT.LQUERY ) THEN
+         INFO = -12
+      END IF
+*
+      IF( INFO.EQ.0 ) THEN
+*
+*        Compute the workspace requirements
+*
+         NB = MIN( NBMAX, ILAENV( 1, 'SORMQR', SIDE // TRANS, M, N, K,
+     $        -1 ) )
+         LWKOPT = MAX( 1, NW )*NB + TSIZE
+         WORK( 1 ) = LWKOPT
+      END IF
+*
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SORMQR', -INFO )
+         RETURN
+      ELSE IF( LQUERY ) THEN
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 ) THEN
+         WORK( 1 ) = 1
+         RETURN
+      END IF
+*
+      NBMIN = 2
+      LDWORK = NW
+      IF( NB.GT.1 .AND. NB.LT.K ) THEN
+         IF( LWORK.LT.NW*NB+TSIZE ) THEN
+            NB = (LWORK-TSIZE) / LDWORK
+            NBMIN = MAX( 2, ILAENV( 2, 'SORMQR', SIDE // TRANS, M, N, K,
+     $              -1 ) )
+         END IF
+      END IF
+*
+      IF( NB.LT.NBMIN .OR. NB.GE.K ) THEN
+*
+*        Use unblocked code
+*
+         CALL SORM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK,
+     $                IINFO )
+      ELSE
+*
+*        Use blocked code
+*
+         IWT = 1 + NW*NB
+         IF( ( LEFT .AND. .NOT.NOTRAN ) .OR.
+     $       ( .NOT.LEFT .AND. NOTRAN ) ) THEN
+            I1 = 1
+            I2 = K
+            I3 = NB
+         ELSE
+            I1 = ( ( K-1 ) / NB )*NB + 1
+            I2 = 1
+            I3 = -NB
+         END IF
+*
+         IF( LEFT ) THEN
+            NI = N
+            JC = 1
+         ELSE
+            MI = M
+            IC = 1
+         END IF
+*
+         DO 10 I = I1, I2, I3
+            IB = MIN( NB, K-I+1 )
+*
+*           Form the triangular factor of the block reflector
+*           H = H(i) H(i+1) . . . H(i+ib-1)
+*
+            CALL SLARFT( 'Forward', 'Columnwise', NQ-I+1, IB, A( I, I ),
+     $                   LDA, TAU( I ), WORK( IWT ), LDT )
+            IF( LEFT ) THEN
+*
+*              H or H**T is applied to C(i:m,1:n)
+*
+               MI = M - I + 1
+               IC = I
+            ELSE
+*
+*              H or H**T is applied to C(1:m,i:n)
+*
+               NI = N - I + 1
+               JC = I
+            END IF
+*
+*           Apply H or H**T
+*
+            CALL SLARFB( SIDE, TRANS, 'Forward', 'Columnwise', MI, NI,
+     $                   IB, A( I, I ), LDA, WORK( IWT ), LDT,
+     $                   C( IC, JC ), LDC, WORK, LDWORK )
+   10    CONTINUE
+      END IF
+      WORK( 1 ) = LWKOPT
+      RETURN
+*
+*     End of SORMQR
+*
+      END
diff -uN AmberTools/src/quick/src/blas/sormtr.f AmberTools/src/quick/src/blas/sormtr.f
--- AmberTools/src/quick/src/blas/sormtr.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/sormtr.f	2022-08-30 19:16:40.000000000 +0900
@@ -0,0 +1,312 @@
+*> \brief \b SORMTR
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SORMTR + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sormtr.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sormtr.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sormtr.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SORMTR( SIDE, UPLO, TRANS, M, N, A, LDA, TAU, C, LDC,
+*                          WORK, LWORK, INFO )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          SIDE, TRANS, UPLO
+*       INTEGER            INFO, LDA, LDC, LWORK, M, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), C( LDC, * ), TAU( * ),
+*      $                   WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SORMTR overwrites the general real M-by-N matrix C with
+*>
+*>                 SIDE = 'L'     SIDE = 'R'
+*> TRANS = 'N':      Q * C          C * Q
+*> TRANS = 'T':      Q**T * C       C * Q**T
+*>
+*> where Q is a real orthogonal matrix of order nq, with nq = m if
+*> SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
+*> nq-1 elementary reflectors, as returned by SSYTRD:
+*>
+*> if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
+*>
+*> if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] SIDE
+*> \verbatim
+*>          SIDE is CHARACTER*1
+*>          = 'L': apply Q or Q**T from the Left;
+*>          = 'R': apply Q or Q**T from the Right.
+*> \endverbatim
+*>
+*> \param[in] UPLO
+*> \verbatim
+*>          UPLO is CHARACTER*1
+*>          = 'U': Upper triangle of A contains elementary reflectors
+*>                 from SSYTRD;
+*>          = 'L': Lower triangle of A contains elementary reflectors
+*>                 from SSYTRD.
+*> \endverbatim
+*>
+*> \param[in] TRANS
+*> \verbatim
+*>          TRANS is CHARACTER*1
+*>          = 'N':  No transpose, apply Q;
+*>          = 'T':  Transpose, apply Q**T.
+*> \endverbatim
+*>
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of rows of the matrix C. M >= 0.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The number of columns of the matrix C. N >= 0.
+*> \endverbatim
+*>
+*> \param[in] A
+*> \verbatim
+*>          A is REAL array, dimension
+*>                               (LDA,M) if SIDE = 'L'
+*>                               (LDA,N) if SIDE = 'R'
+*>          The vectors which define the elementary reflectors, as
+*>          returned by SSYTRD.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A.
+*>          LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
+*> \endverbatim
+*>
+*> \param[in] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension
+*>                               (M-1) if SIDE = 'L'
+*>                               (N-1) if SIDE = 'R'
+*>          TAU(i) must contain the scalar factor of the elementary
+*>          reflector H(i), as returned by SSYTRD.
+*> \endverbatim
+*>
+*> \param[in,out] C
+*> \verbatim
+*>          C is REAL array, dimension (LDC,N)
+*>          On entry, the M-by-N matrix C.
+*>          On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
+*> \endverbatim
+*>
+*> \param[in] LDC
+*> \verbatim
+*>          LDC is INTEGER
+*>          The leading dimension of the array C. LDC >= max(1,M).
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (MAX(1,LWORK))
+*>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
+*> \endverbatim
+*>
+*> \param[in] LWORK
+*> \verbatim
+*>          LWORK is INTEGER
+*>          The dimension of the array WORK.
+*>          If SIDE = 'L', LWORK >= max(1,N);
+*>          if SIDE = 'R', LWORK >= max(1,M).
+*>          For optimum performance LWORK >= N*NB if SIDE = 'L', and
+*>          LWORK >= M*NB if SIDE = 'R', where NB is the optimal
+*>          blocksize.
+*>
+*>          If LWORK = -1, then a workspace query is assumed; the routine
+*>          only calculates the optimal size of the WORK array, returns
+*>          this value as the first entry of the WORK array, and no error
+*>          message related to LWORK is issued by XERBLA.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument had an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SORMTR( SIDE, UPLO, TRANS, M, N, A, LDA, TAU, C, LDC,
+     $                   WORK, LWORK, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          SIDE, TRANS, UPLO
+      INTEGER            INFO, LDA, LDC, LWORK, M, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), C( LDC, * ), TAU( * ),
+     $                   WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Local Scalars ..
+      LOGICAL            LEFT, LQUERY, UPPER
+      INTEGER            I1, I2, IINFO, LWKOPT, MI, NI, NB, NQ, NW
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      INTEGER            ILAENV
+      EXTERNAL           ILAENV, LSAME
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SORMQL, SORMQR, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input arguments
+*
+      INFO = 0
+      LEFT = LSAME( SIDE, 'L' )
+      UPPER = LSAME( UPLO, 'U' )
+      LQUERY = ( LWORK.EQ.-1 )
+*
+*     NQ is the order of Q and NW is the minimum dimension of WORK
+*
+      IF( LEFT ) THEN
+         NQ = M
+         NW = N
+      ELSE
+         NQ = N
+         NW = M
+      END IF
+      IF( .NOT.LEFT .AND. .NOT.LSAME( SIDE, 'R' ) ) THEN
+         INFO = -1
+      ELSE IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -2
+      ELSE IF( .NOT.LSAME( TRANS, 'N' ) .AND. .NOT.LSAME( TRANS, 'T' ) )
+     $          THEN
+         INFO = -3
+      ELSE IF( M.LT.0 ) THEN
+         INFO = -4
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -5
+      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN
+         INFO = -7
+      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN
+         INFO = -10
+      ELSE IF( LWORK.LT.MAX( 1, NW ) .AND. .NOT.LQUERY ) THEN
+         INFO = -12
+      END IF
+*
+      IF( INFO.EQ.0 ) THEN
+         IF( UPPER ) THEN
+            IF( LEFT ) THEN
+               NB = ILAENV( 1, 'SORMQL', SIDE // TRANS, M-1, N, M-1,
+     $                      -1 )
+            ELSE
+               NB = ILAENV( 1, 'SORMQL', SIDE // TRANS, M, N-1, N-1,
+     $                      -1 )
+            END IF
+         ELSE
+            IF( LEFT ) THEN
+               NB = ILAENV( 1, 'SORMQR', SIDE // TRANS, M-1, N, M-1,
+     $                      -1 )
+            ELSE
+               NB = ILAENV( 1, 'SORMQR', SIDE // TRANS, M, N-1, N-1,
+     $                      -1 )
+            END IF
+         END IF
+         LWKOPT = MAX( 1, NW )*NB
+         WORK( 1 ) = LWKOPT
+      END IF
+*
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SORMTR', -INFO )
+         RETURN
+      ELSE IF( LQUERY ) THEN
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( M.EQ.0 .OR. N.EQ.0 .OR. NQ.EQ.1 ) THEN
+         WORK( 1 ) = 1
+         RETURN
+      END IF
+*
+      IF( LEFT ) THEN
+         MI = M - 1
+         NI = N
+      ELSE
+         MI = M
+         NI = N - 1
+      END IF
+*
+      IF( UPPER ) THEN
+*
+*        Q was determined by a call to SSYTRD with UPLO = 'U'
+*
+         CALL SORMQL( SIDE, TRANS, MI, NI, NQ-1, A( 1, 2 ), LDA, TAU, C,
+     $                LDC, WORK, LWORK, IINFO )
+      ELSE
+*
+*        Q was determined by a call to SSYTRD with UPLO = 'L'
+*
+         IF( LEFT ) THEN
+            I1 = 2
+            I2 = 1
+         ELSE
+            I1 = 1
+            I2 = 2
+         END IF
+         CALL SORMQR( SIDE, TRANS, MI, NI, NQ-1, A( 2, 1 ), LDA, TAU,
+     $                C( I1, I2 ), LDC, WORK, LWORK, IINFO )
+      END IF
+      WORK( 1 ) = LWKOPT
+      RETURN
+*
+*     End of SORMTR
+*
+      END
diff -uN AmberTools/src/quick/src/blas/sstebz.f AmberTools/src/quick/src/blas/sstebz.f
--- AmberTools/src/quick/src/blas/sstebz.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/sstebz.f	2022-08-30 19:16:14.000000000 +0900
@@ -0,0 +1,770 @@
+*> \brief \b SSTEBZ
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SSTEBZ + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sstebz.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sstebz.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sstebz.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SSTEBZ( RANGE, ORDER, N, VL, VU, IL, IU, ABSTOL, D, E,
+*                          M, NSPLIT, W, IBLOCK, ISPLIT, WORK, IWORK,
+*                          INFO )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          ORDER, RANGE
+*       INTEGER            IL, INFO, IU, M, N, NSPLIT
+*       REAL               ABSTOL, VL, VU
+*       ..
+*       .. Array Arguments ..
+*       INTEGER            IBLOCK( * ), ISPLIT( * ), IWORK( * )
+*       REAL               D( * ), E( * ), W( * ), WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SSTEBZ computes the eigenvalues of a symmetric tridiagonal
+*> matrix T.  The user may ask for all eigenvalues, all eigenvalues
+*> in the half-open interval (VL, VU], or the IL-th through IU-th
+*> eigenvalues.
+*>
+*> To avoid overflow, the matrix must be scaled so that its
+*> largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
+*> accuracy, it should not be much smaller than that.
+*>
+*> See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
+*> Matrix", Report CS41, Computer Science Dept., Stanford
+*> University, July 21, 1966.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] RANGE
+*> \verbatim
+*>          RANGE is CHARACTER*1
+*>          = 'A': ("All")   all eigenvalues will be found.
+*>          = 'V': ("Value") all eigenvalues in the half-open interval
+*>                           (VL, VU] will be found.
+*>          = 'I': ("Index") the IL-th through IU-th eigenvalues (of the
+*>                           entire matrix) will be found.
+*> \endverbatim
+*>
+*> \param[in] ORDER
+*> \verbatim
+*>          ORDER is CHARACTER*1
+*>          = 'B': ("By Block") the eigenvalues will be grouped by
+*>                              split-off block (see IBLOCK, ISPLIT) and
+*>                              ordered from smallest to largest within
+*>                              the block.
+*>          = 'E': ("Entire matrix")
+*>                              the eigenvalues for the entire matrix
+*>                              will be ordered from smallest to
+*>                              largest.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the tridiagonal matrix T.  N >= 0.
+*> \endverbatim
+*>
+*> \param[in] VL
+*> \verbatim
+*>          VL is REAL
+*>
+*>          If RANGE='V', the lower bound of the interval to
+*>          be searched for eigenvalues.  Eigenvalues less than or equal
+*>          to VL, or greater than VU, will not be returned.  VL < VU.
+*>          Not referenced if RANGE = 'A' or 'I'.
+*> \endverbatim
+*>
+*> \param[in] VU
+*> \verbatim
+*>          VU is REAL
+*>
+*>          If RANGE='V', the upper bound of the interval to
+*>          be searched for eigenvalues.  Eigenvalues less than or equal
+*>          to VL, or greater than VU, will not be returned.  VL < VU.
+*>          Not referenced if RANGE = 'A' or 'I'.
+*> \endverbatim
+*>
+*> \param[in] IL
+*> \verbatim
+*>          IL is INTEGER
+*>
+*>          If RANGE='I', the index of the
+*>          smallest eigenvalue to be returned.
+*>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
+*>          Not referenced if RANGE = 'A' or 'V'.
+*> \endverbatim
+*>
+*> \param[in] IU
+*> \verbatim
+*>          IU is INTEGER
+*>
+*>          If RANGE='I', the index of the
+*>          largest eigenvalue to be returned.
+*>          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.
+*>          Not referenced if RANGE = 'A' or 'V'.
+*> \endverbatim
+*>
+*> \param[in] ABSTOL
+*> \verbatim
+*>          ABSTOL is REAL
+*>          The absolute tolerance for the eigenvalues.  An eigenvalue
+*>          (or cluster) is considered to be located if it has been
+*>          determined to lie in an interval whose width is ABSTOL or
+*>          less.  If ABSTOL is less than or equal to zero, then ULP*|T|
+*>          will be used, where |T| means the 1-norm of T.
+*>
+*>          Eigenvalues will be computed most accurately when ABSTOL is
+*>          set to twice the underflow threshold 2*SLAMCH('S'), not zero.
+*> \endverbatim
+*>
+*> \param[in] D
+*> \verbatim
+*>          D is REAL array, dimension (N)
+*>          The n diagonal elements of the tridiagonal matrix T.
+*> \endverbatim
+*>
+*> \param[in] E
+*> \verbatim
+*>          E is REAL array, dimension (N-1)
+*>          The (n-1) off-diagonal elements of the tridiagonal matrix T.
+*> \endverbatim
+*>
+*> \param[out] M
+*> \verbatim
+*>          M is INTEGER
+*>          The actual number of eigenvalues found. 0 <= M <= N.
+*>          (See also the description of INFO=2,3.)
+*> \endverbatim
+*>
+*> \param[out] NSPLIT
+*> \verbatim
+*>          NSPLIT is INTEGER
+*>          The number of diagonal blocks in the matrix T.
+*>          1 <= NSPLIT <= N.
+*> \endverbatim
+*>
+*> \param[out] W
+*> \verbatim
+*>          W is REAL array, dimension (N)
+*>          On exit, the first M elements of W will contain the
+*>          eigenvalues.  (SSTEBZ may use the remaining N-M elements as
+*>          workspace.)
+*> \endverbatim
+*>
+*> \param[out] IBLOCK
+*> \verbatim
+*>          IBLOCK is INTEGER array, dimension (N)
+*>          At each row/column j where E(j) is zero or small, the
+*>          matrix T is considered to split into a block diagonal
+*>          matrix.  On exit, if INFO = 0, IBLOCK(i) specifies to which
+*>          block (from 1 to the number of blocks) the eigenvalue W(i)
+*>          belongs.  (SSTEBZ may use the remaining N-M elements as
+*>          workspace.)
+*> \endverbatim
+*>
+*> \param[out] ISPLIT
+*> \verbatim
+*>          ISPLIT is INTEGER array, dimension (N)
+*>          The splitting points, at which T breaks up into submatrices.
+*>          The first submatrix consists of rows/columns 1 to ISPLIT(1),
+*>          the second of rows/columns ISPLIT(1)+1 through ISPLIT(2),
+*>          etc., and the NSPLIT-th consists of rows/columns
+*>          ISPLIT(NSPLIT-1)+1 through ISPLIT(NSPLIT)=N.
+*>          (Only the first NSPLIT elements will actually be used, but
+*>          since the user cannot know a priori what value NSPLIT will
+*>          have, N words must be reserved for ISPLIT.)
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (4*N)
+*> \endverbatim
+*>
+*> \param[out] IWORK
+*> \verbatim
+*>          IWORK is INTEGER array, dimension (3*N)
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument had an illegal value
+*>          > 0:  some or all of the eigenvalues failed to converge or
+*>                were not computed:
+*>                =1 or 3: Bisection failed to converge for some
+*>                        eigenvalues; these eigenvalues are flagged by a
+*>                        negative block number.  The effect is that the
+*>                        eigenvalues may not be as accurate as the
+*>                        absolute and relative tolerances.  This is
+*>                        generally caused by unexpectedly inaccurate
+*>                        arithmetic.
+*>                =2 or 3: RANGE='I' only: Not all of the eigenvalues
+*>                        IL:IU were found.
+*>                        Effect: M < IU+1-IL
+*>                        Cause:  non-monotonic arithmetic, causing the
+*>                                Sturm sequence to be non-monotonic.
+*>                        Cure:   recalculate, using RANGE='A', and pick
+*>                                out eigenvalues IL:IU.  In some cases,
+*>                                increasing the PARAMETER "FUDGE" may
+*>                                make things work.
+*>                = 4:    RANGE='I', and the Gershgorin interval
+*>                        initially used was too small.  No eigenvalues
+*>                        were computed.
+*>                        Probable cause: your machine has sloppy
+*>                                        floating-point arithmetic.
+*>                        Cure: Increase the PARAMETER "FUDGE",
+*>                              recompile, and try again.
+*> \endverbatim
+*
+*> \par Internal Parameters:
+*  =========================
+*>
+*> \verbatim
+*>  RELFAC  REAL, default = 2.0e0
+*>          The relative tolerance.  An interval (a,b] lies within
+*>          "relative tolerance" if  b-a < RELFAC*ulp*max(|a|,|b|),
+*>          where "ulp" is the machine precision (distance from 1 to
+*>          the next larger floating point number.)
+*>
+*>  FUDGE   REAL, default = 2
+*>          A "fudge factor" to widen the Gershgorin intervals.  Ideally,
+*>          a value of 1 should work, but on machines with sloppy
+*>          arithmetic, this needs to be larger.  The default for
+*>          publicly released versions should be large enough to handle
+*>          the worst machine around.  Note that this has no effect
+*>          on accuracy of the solution.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date June 2016
+*
+*> \ingroup auxOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SSTEBZ( RANGE, ORDER, N, VL, VU, IL, IU, ABSTOL, D, E,
+     $                   M, NSPLIT, W, IBLOCK, ISPLIT, WORK, IWORK,
+     $                   INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     June 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          ORDER, RANGE
+      INTEGER            IL, INFO, IU, M, N, NSPLIT
+      REAL               ABSTOL, VL, VU
+*     ..
+*     .. Array Arguments ..
+      INTEGER            IBLOCK( * ), ISPLIT( * ), IWORK( * )
+      REAL               D( * ), E( * ), W( * ), WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO, ONE, TWO, HALF
+      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0, TWO = 2.0E0,
+     $                   HALF = 1.0E0 / TWO )
+      REAL               FUDGE, RELFAC
+      PARAMETER          ( FUDGE = 2.1E0, RELFAC = 2.0E0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            NCNVRG, TOOFEW
+      INTEGER            IB, IBEGIN, IDISCL, IDISCU, IE, IEND, IINFO,
+     $                   IM, IN, IOFF, IORDER, IOUT, IRANGE, ITMAX,
+     $                   ITMP1, IW, IWOFF, J, JB, JDISC, JE, NB, NWL,
+     $                   NWU
+      REAL               ATOLI, BNORM, GL, GU, PIVMIN, RTOLI, SAFEMN,
+     $                   TMP1, TMP2, TNORM, ULP, WKILL, WL, WLU, WU, WUL
+*     ..
+*     .. Local Arrays ..
+      INTEGER            IDUMMA( 1 )
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      INTEGER            ILAENV
+      REAL               SLAMCH
+      EXTERNAL           LSAME, ILAENV, SLAMCH
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLAEBZ, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, INT, LOG, MAX, MIN, SQRT
+*     ..
+*     .. Executable Statements ..
+*
+      INFO = 0
+*
+*     Decode RANGE
+*
+      IF( LSAME( RANGE, 'A' ) ) THEN
+         IRANGE = 1
+      ELSE IF( LSAME( RANGE, 'V' ) ) THEN
+         IRANGE = 2
+      ELSE IF( LSAME( RANGE, 'I' ) ) THEN
+         IRANGE = 3
+      ELSE
+         IRANGE = 0
+      END IF
+*
+*     Decode ORDER
+*
+      IF( LSAME( ORDER, 'B' ) ) THEN
+         IORDER = 2
+      ELSE IF( LSAME( ORDER, 'E' ) ) THEN
+         IORDER = 1
+      ELSE
+         IORDER = 0
+      END IF
+*
+*     Check for Errors
+*
+      IF( IRANGE.LE.0 ) THEN
+         INFO = -1
+      ELSE IF( IORDER.LE.0 ) THEN
+         INFO = -2
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -3
+      ELSE IF( IRANGE.EQ.2 ) THEN
+         IF( VL.GE.VU ) INFO = -5
+      ELSE IF( IRANGE.EQ.3 .AND. ( IL.LT.1 .OR. IL.GT.MAX( 1, N ) ) )
+     $          THEN
+         INFO = -6
+      ELSE IF( IRANGE.EQ.3 .AND. ( IU.LT.MIN( N, IL ) .OR. IU.GT.N ) )
+     $          THEN
+         INFO = -7
+      END IF
+*
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SSTEBZ', -INFO )
+         RETURN
+      END IF
+*
+*     Initialize error flags
+*
+      INFO = 0
+      NCNVRG = .FALSE.
+      TOOFEW = .FALSE.
+*
+*     Quick return if possible
+*
+      M = 0
+      IF( N.EQ.0 )
+     $   RETURN
+*
+*     Simplifications:
+*
+      IF( IRANGE.EQ.3 .AND. IL.EQ.1 .AND. IU.EQ.N )
+     $   IRANGE = 1
+*
+*     Get machine constants
+*     NB is the minimum vector length for vector bisection, or 0
+*     if only scalar is to be done.
+*
+      SAFEMN = SLAMCH( 'S' )
+      ULP = SLAMCH( 'P' )
+      RTOLI = ULP*RELFAC
+      NB = ILAENV( 1, 'SSTEBZ', ' ', N, -1, -1, -1 )
+      IF( NB.LE.1 )
+     $   NB = 0
+*
+*     Special Case when N=1
+*
+      IF( N.EQ.1 ) THEN
+         NSPLIT = 1
+         ISPLIT( 1 ) = 1
+         IF( IRANGE.EQ.2 .AND. ( VL.GE.D( 1 ) .OR. VU.LT.D( 1 ) ) ) THEN
+            M = 0
+         ELSE
+            W( 1 ) = D( 1 )
+            IBLOCK( 1 ) = 1
+            M = 1
+         END IF
+         RETURN
+      END IF
+*
+*     Compute Splitting Points
+*
+      NSPLIT = 1
+      WORK( N ) = ZERO
+      PIVMIN = ONE
+*
+      DO 10 J = 2, N
+         TMP1 = E( J-1 )**2
+         IF( ABS( D( J )*D( J-1 ) )*ULP**2+SAFEMN.GT.TMP1 ) THEN
+            ISPLIT( NSPLIT ) = J - 1
+            NSPLIT = NSPLIT + 1
+            WORK( J-1 ) = ZERO
+         ELSE
+            WORK( J-1 ) = TMP1
+            PIVMIN = MAX( PIVMIN, TMP1 )
+         END IF
+   10 CONTINUE
+      ISPLIT( NSPLIT ) = N
+      PIVMIN = PIVMIN*SAFEMN
+*
+*     Compute Interval and ATOLI
+*
+      IF( IRANGE.EQ.3 ) THEN
+*
+*        RANGE='I': Compute the interval containing eigenvalues
+*                   IL through IU.
+*
+*        Compute Gershgorin interval for entire (split) matrix
+*        and use it as the initial interval
+*
+         GU = D( 1 )
+         GL = D( 1 )
+         TMP1 = ZERO
+*
+         DO 20 J = 1, N - 1
+            TMP2 = SQRT( WORK( J ) )
+            GU = MAX( GU, D( J )+TMP1+TMP2 )
+            GL = MIN( GL, D( J )-TMP1-TMP2 )
+            TMP1 = TMP2
+   20    CONTINUE
+*
+         GU = MAX( GU, D( N )+TMP1 )
+         GL = MIN( GL, D( N )-TMP1 )
+         TNORM = MAX( ABS( GL ), ABS( GU ) )
+         GL = GL - FUDGE*TNORM*ULP*N - FUDGE*TWO*PIVMIN
+         GU = GU + FUDGE*TNORM*ULP*N + FUDGE*PIVMIN
+*
+*        Compute Iteration parameters
+*
+         ITMAX = INT( ( LOG( TNORM+PIVMIN )-LOG( PIVMIN ) ) /
+     $           LOG( TWO ) ) + 2
+         IF( ABSTOL.LE.ZERO ) THEN
+            ATOLI = ULP*TNORM
+         ELSE
+            ATOLI = ABSTOL
+         END IF
+*
+         WORK( N+1 ) = GL
+         WORK( N+2 ) = GL
+         WORK( N+3 ) = GU
+         WORK( N+4 ) = GU
+         WORK( N+5 ) = GL
+         WORK( N+6 ) = GU
+         IWORK( 1 ) = -1
+         IWORK( 2 ) = -1
+         IWORK( 3 ) = N + 1
+         IWORK( 4 ) = N + 1
+         IWORK( 5 ) = IL - 1
+         IWORK( 6 ) = IU
+*
+         CALL SLAEBZ( 3, ITMAX, N, 2, 2, NB, ATOLI, RTOLI, PIVMIN, D, E,
+     $                WORK, IWORK( 5 ), WORK( N+1 ), WORK( N+5 ), IOUT,
+     $                IWORK, W, IBLOCK, IINFO )
+*
+         IF( IWORK( 6 ).EQ.IU ) THEN
+            WL = WORK( N+1 )
+            WLU = WORK( N+3 )
+            NWL = IWORK( 1 )
+            WU = WORK( N+4 )
+            WUL = WORK( N+2 )
+            NWU = IWORK( 4 )
+         ELSE
+            WL = WORK( N+2 )
+            WLU = WORK( N+4 )
+            NWL = IWORK( 2 )
+            WU = WORK( N+3 )
+            WUL = WORK( N+1 )
+            NWU = IWORK( 3 )
+         END IF
+*
+         IF( NWL.LT.0 .OR. NWL.GE.N .OR. NWU.LT.1 .OR. NWU.GT.N ) THEN
+            INFO = 4
+            RETURN
+         END IF
+      ELSE
+*
+*        RANGE='A' or 'V' -- Set ATOLI
+*
+         TNORM = MAX( ABS( D( 1 ) )+ABS( E( 1 ) ),
+     $           ABS( D( N ) )+ABS( E( N-1 ) ) )
+*
+         DO 30 J = 2, N - 1
+            TNORM = MAX( TNORM, ABS( D( J ) )+ABS( E( J-1 ) )+
+     $              ABS( E( J ) ) )
+   30    CONTINUE
+*
+         IF( ABSTOL.LE.ZERO ) THEN
+            ATOLI = ULP*TNORM
+         ELSE
+            ATOLI = ABSTOL
+         END IF
+*
+         IF( IRANGE.EQ.2 ) THEN
+            WL = VL
+            WU = VU
+         ELSE
+            WL = ZERO
+            WU = ZERO
+         END IF
+      END IF
+*
+*     Find Eigenvalues -- Loop Over Blocks and recompute NWL and NWU.
+*     NWL accumulates the number of eigenvalues .le. WL,
+*     NWU accumulates the number of eigenvalues .le. WU
+*
+      M = 0
+      IEND = 0
+      INFO = 0
+      NWL = 0
+      NWU = 0
+*
+      DO 70 JB = 1, NSPLIT
+         IOFF = IEND
+         IBEGIN = IOFF + 1
+         IEND = ISPLIT( JB )
+         IN = IEND - IOFF
+*
+         IF( IN.EQ.1 ) THEN
+*
+*           Special Case -- IN=1
+*
+            IF( IRANGE.EQ.1 .OR. WL.GE.D( IBEGIN )-PIVMIN )
+     $         NWL = NWL + 1
+            IF( IRANGE.EQ.1 .OR. WU.GE.D( IBEGIN )-PIVMIN )
+     $         NWU = NWU + 1
+            IF( IRANGE.EQ.1 .OR. ( WL.LT.D( IBEGIN )-PIVMIN .AND. WU.GE.
+     $          D( IBEGIN )-PIVMIN ) ) THEN
+               M = M + 1
+               W( M ) = D( IBEGIN )
+               IBLOCK( M ) = JB
+            END IF
+         ELSE
+*
+*           General Case -- IN > 1
+*
+*           Compute Gershgorin Interval
+*           and use it as the initial interval
+*
+            GU = D( IBEGIN )
+            GL = D( IBEGIN )
+            TMP1 = ZERO
+*
+            DO 40 J = IBEGIN, IEND - 1
+               TMP2 = ABS( E( J ) )
+               GU = MAX( GU, D( J )+TMP1+TMP2 )
+               GL = MIN( GL, D( J )-TMP1-TMP2 )
+               TMP1 = TMP2
+   40       CONTINUE
+*
+            GU = MAX( GU, D( IEND )+TMP1 )
+            GL = MIN( GL, D( IEND )-TMP1 )
+            BNORM = MAX( ABS( GL ), ABS( GU ) )
+            GL = GL - FUDGE*BNORM*ULP*IN - FUDGE*PIVMIN
+            GU = GU + FUDGE*BNORM*ULP*IN + FUDGE*PIVMIN
+*
+*           Compute ATOLI for the current submatrix
+*
+            IF( ABSTOL.LE.ZERO ) THEN
+               ATOLI = ULP*MAX( ABS( GL ), ABS( GU ) )
+            ELSE
+               ATOLI = ABSTOL
+            END IF
+*
+            IF( IRANGE.GT.1 ) THEN
+               IF( GU.LT.WL ) THEN
+                  NWL = NWL + IN
+                  NWU = NWU + IN
+                  GO TO 70
+               END IF
+               GL = MAX( GL, WL )
+               GU = MIN( GU, WU )
+               IF( GL.GE.GU )
+     $            GO TO 70
+            END IF
+*
+*           Set Up Initial Interval
+*
+            WORK( N+1 ) = GL
+            WORK( N+IN+1 ) = GU
+            CALL SLAEBZ( 1, 0, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,
+     $                   D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),
+     $                   IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IM,
+     $                   IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )
+*
+            NWL = NWL + IWORK( 1 )
+            NWU = NWU + IWORK( IN+1 )
+            IWOFF = M - IWORK( 1 )
+*
+*           Compute Eigenvalues
+*
+            ITMAX = INT( ( LOG( GU-GL+PIVMIN )-LOG( PIVMIN ) ) /
+     $              LOG( TWO ) ) + 2
+            CALL SLAEBZ( 2, ITMAX, IN, IN, 1, NB, ATOLI, RTOLI, PIVMIN,
+     $                   D( IBEGIN ), E( IBEGIN ), WORK( IBEGIN ),
+     $                   IDUMMA, WORK( N+1 ), WORK( N+2*IN+1 ), IOUT,
+     $                   IWORK, W( M+1 ), IBLOCK( M+1 ), IINFO )
+*
+*           Copy Eigenvalues Into W and IBLOCK
+*           Use -JB for block number for unconverged eigenvalues.
+*
+            DO 60 J = 1, IOUT
+               TMP1 = HALF*( WORK( J+N )+WORK( J+IN+N ) )
+*
+*              Flag non-convergence.
+*
+               IF( J.GT.IOUT-IINFO ) THEN
+                  NCNVRG = .TRUE.
+                  IB = -JB
+               ELSE
+                  IB = JB
+               END IF
+               DO 50 JE = IWORK( J ) + 1 + IWOFF,
+     $                 IWORK( J+IN ) + IWOFF
+                  W( JE ) = TMP1
+                  IBLOCK( JE ) = IB
+   50          CONTINUE
+   60       CONTINUE
+*
+            M = M + IM
+         END IF
+   70 CONTINUE
+*
+*     If RANGE='I', then (WL,WU) contains eigenvalues NWL+1,...,NWU
+*     If NWL+1 < IL or NWU > IU, discard extra eigenvalues.
+*
+      IF( IRANGE.EQ.3 ) THEN
+         IM = 0
+         IDISCL = IL - 1 - NWL
+         IDISCU = NWU - IU
+*
+         IF( IDISCL.GT.0 .OR. IDISCU.GT.0 ) THEN
+            DO 80 JE = 1, M
+               IF( W( JE ).LE.WLU .AND. IDISCL.GT.0 ) THEN
+                  IDISCL = IDISCL - 1
+               ELSE IF( W( JE ).GE.WUL .AND. IDISCU.GT.0 ) THEN
+                  IDISCU = IDISCU - 1
+               ELSE
+                  IM = IM + 1
+                  W( IM ) = W( JE )
+                  IBLOCK( IM ) = IBLOCK( JE )
+               END IF
+   80       CONTINUE
+            M = IM
+         END IF
+         IF( IDISCL.GT.0 .OR. IDISCU.GT.0 ) THEN
+*
+*           Code to deal with effects of bad arithmetic:
+*           Some low eigenvalues to be discarded are not in (WL,WLU],
+*           or high eigenvalues to be discarded are not in (WUL,WU]
+*           so just kill off the smallest IDISCL/largest IDISCU
+*           eigenvalues, by simply finding the smallest/largest
+*           eigenvalue(s).
+*
+*           (If N(w) is monotone non-decreasing, this should never
+*               happen.)
+*
+            IF( IDISCL.GT.0 ) THEN
+               WKILL = WU
+               DO 100 JDISC = 1, IDISCL
+                  IW = 0
+                  DO 90 JE = 1, M
+                     IF( IBLOCK( JE ).NE.0 .AND.
+     $                   ( W( JE ).LT.WKILL .OR. IW.EQ.0 ) ) THEN
+                        IW = JE
+                        WKILL = W( JE )
+                     END IF
+   90             CONTINUE
+                  IBLOCK( IW ) = 0
+  100          CONTINUE
+            END IF
+            IF( IDISCU.GT.0 ) THEN
+*
+               WKILL = WL
+               DO 120 JDISC = 1, IDISCU
+                  IW = 0
+                  DO 110 JE = 1, M
+                     IF( IBLOCK( JE ).NE.0 .AND.
+     $                   ( W( JE ).GT.WKILL .OR. IW.EQ.0 ) ) THEN
+                        IW = JE
+                        WKILL = W( JE )
+                     END IF
+  110             CONTINUE
+                  IBLOCK( IW ) = 0
+  120          CONTINUE
+            END IF
+            IM = 0
+            DO 130 JE = 1, M
+               IF( IBLOCK( JE ).NE.0 ) THEN
+                  IM = IM + 1
+                  W( IM ) = W( JE )
+                  IBLOCK( IM ) = IBLOCK( JE )
+               END IF
+  130       CONTINUE
+            M = IM
+         END IF
+         IF( IDISCL.LT.0 .OR. IDISCU.LT.0 ) THEN
+            TOOFEW = .TRUE.
+         END IF
+      END IF
+*
+*     If ORDER='B', do nothing -- the eigenvalues are already sorted
+*        by block.
+*     If ORDER='E', sort the eigenvalues from smallest to largest
+*
+      IF( IORDER.EQ.1 .AND. NSPLIT.GT.1 ) THEN
+         DO 150 JE = 1, M - 1
+            IE = 0
+            TMP1 = W( JE )
+            DO 140 J = JE + 1, M
+               IF( W( J ).LT.TMP1 ) THEN
+                  IE = J
+                  TMP1 = W( J )
+               END IF
+  140       CONTINUE
+*
+            IF( IE.NE.0 ) THEN
+               ITMP1 = IBLOCK( IE )
+               W( IE ) = W( JE )
+               IBLOCK( IE ) = IBLOCK( JE )
+               W( JE ) = TMP1
+               IBLOCK( JE ) = ITMP1
+            END IF
+  150    CONTINUE
+      END IF
+*
+      INFO = 0
+      IF( NCNVRG )
+     $   INFO = INFO + 1
+      IF( TOOFEW )
+     $   INFO = INFO + 2
+      RETURN
+*
+*     End of SSTEBZ
+*
+      END
diff -uN AmberTools/src/quick/src/blas/sstein.f AmberTools/src/quick/src/blas/sstein.f
--- AmberTools/src/quick/src/blas/sstein.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/sstein.f	2022-08-30 19:17:04.000000000 +0900
@@ -0,0 +1,453 @@
+*> \brief \b SSTEIN
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SSTEIN + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sstein.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sstein.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sstein.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SSTEIN( N, D, E, M, W, IBLOCK, ISPLIT, Z, LDZ, WORK,
+*                          IWORK, IFAIL, INFO )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            INFO, LDZ, M, N
+*       ..
+*       .. Array Arguments ..
+*       INTEGER            IBLOCK( * ), IFAIL( * ), ISPLIT( * ),
+*      $                   IWORK( * )
+*       REAL               D( * ), E( * ), W( * ), WORK( * ), Z( LDZ, * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SSTEIN computes the eigenvectors of a real symmetric tridiagonal
+*> matrix T corresponding to specified eigenvalues, using inverse
+*> iteration.
+*>
+*> The maximum number of iterations allowed for each eigenvector is
+*> specified by an internal parameter MAXITS (currently set to 5).
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the matrix.  N >= 0.
+*> \endverbatim
+*>
+*> \param[in] D
+*> \verbatim
+*>          D is REAL array, dimension (N)
+*>          The n diagonal elements of the tridiagonal matrix T.
+*> \endverbatim
+*>
+*> \param[in] E
+*> \verbatim
+*>          E is REAL array, dimension (N-1)
+*>          The (n-1) subdiagonal elements of the tridiagonal matrix
+*>          T, in elements 1 to N-1.
+*> \endverbatim
+*>
+*> \param[in] M
+*> \verbatim
+*>          M is INTEGER
+*>          The number of eigenvectors to be found.  0 <= M <= N.
+*> \endverbatim
+*>
+*> \param[in] W
+*> \verbatim
+*>          W is REAL array, dimension (N)
+*>          The first M elements of W contain the eigenvalues for
+*>          which eigenvectors are to be computed.  The eigenvalues
+*>          should be grouped by split-off block and ordered from
+*>          smallest to largest within the block.  ( The output array
+*>          W from SSTEBZ with ORDER = 'B' is expected here. )
+*> \endverbatim
+*>
+*> \param[in] IBLOCK
+*> \verbatim
+*>          IBLOCK is INTEGER array, dimension (N)
+*>          The submatrix indices associated with the corresponding
+*>          eigenvalues in W; IBLOCK(i)=1 if eigenvalue W(i) belongs to
+*>          the first submatrix from the top, =2 if W(i) belongs to
+*>          the second submatrix, etc.  ( The output array IBLOCK
+*>          from SSTEBZ is expected here. )
+*> \endverbatim
+*>
+*> \param[in] ISPLIT
+*> \verbatim
+*>          ISPLIT is INTEGER array, dimension (N)
+*>          The splitting points, at which T breaks up into submatrices.
+*>          The first submatrix consists of rows/columns 1 to
+*>          ISPLIT( 1 ), the second of rows/columns ISPLIT( 1 )+1
+*>          through ISPLIT( 2 ), etc.
+*>          ( The output array ISPLIT from SSTEBZ is expected here. )
+*> \endverbatim
+*>
+*> \param[out] Z
+*> \verbatim
+*>          Z is REAL array, dimension (LDZ, M)
+*>          The computed eigenvectors.  The eigenvector associated
+*>          with the eigenvalue W(i) is stored in the i-th column of
+*>          Z.  Any vector which fails to converge is set to its current
+*>          iterate after MAXITS iterations.
+*> \endverbatim
+*>
+*> \param[in] LDZ
+*> \verbatim
+*>          LDZ is INTEGER
+*>          The leading dimension of the array Z.  LDZ >= max(1,N).
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (5*N)
+*> \endverbatim
+*>
+*> \param[out] IWORK
+*> \verbatim
+*>          IWORK is INTEGER array, dimension (N)
+*> \endverbatim
+*>
+*> \param[out] IFAIL
+*> \verbatim
+*>          IFAIL is INTEGER array, dimension (M)
+*>          On normal exit, all elements of IFAIL are zero.
+*>          If one or more eigenvectors fail to converge after
+*>          MAXITS iterations, then their indices are stored in
+*>          array IFAIL.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0: successful exit.
+*>          < 0: if INFO = -i, the i-th argument had an illegal value
+*>          > 0: if INFO = i, then i eigenvectors failed to converge
+*>               in MAXITS iterations.  Their indices are stored in
+*>               array IFAIL.
+*> \endverbatim
+*
+*> \par Internal Parameters:
+*  =========================
+*>
+*> \verbatim
+*>  MAXITS  INTEGER, default = 5
+*>          The maximum number of iterations performed.
+*>
+*>  EXTRA   INTEGER, default = 2
+*>          The number of iterations performed after norm growth
+*>          criterion is satisfied, should be at least 1.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SSTEIN( N, D, E, M, W, IBLOCK, ISPLIT, Z, LDZ, WORK,
+     $                   IWORK, IFAIL, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      INTEGER            INFO, LDZ, M, N
+*     ..
+*     .. Array Arguments ..
+      INTEGER            IBLOCK( * ), IFAIL( * ), ISPLIT( * ),
+     $                   IWORK( * )
+      REAL               D( * ), E( * ), W( * ), WORK( * ), Z( LDZ, * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO, ONE, TEN, ODM3, ODM1
+      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0, TEN = 1.0E+1,
+     $                   ODM3 = 1.0E-3, ODM1 = 1.0E-1 )
+      INTEGER            MAXITS, EXTRA
+      PARAMETER          ( MAXITS = 5, EXTRA = 2 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            B1, BLKSIZ, BN, GPIND, I, IINFO, INDRV1,
+     $                   INDRV2, INDRV3, INDRV4, INDRV5, ITS, J, J1,
+     $                   JBLK, JMAX, NBLK, NRMCHK
+      REAL               CTR, EPS, EPS1, NRM, ONENRM, ORTOL, PERTOL,
+     $                   SCL, SEP, STPCRT, TOL, XJ, XJM
+*     ..
+*     .. Local Arrays ..
+      INTEGER            ISEED( 4 )
+*     ..
+*     .. External Functions ..
+      INTEGER            ISAMAX
+      REAL               SDOT, SLAMCH, SNRM2
+      EXTERNAL           ISAMAX, SDOT, SLAMCH, SNRM2
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SAXPY, SCOPY, SLAGTF, SLAGTS, SLARNV, SSCAL,
+     $                   XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, MAX, SQRT
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters.
+*
+      INFO = 0
+      DO 10 I = 1, M
+         IFAIL( I ) = 0
+   10 CONTINUE
+*
+      IF( N.LT.0 ) THEN
+         INFO = -1
+      ELSE IF( M.LT.0 .OR. M.GT.N ) THEN
+         INFO = -4
+      ELSE IF( LDZ.LT.MAX( 1, N ) ) THEN
+         INFO = -9
+      ELSE
+         DO 20 J = 2, M
+            IF( IBLOCK( J ).LT.IBLOCK( J-1 ) ) THEN
+               INFO = -6
+               GO TO 30
+            END IF
+            IF( IBLOCK( J ).EQ.IBLOCK( J-1 ) .AND. W( J ).LT.W( J-1 ) )
+     $           THEN
+               INFO = -5
+               GO TO 30
+            END IF
+   20    CONTINUE
+   30    CONTINUE
+      END IF
+*
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SSTEIN', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 .OR. M.EQ.0 ) THEN
+         RETURN
+      ELSE IF( N.EQ.1 ) THEN
+         Z( 1, 1 ) = ONE
+         RETURN
+      END IF
+*
+*     Get machine constants.
+*
+      EPS = SLAMCH( 'Precision' )
+*
+*     Initialize seed for random number generator SLARNV.
+*
+      DO 40 I = 1, 4
+         ISEED( I ) = 1
+   40 CONTINUE
+*
+*     Initialize pointers.
+*
+      INDRV1 = 0
+      INDRV2 = INDRV1 + N
+      INDRV3 = INDRV2 + N
+      INDRV4 = INDRV3 + N
+      INDRV5 = INDRV4 + N
+*
+*     Compute eigenvectors of matrix blocks.
+*
+      J1 = 1
+      DO 160 NBLK = 1, IBLOCK( M )
+*
+*        Find starting and ending indices of block nblk.
+*
+         IF( NBLK.EQ.1 ) THEN
+            B1 = 1
+         ELSE
+            B1 = ISPLIT( NBLK-1 ) + 1
+         END IF
+         BN = ISPLIT( NBLK )
+         BLKSIZ = BN - B1 + 1
+         IF( BLKSIZ.EQ.1 )
+     $      GO TO 60
+         GPIND = J1
+*
+*        Compute reorthogonalization criterion and stopping criterion.
+*
+         ONENRM = ABS( D( B1 ) ) + ABS( E( B1 ) )
+         ONENRM = MAX( ONENRM, ABS( D( BN ) )+ABS( E( BN-1 ) ) )
+         DO 50 I = B1 + 1, BN - 1
+            ONENRM = MAX( ONENRM, ABS( D( I ) )+ABS( E( I-1 ) )+
+     $               ABS( E( I ) ) )
+   50    CONTINUE
+         ORTOL = ODM3*ONENRM
+*
+         STPCRT = SQRT( ODM1 / BLKSIZ )
+*
+*        Loop through eigenvalues of block nblk.
+*
+   60    CONTINUE
+         JBLK = 0
+         DO 150 J = J1, M
+            IF( IBLOCK( J ).NE.NBLK ) THEN
+               J1 = J
+               GO TO 160
+            END IF
+            JBLK = JBLK + 1
+            XJ = W( J )
+*
+*           Skip all the work if the block size is one.
+*
+            IF( BLKSIZ.EQ.1 ) THEN
+               WORK( INDRV1+1 ) = ONE
+               GO TO 120
+            END IF
+*
+*           If eigenvalues j and j-1 are too close, add a relatively
+*           small perturbation.
+*
+            IF( JBLK.GT.1 ) THEN
+               EPS1 = ABS( EPS*XJ )
+               PERTOL = TEN*EPS1
+               SEP = XJ - XJM
+               IF( SEP.LT.PERTOL )
+     $            XJ = XJM + PERTOL
+            END IF
+*
+            ITS = 0
+            NRMCHK = 0
+*
+*           Get random starting vector.
+*
+            CALL SLARNV( 2, ISEED, BLKSIZ, WORK( INDRV1+1 ) )
+*
+*           Copy the matrix T so it won't be destroyed in factorization.
+*
+            CALL SCOPY( BLKSIZ, D( B1 ), 1, WORK( INDRV4+1 ), 1 )
+            CALL SCOPY( BLKSIZ-1, E( B1 ), 1, WORK( INDRV2+2 ), 1 )
+            CALL SCOPY( BLKSIZ-1, E( B1 ), 1, WORK( INDRV3+1 ), 1 )
+*
+*           Compute LU factors with partial pivoting  ( PT = LU )
+*
+            TOL = ZERO
+            CALL SLAGTF( BLKSIZ, WORK( INDRV4+1 ), XJ, WORK( INDRV2+2 ),
+     $                   WORK( INDRV3+1 ), TOL, WORK( INDRV5+1 ), IWORK,
+     $                   IINFO )
+*
+*           Update iteration count.
+*
+   70       CONTINUE
+            ITS = ITS + 1
+            IF( ITS.GT.MAXITS )
+     $         GO TO 100
+*
+*           Normalize and scale the righthand side vector Pb.
+*
+            JMAX = ISAMAX( BLKSIZ, WORK( INDRV1+1 ), 1 )
+            SCL = BLKSIZ*ONENRM*MAX( EPS,
+     $            ABS( WORK( INDRV4+BLKSIZ ) ) ) /
+     $            ABS( WORK( INDRV1+JMAX ) )
+            CALL SSCAL( BLKSIZ, SCL, WORK( INDRV1+1 ), 1 )
+*
+*           Solve the system LU = Pb.
+*
+            CALL SLAGTS( -1, BLKSIZ, WORK( INDRV4+1 ), WORK( INDRV2+2 ),
+     $                   WORK( INDRV3+1 ), WORK( INDRV5+1 ), IWORK,
+     $                   WORK( INDRV1+1 ), TOL, IINFO )
+*
+*           Reorthogonalize by modified Gram-Schmidt if eigenvalues are
+*           close enough.
+*
+            IF( JBLK.EQ.1 )
+     $         GO TO 90
+            IF( ABS( XJ-XJM ).GT.ORTOL )
+     $         GPIND = J
+            IF( GPIND.NE.J ) THEN
+               DO 80 I = GPIND, J - 1
+                  CTR = -SDOT( BLKSIZ, WORK( INDRV1+1 ), 1, Z( B1, I ),
+     $                  1 )
+                  CALL SAXPY( BLKSIZ, CTR, Z( B1, I ), 1,
+     $                        WORK( INDRV1+1 ), 1 )
+   80          CONTINUE
+            END IF
+*
+*           Check the infinity norm of the iterate.
+*
+   90       CONTINUE
+            JMAX = ISAMAX( BLKSIZ, WORK( INDRV1+1 ), 1 )
+            NRM = ABS( WORK( INDRV1+JMAX ) )
+*
+*           Continue for additional iterations after norm reaches
+*           stopping criterion.
+*
+            IF( NRM.LT.STPCRT )
+     $         GO TO 70
+            NRMCHK = NRMCHK + 1
+            IF( NRMCHK.LT.EXTRA+1 )
+     $         GO TO 70
+*
+            GO TO 110
+*
+*           If stopping criterion was not satisfied, update info and
+*           store eigenvector number in array ifail.
+*
+  100       CONTINUE
+            INFO = INFO + 1
+            IFAIL( INFO ) = J
+*
+*           Accept iterate as jth eigenvector.
+*
+  110       CONTINUE
+            SCL = ONE / SNRM2( BLKSIZ, WORK( INDRV1+1 ), 1 )
+            JMAX = ISAMAX( BLKSIZ, WORK( INDRV1+1 ), 1 )
+            IF( WORK( INDRV1+JMAX ).LT.ZERO )
+     $         SCL = -SCL
+            CALL SSCAL( BLKSIZ, SCL, WORK( INDRV1+1 ), 1 )
+  120       CONTINUE
+            DO 130 I = 1, N
+               Z( I, J ) = ZERO
+  130       CONTINUE
+            DO 140 I = 1, BLKSIZ
+               Z( B1+I-1, J ) = WORK( INDRV1+I )
+  140       CONTINUE
+*
+*           Save the shift to check eigenvalue spacing at next
+*           iteration.
+*
+            XJM = XJ
+*
+  150    CONTINUE
+  160 CONTINUE
+*
+      RETURN
+*
+*     End of SSTEIN
+*
+      END
diff -uN AmberTools/src/quick/src/blas/ssteqr.f AmberTools/src/quick/src/blas/ssteqr.f
--- AmberTools/src/quick/src/blas/ssteqr.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/ssteqr.f	2022-08-30 19:14:36.000000000 +0900
@@ -0,0 +1,572 @@
+*> \brief \b SSTEQR
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SSTEQR + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ssteqr.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ssteqr.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssteqr.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SSTEQR( COMPZ, N, D, E, Z, LDZ, WORK, INFO )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          COMPZ
+*       INTEGER            INFO, LDZ, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               D( * ), E( * ), WORK( * ), Z( LDZ, * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SSTEQR computes all eigenvalues and, optionally, eigenvectors of a
+*> symmetric tridiagonal matrix using the implicit QL or QR method.
+*> The eigenvectors of a full or band symmetric matrix can also be found
+*> if SSYTRD or SSPTRD or SSBTRD has been used to reduce this matrix to
+*> tridiagonal form.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] COMPZ
+*> \verbatim
+*>          COMPZ is CHARACTER*1
+*>          = 'N':  Compute eigenvalues only.
+*>          = 'V':  Compute eigenvalues and eigenvectors of the original
+*>                  symmetric matrix.  On entry, Z must contain the
+*>                  orthogonal matrix used to reduce the original matrix
+*>                  to tridiagonal form.
+*>          = 'I':  Compute eigenvalues and eigenvectors of the
+*>                  tridiagonal matrix.  Z is initialized to the identity
+*>                  matrix.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the matrix.  N >= 0.
+*> \endverbatim
+*>
+*> \param[in,out] D
+*> \verbatim
+*>          D is REAL array, dimension (N)
+*>          On entry, the diagonal elements of the tridiagonal matrix.
+*>          On exit, if INFO = 0, the eigenvalues in ascending order.
+*> \endverbatim
+*>
+*> \param[in,out] E
+*> \verbatim
+*>          E is REAL array, dimension (N-1)
+*>          On entry, the (n-1) subdiagonal elements of the tridiagonal
+*>          matrix.
+*>          On exit, E has been destroyed.
+*> \endverbatim
+*>
+*> \param[in,out] Z
+*> \verbatim
+*>          Z is REAL array, dimension (LDZ, N)
+*>          On entry, if  COMPZ = 'V', then Z contains the orthogonal
+*>          matrix used in the reduction to tridiagonal form.
+*>          On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
+*>          orthonormal eigenvectors of the original symmetric matrix,
+*>          and if COMPZ = 'I', Z contains the orthonormal eigenvectors
+*>          of the symmetric tridiagonal matrix.
+*>          If COMPZ = 'N', then Z is not referenced.
+*> \endverbatim
+*>
+*> \param[in] LDZ
+*> \verbatim
+*>          LDZ is INTEGER
+*>          The leading dimension of the array Z.  LDZ >= 1, and if
+*>          eigenvectors are desired, then  LDZ >= max(1,N).
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (max(1,2*N-2))
+*>          If COMPZ = 'N', then WORK is not referenced.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument had an illegal value
+*>          > 0:  the algorithm has failed to find all the eigenvalues in
+*>                a total of 30*N iterations; if INFO = i, then i
+*>                elements of E have not converged to zero; on exit, D
+*>                and E contain the elements of a symmetric tridiagonal
+*>                matrix which is orthogonally similar to the original
+*>                matrix.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup auxOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SSTEQR( COMPZ, N, D, E, Z, LDZ, WORK, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          COMPZ
+      INTEGER            INFO, LDZ, N
+*     ..
+*     .. Array Arguments ..
+      REAL               D( * ), E( * ), WORK( * ), Z( LDZ, * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO, ONE, TWO, THREE
+      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0, TWO = 2.0E0,
+     $                   THREE = 3.0E0 )
+      INTEGER            MAXIT
+      PARAMETER          ( MAXIT = 30 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, ICOMPZ, II, ISCALE, J, JTOT, K, L, L1, LEND,
+     $                   LENDM1, LENDP1, LENDSV, LM1, LSV, M, MM, MM1,
+     $                   NM1, NMAXIT
+      REAL               ANORM, B, C, EPS, EPS2, F, G, P, R, RT1, RT2,
+     $                   S, SAFMAX, SAFMIN, SSFMAX, SSFMIN, TST
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      REAL               SLAMCH, SLANST, SLAPY2
+      EXTERNAL           LSAME, SLAMCH, SLANST, SLAPY2
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLAE2, SLAEV2, SLARTG, SLASCL, SLASET, SLASR,
+     $                   SLASRT, SSWAP, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, MAX, SIGN, SQRT
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters.
+*
+      INFO = 0
+*
+      IF( LSAME( COMPZ, 'N' ) ) THEN
+         ICOMPZ = 0
+      ELSE IF( LSAME( COMPZ, 'V' ) ) THEN
+         ICOMPZ = 1
+      ELSE IF( LSAME( COMPZ, 'I' ) ) THEN
+         ICOMPZ = 2
+      ELSE
+         ICOMPZ = -1
+      END IF
+      IF( ICOMPZ.LT.0 ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -2
+      ELSE IF( ( LDZ.LT.1 ) .OR. ( ICOMPZ.GT.0 .AND. LDZ.LT.MAX( 1,
+     $         N ) ) ) THEN
+         INFO = -6
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SSTEQR', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 )
+     $   RETURN
+*
+      IF( N.EQ.1 ) THEN
+         IF( ICOMPZ.EQ.2 )
+     $      Z( 1, 1 ) = ONE
+         RETURN
+      END IF
+*
+*     Determine the unit roundoff and over/underflow thresholds.
+*
+      EPS = SLAMCH( 'E' )
+      EPS2 = EPS**2
+      SAFMIN = SLAMCH( 'S' )
+      SAFMAX = ONE / SAFMIN
+      SSFMAX = SQRT( SAFMAX ) / THREE
+      SSFMIN = SQRT( SAFMIN ) / EPS2
+*
+*     Compute the eigenvalues and eigenvectors of the tridiagonal
+*     matrix.
+*
+      IF( ICOMPZ.EQ.2 )
+     $   CALL SLASET( 'Full', N, N, ZERO, ONE, Z, LDZ )
+*
+      NMAXIT = N*MAXIT
+      JTOT = 0
+*
+*     Determine where the matrix splits and choose QL or QR iteration
+*     for each block, according to whether top or bottom diagonal
+*     element is smaller.
+*
+      L1 = 1
+      NM1 = N - 1
+*
+   10 CONTINUE
+      IF( L1.GT.N )
+     $   GO TO 160
+      IF( L1.GT.1 )
+     $   E( L1-1 ) = ZERO
+      IF( L1.LE.NM1 ) THEN
+         DO 20 M = L1, NM1
+            TST = ABS( E( M ) )
+            IF( TST.EQ.ZERO )
+     $         GO TO 30
+            IF( TST.LE.( SQRT( ABS( D( M ) ) )*SQRT( ABS( D( M+
+     $          1 ) ) ) )*EPS ) THEN
+               E( M ) = ZERO
+               GO TO 30
+            END IF
+   20    CONTINUE
+      END IF
+      M = N
+*
+   30 CONTINUE
+      L = L1
+      LSV = L
+      LEND = M
+      LENDSV = LEND
+      L1 = M + 1
+      IF( LEND.EQ.L )
+     $   GO TO 10
+*
+*     Scale submatrix in rows and columns L to LEND
+*
+      ANORM = SLANST( 'M', LEND-L+1, D( L ), E( L ) )
+      ISCALE = 0
+      IF( ANORM.EQ.ZERO )
+     $   GO TO 10
+      IF( ANORM.GT.SSFMAX ) THEN
+         ISCALE = 1
+         CALL SLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L+1, 1, D( L ), N,
+     $                INFO )
+         CALL SLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L, 1, E( L ), N,
+     $                INFO )
+      ELSE IF( ANORM.LT.SSFMIN ) THEN
+         ISCALE = 2
+         CALL SLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L+1, 1, D( L ), N,
+     $                INFO )
+         CALL SLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L, 1, E( L ), N,
+     $                INFO )
+      END IF
+*
+*     Choose between QL and QR iteration
+*
+      IF( ABS( D( LEND ) ).LT.ABS( D( L ) ) ) THEN
+         LEND = LSV
+         L = LENDSV
+      END IF
+*
+      IF( LEND.GT.L ) THEN
+*
+*        QL Iteration
+*
+*        Look for small subdiagonal element.
+*
+   40    CONTINUE
+         IF( L.NE.LEND ) THEN
+            LENDM1 = LEND - 1
+            DO 50 M = L, LENDM1
+               TST = ABS( E( M ) )**2
+               IF( TST.LE.( EPS2*ABS( D( M ) ) )*ABS( D( M+1 ) )+
+     $             SAFMIN )GO TO 60
+   50       CONTINUE
+         END IF
+*
+         M = LEND
+*
+   60    CONTINUE
+         IF( M.LT.LEND )
+     $      E( M ) = ZERO
+         P = D( L )
+         IF( M.EQ.L )
+     $      GO TO 80
+*
+*        If remaining matrix is 2-by-2, use SLAE2 or SLAEV2
+*        to compute its eigensystem.
+*
+         IF( M.EQ.L+1 ) THEN
+            IF( ICOMPZ.GT.0 ) THEN
+               CALL SLAEV2( D( L ), E( L ), D( L+1 ), RT1, RT2, C, S )
+               WORK( L ) = C
+               WORK( N-1+L ) = S
+               CALL SLASR( 'R', 'V', 'B', N, 2, WORK( L ),
+     $                     WORK( N-1+L ), Z( 1, L ), LDZ )
+            ELSE
+               CALL SLAE2( D( L ), E( L ), D( L+1 ), RT1, RT2 )
+            END IF
+            D( L ) = RT1
+            D( L+1 ) = RT2
+            E( L ) = ZERO
+            L = L + 2
+            IF( L.LE.LEND )
+     $         GO TO 40
+            GO TO 140
+         END IF
+*
+         IF( JTOT.EQ.NMAXIT )
+     $      GO TO 140
+         JTOT = JTOT + 1
+*
+*        Form shift.
+*
+         G = ( D( L+1 )-P ) / ( TWO*E( L ) )
+         R = SLAPY2( G, ONE )
+         G = D( M ) - P + ( E( L ) / ( G+SIGN( R, G ) ) )
+*
+         S = ONE
+         C = ONE
+         P = ZERO
+*
+*        Inner loop
+*
+         MM1 = M - 1
+         DO 70 I = MM1, L, -1
+            F = S*E( I )
+            B = C*E( I )
+            CALL SLARTG( G, F, C, S, R )
+            IF( I.NE.M-1 )
+     $         E( I+1 ) = R
+            G = D( I+1 ) - P
+            R = ( D( I )-G )*S + TWO*C*B
+            P = S*R
+            D( I+1 ) = G + P
+            G = C*R - B
+*
+*           If eigenvectors are desired, then save rotations.
+*
+            IF( ICOMPZ.GT.0 ) THEN
+               WORK( I ) = C
+               WORK( N-1+I ) = -S
+            END IF
+*
+   70    CONTINUE
+*
+*        If eigenvectors are desired, then apply saved rotations.
+*
+         IF( ICOMPZ.GT.0 ) THEN
+            MM = M - L + 1
+            CALL SLASR( 'R', 'V', 'B', N, MM, WORK( L ), WORK( N-1+L ),
+     $                  Z( 1, L ), LDZ )
+         END IF
+*
+         D( L ) = D( L ) - P
+         E( L ) = G
+         GO TO 40
+*
+*        Eigenvalue found.
+*
+   80    CONTINUE
+         D( L ) = P
+*
+         L = L + 1
+         IF( L.LE.LEND )
+     $      GO TO 40
+         GO TO 140
+*
+      ELSE
+*
+*        QR Iteration
+*
+*        Look for small superdiagonal element.
+*
+   90    CONTINUE
+         IF( L.NE.LEND ) THEN
+            LENDP1 = LEND + 1
+            DO 100 M = L, LENDP1, -1
+               TST = ABS( E( M-1 ) )**2
+               IF( TST.LE.( EPS2*ABS( D( M ) ) )*ABS( D( M-1 ) )+
+     $             SAFMIN )GO TO 110
+  100       CONTINUE
+         END IF
+*
+         M = LEND
+*
+  110    CONTINUE
+         IF( M.GT.LEND )
+     $      E( M-1 ) = ZERO
+         P = D( L )
+         IF( M.EQ.L )
+     $      GO TO 130
+*
+*        If remaining matrix is 2-by-2, use SLAE2 or SLAEV2
+*        to compute its eigensystem.
+*
+         IF( M.EQ.L-1 ) THEN
+            IF( ICOMPZ.GT.0 ) THEN
+               CALL SLAEV2( D( L-1 ), E( L-1 ), D( L ), RT1, RT2, C, S )
+               WORK( M ) = C
+               WORK( N-1+M ) = S
+               CALL SLASR( 'R', 'V', 'F', N, 2, WORK( M ),
+     $                     WORK( N-1+M ), Z( 1, L-1 ), LDZ )
+            ELSE
+               CALL SLAE2( D( L-1 ), E( L-1 ), D( L ), RT1, RT2 )
+            END IF
+            D( L-1 ) = RT1
+            D( L ) = RT2
+            E( L-1 ) = ZERO
+            L = L - 2
+            IF( L.GE.LEND )
+     $         GO TO 90
+            GO TO 140
+         END IF
+*
+         IF( JTOT.EQ.NMAXIT )
+     $      GO TO 140
+         JTOT = JTOT + 1
+*
+*        Form shift.
+*
+         G = ( D( L-1 )-P ) / ( TWO*E( L-1 ) )
+         R = SLAPY2( G, ONE )
+         G = D( M ) - P + ( E( L-1 ) / ( G+SIGN( R, G ) ) )
+*
+         S = ONE
+         C = ONE
+         P = ZERO
+*
+*        Inner loop
+*
+         LM1 = L - 1
+         DO 120 I = M, LM1
+            F = S*E( I )
+            B = C*E( I )
+            CALL SLARTG( G, F, C, S, R )
+            IF( I.NE.M )
+     $         E( I-1 ) = R
+            G = D( I ) - P
+            R = ( D( I+1 )-G )*S + TWO*C*B
+            P = S*R
+            D( I ) = G + P
+            G = C*R - B
+*
+*           If eigenvectors are desired, then save rotations.
+*
+            IF( ICOMPZ.GT.0 ) THEN
+               WORK( I ) = C
+               WORK( N-1+I ) = S
+            END IF
+*
+  120    CONTINUE
+*
+*        If eigenvectors are desired, then apply saved rotations.
+*
+         IF( ICOMPZ.GT.0 ) THEN
+            MM = L - M + 1
+            CALL SLASR( 'R', 'V', 'F', N, MM, WORK( M ), WORK( N-1+M ),
+     $                  Z( 1, M ), LDZ )
+         END IF
+*
+         D( L ) = D( L ) - P
+         E( LM1 ) = G
+         GO TO 90
+*
+*        Eigenvalue found.
+*
+  130    CONTINUE
+         D( L ) = P
+*
+         L = L - 1
+         IF( L.GE.LEND )
+     $      GO TO 90
+         GO TO 140
+*
+      END IF
+*
+*     Undo scaling if necessary
+*
+  140 CONTINUE
+      IF( ISCALE.EQ.1 ) THEN
+         CALL SLASCL( 'G', 0, 0, SSFMAX, ANORM, LENDSV-LSV+1, 1,
+     $                D( LSV ), N, INFO )
+         CALL SLASCL( 'G', 0, 0, SSFMAX, ANORM, LENDSV-LSV, 1, E( LSV ),
+     $                N, INFO )
+      ELSE IF( ISCALE.EQ.2 ) THEN
+         CALL SLASCL( 'G', 0, 0, SSFMIN, ANORM, LENDSV-LSV+1, 1,
+     $                D( LSV ), N, INFO )
+         CALL SLASCL( 'G', 0, 0, SSFMIN, ANORM, LENDSV-LSV, 1, E( LSV ),
+     $                N, INFO )
+      END IF
+*
+*     Check for no convergence to an eigenvalue after a total
+*     of N*MAXIT iterations.
+*
+      IF( JTOT.LT.NMAXIT )
+     $   GO TO 10
+      DO 150 I = 1, N - 1
+         IF( E( I ).NE.ZERO )
+     $      INFO = INFO + 1
+  150 CONTINUE
+      GO TO 190
+*
+*     Order eigenvalues and eigenvectors.
+*
+  160 CONTINUE
+      IF( ICOMPZ.EQ.0 ) THEN
+*
+*        Use Quick Sort
+*
+         CALL SLASRT( 'I', N, D, INFO )
+*
+      ELSE
+*
+*        Use Selection Sort to minimize swaps of eigenvectors
+*
+         DO 180 II = 2, N
+            I = II - 1
+            K = I
+            P = D( I )
+            DO 170 J = II, N
+               IF( D( J ).LT.P ) THEN
+                  K = J
+                  P = D( J )
+               END IF
+  170       CONTINUE
+            IF( K.NE.I ) THEN
+               D( K ) = D( I )
+               D( I ) = P
+               CALL SSWAP( N, Z( 1, I ), 1, Z( 1, K ), 1 )
+            END IF
+  180    CONTINUE
+      END IF
+*
+  190 CONTINUE
+      RETURN
+*
+*     End of SSTEQR
+*
+      END
diff -uN AmberTools/src/quick/src/blas/ssterf.f AmberTools/src/quick/src/blas/ssterf.f
--- AmberTools/src/quick/src/blas/ssterf.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/ssterf.f	2022-08-30 19:18:17.000000000 +0900
@@ -0,0 +1,425 @@
+*> \brief \b SSTERF
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SSTERF + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ssterf.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ssterf.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssterf.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SSTERF( N, D, E, INFO )
+*
+*       .. Scalar Arguments ..
+*       INTEGER            INFO, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               D( * ), E( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SSTERF computes all eigenvalues of a symmetric tridiagonal matrix
+*> using the Pal-Walker-Kahan variant of the QL or QR algorithm.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the matrix.  N >= 0.
+*> \endverbatim
+*>
+*> \param[in,out] D
+*> \verbatim
+*>          D is REAL array, dimension (N)
+*>          On entry, the n diagonal elements of the tridiagonal matrix.
+*>          On exit, if INFO = 0, the eigenvalues in ascending order.
+*> \endverbatim
+*>
+*> \param[in,out] E
+*> \verbatim
+*>          E is REAL array, dimension (N-1)
+*>          On entry, the (n-1) subdiagonal elements of the tridiagonal
+*>          matrix.
+*>          On exit, E has been destroyed.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument had an illegal value
+*>          > 0:  the algorithm failed to find all of the eigenvalues in
+*>                a total of 30*N iterations; if INFO = i, then i
+*>                elements of E have not converged to zero.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup auxOTHERcomputational
+*
+*  =====================================================================
+      SUBROUTINE SSTERF( N, D, E, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      INTEGER            INFO, N
+*     ..
+*     .. Array Arguments ..
+      REAL               D( * ), E( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ZERO, ONE, TWO, THREE
+      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0, TWO = 2.0E0,
+     $                   THREE = 3.0E0 )
+      INTEGER            MAXIT
+      PARAMETER          ( MAXIT = 30 )
+*     ..
+*     .. Local Scalars ..
+      INTEGER            I, ISCALE, JTOT, L, L1, LEND, LENDSV, LSV, M,
+     $                   NMAXIT
+      REAL               ALPHA, ANORM, BB, C, EPS, EPS2, GAMMA, OLDC,
+     $                   OLDGAM, P, R, RT1, RT2, RTE, S, SAFMAX, SAFMIN,
+     $                   SIGMA, SSFMAX, SSFMIN
+*     ..
+*     .. External Functions ..
+      REAL               SLAMCH, SLANST, SLAPY2
+      EXTERNAL           SLAMCH, SLANST, SLAPY2
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLAE2, SLASCL, SLASRT, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          ABS, SIGN, SQRT
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters.
+*
+      INFO = 0
+*
+*     Quick return if possible
+*
+      IF( N.LT.0 ) THEN
+         INFO = -1
+         CALL XERBLA( 'SSTERF', -INFO )
+         RETURN
+      END IF
+      IF( N.LE.1 )
+     $   RETURN
+*
+*     Determine the unit roundoff for this environment.
+*
+      EPS = SLAMCH( 'E' )
+      EPS2 = EPS**2
+      SAFMIN = SLAMCH( 'S' )
+      SAFMAX = ONE / SAFMIN
+      SSFMAX = SQRT( SAFMAX ) / THREE
+      SSFMIN = SQRT( SAFMIN ) / EPS2
+*
+*     Compute the eigenvalues of the tridiagonal matrix.
+*
+      NMAXIT = N*MAXIT
+      SIGMA = ZERO
+      JTOT = 0
+*
+*     Determine where the matrix splits and choose QL or QR iteration
+*     for each block, according to whether top or bottom diagonal
+*     element is smaller.
+*
+      L1 = 1
+*
+   10 CONTINUE
+      IF( L1.GT.N )
+     $   GO TO 170
+      IF( L1.GT.1 )
+     $   E( L1-1 ) = ZERO
+      DO 20 M = L1, N - 1
+         IF( ABS( E( M ) ).LE.( SQRT( ABS( D( M ) ) )*
+     $       SQRT( ABS( D( M+1 ) ) ) )*EPS ) THEN
+            E( M ) = ZERO
+            GO TO 30
+         END IF
+   20 CONTINUE
+      M = N
+*
+   30 CONTINUE
+      L = L1
+      LSV = L
+      LEND = M
+      LENDSV = LEND
+      L1 = M + 1
+      IF( LEND.EQ.L )
+     $   GO TO 10
+*
+*     Scale submatrix in rows and columns L to LEND
+*
+      ANORM = SLANST( 'M', LEND-L+1, D( L ), E( L ) )
+      ISCALE = 0
+      IF( ANORM.EQ.ZERO )
+     $   GO TO 10
+      IF( ANORM.GT.SSFMAX ) THEN
+         ISCALE = 1
+         CALL SLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L+1, 1, D( L ), N,
+     $                INFO )
+         CALL SLASCL( 'G', 0, 0, ANORM, SSFMAX, LEND-L, 1, E( L ), N,
+     $                INFO )
+      ELSE IF( ANORM.LT.SSFMIN ) THEN
+         ISCALE = 2
+         CALL SLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L+1, 1, D( L ), N,
+     $                INFO )
+         CALL SLASCL( 'G', 0, 0, ANORM, SSFMIN, LEND-L, 1, E( L ), N,
+     $                INFO )
+      END IF
+*
+      DO 40 I = L, LEND - 1
+         E( I ) = E( I )**2
+   40 CONTINUE
+*
+*     Choose between QL and QR iteration
+*
+      IF( ABS( D( LEND ) ).LT.ABS( D( L ) ) ) THEN
+         LEND = LSV
+         L = LENDSV
+      END IF
+*
+      IF( LEND.GE.L ) THEN
+*
+*        QL Iteration
+*
+*        Look for small subdiagonal element.
+*
+   50    CONTINUE
+         IF( L.NE.LEND ) THEN
+            DO 60 M = L, LEND - 1
+               IF( ABS( E( M ) ).LE.EPS2*ABS( D( M )*D( M+1 ) ) )
+     $            GO TO 70
+   60       CONTINUE
+         END IF
+         M = LEND
+*
+   70    CONTINUE
+         IF( M.LT.LEND )
+     $      E( M ) = ZERO
+         P = D( L )
+         IF( M.EQ.L )
+     $      GO TO 90
+*
+*        If remaining matrix is 2 by 2, use SLAE2 to compute its
+*        eigenvalues.
+*
+         IF( M.EQ.L+1 ) THEN
+            RTE = SQRT( E( L ) )
+            CALL SLAE2( D( L ), RTE, D( L+1 ), RT1, RT2 )
+            D( L ) = RT1
+            D( L+1 ) = RT2
+            E( L ) = ZERO
+            L = L + 2
+            IF( L.LE.LEND )
+     $         GO TO 50
+            GO TO 150
+         END IF
+*
+         IF( JTOT.EQ.NMAXIT )
+     $      GO TO 150
+         JTOT = JTOT + 1
+*
+*        Form shift.
+*
+         RTE = SQRT( E( L ) )
+         SIGMA = ( D( L+1 )-P ) / ( TWO*RTE )
+         R = SLAPY2( SIGMA, ONE )
+         SIGMA = P - ( RTE / ( SIGMA+SIGN( R, SIGMA ) ) )
+*
+         C = ONE
+         S = ZERO
+         GAMMA = D( M ) - SIGMA
+         P = GAMMA*GAMMA
+*
+*        Inner loop
+*
+         DO 80 I = M - 1, L, -1
+            BB = E( I )
+            R = P + BB
+            IF( I.NE.M-1 )
+     $         E( I+1 ) = S*R
+            OLDC = C
+            C = P / R
+            S = BB / R
+            OLDGAM = GAMMA
+            ALPHA = D( I )
+            GAMMA = C*( ALPHA-SIGMA ) - S*OLDGAM
+            D( I+1 ) = OLDGAM + ( ALPHA-GAMMA )
+            IF( C.NE.ZERO ) THEN
+               P = ( GAMMA*GAMMA ) / C
+            ELSE
+               P = OLDC*BB
+            END IF
+   80    CONTINUE
+*
+         E( L ) = S*P
+         D( L ) = SIGMA + GAMMA
+         GO TO 50
+*
+*        Eigenvalue found.
+*
+   90    CONTINUE
+         D( L ) = P
+*
+         L = L + 1
+         IF( L.LE.LEND )
+     $      GO TO 50
+         GO TO 150
+*
+      ELSE
+*
+*        QR Iteration
+*
+*        Look for small superdiagonal element.
+*
+  100    CONTINUE
+         DO 110 M = L, LEND + 1, -1
+            IF( ABS( E( M-1 ) ).LE.EPS2*ABS( D( M )*D( M-1 ) ) )
+     $         GO TO 120
+  110    CONTINUE
+         M = LEND
+*
+  120    CONTINUE
+         IF( M.GT.LEND )
+     $      E( M-1 ) = ZERO
+         P = D( L )
+         IF( M.EQ.L )
+     $      GO TO 140
+*
+*        If remaining matrix is 2 by 2, use SLAE2 to compute its
+*        eigenvalues.
+*
+         IF( M.EQ.L-1 ) THEN
+            RTE = SQRT( E( L-1 ) )
+            CALL SLAE2( D( L ), RTE, D( L-1 ), RT1, RT2 )
+            D( L ) = RT1
+            D( L-1 ) = RT2
+            E( L-1 ) = ZERO
+            L = L - 2
+            IF( L.GE.LEND )
+     $         GO TO 100
+            GO TO 150
+         END IF
+*
+         IF( JTOT.EQ.NMAXIT )
+     $      GO TO 150
+         JTOT = JTOT + 1
+*
+*        Form shift.
+*
+         RTE = SQRT( E( L-1 ) )
+         SIGMA = ( D( L-1 )-P ) / ( TWO*RTE )
+         R = SLAPY2( SIGMA, ONE )
+         SIGMA = P - ( RTE / ( SIGMA+SIGN( R, SIGMA ) ) )
+*
+         C = ONE
+         S = ZERO
+         GAMMA = D( M ) - SIGMA
+         P = GAMMA*GAMMA
+*
+*        Inner loop
+*
+         DO 130 I = M, L - 1
+            BB = E( I )
+            R = P + BB
+            IF( I.NE.M )
+     $         E( I-1 ) = S*R
+            OLDC = C
+            C = P / R
+            S = BB / R
+            OLDGAM = GAMMA
+            ALPHA = D( I+1 )
+            GAMMA = C*( ALPHA-SIGMA ) - S*OLDGAM
+            D( I ) = OLDGAM + ( ALPHA-GAMMA )
+            IF( C.NE.ZERO ) THEN
+               P = ( GAMMA*GAMMA ) / C
+            ELSE
+               P = OLDC*BB
+            END IF
+  130    CONTINUE
+*
+         E( L-1 ) = S*P
+         D( L ) = SIGMA + GAMMA
+         GO TO 100
+*
+*        Eigenvalue found.
+*
+  140    CONTINUE
+         D( L ) = P
+*
+         L = L - 1
+         IF( L.GE.LEND )
+     $      GO TO 100
+         GO TO 150
+*
+      END IF
+*
+*     Undo scaling if necessary
+*
+  150 CONTINUE
+      IF( ISCALE.EQ.1 )
+     $   CALL SLASCL( 'G', 0, 0, SSFMAX, ANORM, LENDSV-LSV+1, 1,
+     $                D( LSV ), N, INFO )
+      IF( ISCALE.EQ.2 )
+     $   CALL SLASCL( 'G', 0, 0, SSFMIN, ANORM, LENDSV-LSV+1, 1,
+     $                D( LSV ), N, INFO )
+*
+*     Check for no convergence to an eigenvalue after a total
+*     of N*MAXIT iterations.
+*
+      IF( JTOT.LT.NMAXIT )
+     $   GO TO 10
+      DO 160 I = 1, N - 1
+         IF( E( I ).NE.ZERO )
+     $      INFO = INFO + 1
+  160 CONTINUE
+      GO TO 180
+*
+*     Sort eigenvalues in increasing order.
+*
+  170 CONTINUE
+      CALL SLASRT( 'I', N, D, INFO )
+*
+  180 CONTINUE
+      RETURN
+*
+*     End of SSTERF
+*
+      END
diff -uN AmberTools/src/quick/src/blas/ssytd2.f AmberTools/src/quick/src/blas/ssytd2.f
--- AmberTools/src/quick/src/blas/ssytd2.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/ssytd2.f	2022-08-30 19:21:27.000000000 +0900
@@ -0,0 +1,322 @@
+*> \brief \b SSYTD2 reduces a symmetric matrix to real symmetric tridiagonal form by an orthogonal similarity transformation (unblocked algorithm).
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SSYTD2 + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ssytd2.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ssytd2.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssytd2.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SSYTD2( UPLO, N, A, LDA, D, E, TAU, INFO )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          UPLO
+*       INTEGER            INFO, LDA, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), D( * ), E( * ), TAU( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal
+*> form T by an orthogonal similarity transformation: Q**T * A * Q = T.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] UPLO
+*> \verbatim
+*>          UPLO is CHARACTER*1
+*>          Specifies whether the upper or lower triangular part of the
+*>          symmetric matrix A is stored:
+*>          = 'U':  Upper triangular
+*>          = 'L':  Lower triangular
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the matrix A.  N >= 0.
+*> \endverbatim
+*>
+*> \param[in,out] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
+*>          n-by-n upper triangular part of A contains the upper
+*>          triangular part of the matrix A, and the strictly lower
+*>          triangular part of A is not referenced.  If UPLO = 'L', the
+*>          leading n-by-n lower triangular part of A contains the lower
+*>          triangular part of the matrix A, and the strictly upper
+*>          triangular part of A is not referenced.
+*>          On exit, if UPLO = 'U', the diagonal and first superdiagonal
+*>          of A are overwritten by the corresponding elements of the
+*>          tridiagonal matrix T, and the elements above the first
+*>          superdiagonal, with the array TAU, represent the orthogonal
+*>          matrix Q as a product of elementary reflectors; if UPLO
+*>          = 'L', the diagonal and first subdiagonal of A are over-
+*>          written by the corresponding elements of the tridiagonal
+*>          matrix T, and the elements below the first subdiagonal, with
+*>          the array TAU, represent the orthogonal matrix Q as a product
+*>          of elementary reflectors. See Further Details.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A.  LDA >= max(1,N).
+*> \endverbatim
+*>
+*> \param[out] D
+*> \verbatim
+*>          D is REAL array, dimension (N)
+*>          The diagonal elements of the tridiagonal matrix T:
+*>          D(i) = A(i,i).
+*> \endverbatim
+*>
+*> \param[out] E
+*> \verbatim
+*>          E is REAL array, dimension (N-1)
+*>          The off-diagonal elements of the tridiagonal matrix T:
+*>          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
+*> \endverbatim
+*>
+*> \param[out] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension (N-1)
+*>          The scalar factors of the elementary reflectors (see Further
+*>          Details).
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument had an illegal value.
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realSYcomputational
+*
+*> \par Further Details:
+*  =====================
+*>
+*> \verbatim
+*>
+*>  If UPLO = 'U', the matrix Q is represented as a product of elementary
+*>  reflectors
+*>
+*>     Q = H(n-1) . . . H(2) H(1).
+*>
+*>  Each H(i) has the form
+*>
+*>     H(i) = I - tau * v * v**T
+*>
+*>  where tau is a real scalar, and v is a real vector with
+*>  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
+*>  A(1:i-1,i+1), and tau in TAU(i).
+*>
+*>  If UPLO = 'L', the matrix Q is represented as a product of elementary
+*>  reflectors
+*>
+*>     Q = H(1) H(2) . . . H(n-1).
+*>
+*>  Each H(i) has the form
+*>
+*>     H(i) = I - tau * v * v**T
+*>
+*>  where tau is a real scalar, and v is a real vector with
+*>  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
+*>  and tau in TAU(i).
+*>
+*>  The contents of A on exit are illustrated by the following examples
+*>  with n = 5:
+*>
+*>  if UPLO = 'U':                       if UPLO = 'L':
+*>
+*>    (  d   e   v2  v3  v4 )              (  d                  )
+*>    (      d   e   v3  v4 )              (  e   d              )
+*>    (          d   e   v4 )              (  v1  e   d          )
+*>    (              d   e  )              (  v1  v2  e   d      )
+*>    (                  d  )              (  v1  v2  v3  e   d  )
+*>
+*>  where d and e denote diagonal and off-diagonal elements of T, and vi
+*>  denotes an element of the vector defining H(i).
+*> \endverbatim
+*>
+*  =====================================================================
+      SUBROUTINE SSYTD2( UPLO, N, A, LDA, D, E, TAU, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          UPLO
+      INTEGER            INFO, LDA, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), D( * ), E( * ), TAU( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE, ZERO, HALF
+      PARAMETER          ( ONE = 1.0, ZERO = 0.0, HALF = 1.0 / 2.0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            UPPER
+      INTEGER            I
+      REAL               ALPHA, TAUI
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SAXPY, SLARFG, SSYMV, SSYR2, XERBLA
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      REAL               SDOT
+      EXTERNAL           LSAME, SDOT
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX, MIN
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters
+*
+      INFO = 0
+      UPPER = LSAME( UPLO, 'U' )
+      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -2
+      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
+         INFO = -4
+      END IF
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SSYTD2', -INFO )
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.LE.0 )
+     $   RETURN
+*
+      IF( UPPER ) THEN
+*
+*        Reduce the upper triangle of A
+*
+         DO 10 I = N - 1, 1, -1
+*
+*           Generate elementary reflector H(i) = I - tau * v * v**T
+*           to annihilate A(1:i-1,i+1)
+*
+            CALL SLARFG( I, A( I, I+1 ), A( 1, I+1 ), 1, TAUI )
+            E( I ) = A( I, I+1 )
+*
+            IF( TAUI.NE.ZERO ) THEN
+*
+*              Apply H(i) from both sides to A(1:i,1:i)
+*
+               A( I, I+1 ) = ONE
+*
+*              Compute  x := tau * A * v  storing x in TAU(1:i)
+*
+               CALL SSYMV( UPLO, I, TAUI, A, LDA, A( 1, I+1 ), 1, ZERO,
+     $                     TAU, 1 )
+*
+*              Compute  w := x - 1/2 * tau * (x**T * v) * v
+*
+               ALPHA = -HALF*TAUI*SDOT( I, TAU, 1, A( 1, I+1 ), 1 )
+               CALL SAXPY( I, ALPHA, A( 1, I+1 ), 1, TAU, 1 )
+*
+*              Apply the transformation as a rank-2 update:
+*                 A := A - v * w**T - w * v**T
+*
+               CALL SSYR2( UPLO, I, -ONE, A( 1, I+1 ), 1, TAU, 1, A,
+     $                     LDA )
+*
+               A( I, I+1 ) = E( I )
+            END IF
+            D( I+1 ) = A( I+1, I+1 )
+            TAU( I ) = TAUI
+   10    CONTINUE
+         D( 1 ) = A( 1, 1 )
+      ELSE
+*
+*        Reduce the lower triangle of A
+*
+         DO 20 I = 1, N - 1
+*
+*           Generate elementary reflector H(i) = I - tau * v * v**T
+*           to annihilate A(i+2:n,i)
+*
+            CALL SLARFG( N-I, A( I+1, I ), A( MIN( I+2, N ), I ), 1,
+     $                   TAUI )
+            E( I ) = A( I+1, I )
+*
+            IF( TAUI.NE.ZERO ) THEN
+*
+*              Apply H(i) from both sides to A(i+1:n,i+1:n)
+*
+               A( I+1, I ) = ONE
+*
+*              Compute  x := tau * A * v  storing y in TAU(i:n-1)
+*
+               CALL SSYMV( UPLO, N-I, TAUI, A( I+1, I+1 ), LDA,
+     $                     A( I+1, I ), 1, ZERO, TAU( I ), 1 )
+*
+*              Compute  w := x - 1/2 * tau * (x**T * v) * v
+*
+               ALPHA = -HALF*TAUI*SDOT( N-I, TAU( I ), 1, A( I+1, I ),
+     $                 1 )
+               CALL SAXPY( N-I, ALPHA, A( I+1, I ), 1, TAU( I ), 1 )
+*
+*              Apply the transformation as a rank-2 update:
+*                 A := A - v * w**T - w * v**T
+*
+               CALL SSYR2( UPLO, N-I, -ONE, A( I+1, I ), 1, TAU( I ), 1,
+     $                     A( I+1, I+1 ), LDA )
+*
+               A( I+1, I ) = E( I )
+            END IF
+            D( I ) = A( I, I )
+            TAU( I ) = TAUI
+   20    CONTINUE
+         D( N ) = A( N, N )
+      END IF
+*
+      RETURN
+*
+*     End of SSYTD2
+*
+      END
diff -uN AmberTools/src/quick/src/blas/ssytrd.f AmberTools/src/quick/src/blas/ssytrd.f
--- AmberTools/src/quick/src/blas/ssytrd.f	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/ssytrd.f	2022-08-30 19:15:26.000000000 +0900
@@ -0,0 +1,376 @@
+*> \brief \b SSYTRD
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SSYTRD + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ssytrd.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ssytrd.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssytrd.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SSYTRD( UPLO, N, A, LDA, D, E, TAU, WORK, LWORK, INFO )
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          UPLO
+*       INTEGER            INFO, LDA, LWORK, N
+*       ..
+*       .. Array Arguments ..
+*       REAL               A( LDA, * ), D( * ), E( * ), TAU( * ),
+*      $                   WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SSYTRD reduces a real symmetric matrix A to real symmetric
+*> tridiagonal form T by an orthogonal similarity transformation:
+*> Q**T * A * Q = T.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] UPLO
+*> \verbatim
+*>          UPLO is CHARACTER*1
+*>          = 'U':  Upper triangle of A is stored;
+*>          = 'L':  Lower triangle of A is stored.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the matrix A.  N >= 0.
+*> \endverbatim
+*>
+*> \param[in,out] A
+*> \verbatim
+*>          A is REAL array, dimension (LDA,N)
+*>          On entry, the symmetric matrix A.  If UPLO = 'U', the leading
+*>          N-by-N upper triangular part of A contains the upper
+*>          triangular part of the matrix A, and the strictly lower
+*>          triangular part of A is not referenced.  If UPLO = 'L', the
+*>          leading N-by-N lower triangular part of A contains the lower
+*>          triangular part of the matrix A, and the strictly upper
+*>          triangular part of A is not referenced.
+*>          On exit, if UPLO = 'U', the diagonal and first superdiagonal
+*>          of A are overwritten by the corresponding elements of the
+*>          tridiagonal matrix T, and the elements above the first
+*>          superdiagonal, with the array TAU, represent the orthogonal
+*>          matrix Q as a product of elementary reflectors; if UPLO
+*>          = 'L', the diagonal and first subdiagonal of A are over-
+*>          written by the corresponding elements of the tridiagonal
+*>          matrix T, and the elements below the first subdiagonal, with
+*>          the array TAU, represent the orthogonal matrix Q as a product
+*>          of elementary reflectors. See Further Details.
+*> \endverbatim
+*>
+*> \param[in] LDA
+*> \verbatim
+*>          LDA is INTEGER
+*>          The leading dimension of the array A.  LDA >= max(1,N).
+*> \endverbatim
+*>
+*> \param[out] D
+*> \verbatim
+*>          D is REAL array, dimension (N)
+*>          The diagonal elements of the tridiagonal matrix T:
+*>          D(i) = A(i,i).
+*> \endverbatim
+*>
+*> \param[out] E
+*> \verbatim
+*>          E is REAL array, dimension (N-1)
+*>          The off-diagonal elements of the tridiagonal matrix T:
+*>          E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
+*> \endverbatim
+*>
+*> \param[out] TAU
+*> \verbatim
+*>          TAU is REAL array, dimension (N-1)
+*>          The scalar factors of the elementary reflectors (see Further
+*>          Details).
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension (MAX(1,LWORK))
+*>          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
+*> \endverbatim
+*>
+*> \param[in] LWORK
+*> \verbatim
+*>          LWORK is INTEGER
+*>          The dimension of the array WORK.  LWORK >= 1.
+*>          For optimum performance LWORK >= N*NB, where NB is the
+*>          optimal blocksize.
+*>
+*>          If LWORK = -1, then a workspace query is assumed; the routine
+*>          only calculates the optimal size of the WORK array, returns
+*>          this value as the first entry of the WORK array, and no error
+*>          message related to LWORK is issued by XERBLA.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument had an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date December 2016
+*
+*> \ingroup realSYcomputational
+*
+*> \par Further Details:
+*  =====================
+*>
+*> \verbatim
+*>
+*>  If UPLO = 'U', the matrix Q is represented as a product of elementary
+*>  reflectors
+*>
+*>     Q = H(n-1) . . . H(2) H(1).
+*>
+*>  Each H(i) has the form
+*>
+*>     H(i) = I - tau * v * v**T
+*>
+*>  where tau is a real scalar, and v is a real vector with
+*>  v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
+*>  A(1:i-1,i+1), and tau in TAU(i).
+*>
+*>  If UPLO = 'L', the matrix Q is represented as a product of elementary
+*>  reflectors
+*>
+*>     Q = H(1) H(2) . . . H(n-1).
+*>
+*>  Each H(i) has the form
+*>
+*>     H(i) = I - tau * v * v**T
+*>
+*>  where tau is a real scalar, and v is a real vector with
+*>  v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
+*>  and tau in TAU(i).
+*>
+*>  The contents of A on exit are illustrated by the following examples
+*>  with n = 5:
+*>
+*>  if UPLO = 'U':                       if UPLO = 'L':
+*>
+*>    (  d   e   v2  v3  v4 )              (  d                  )
+*>    (      d   e   v3  v4 )              (  e   d              )
+*>    (          d   e   v4 )              (  v1  e   d          )
+*>    (              d   e  )              (  v1  v2  e   d      )
+*>    (                  d  )              (  v1  v2  v3  e   d  )
+*>
+*>  where d and e denote diagonal and off-diagonal elements of T, and vi
+*>  denotes an element of the vector defining H(i).
+*> \endverbatim
+*>
+*  =====================================================================
+      SUBROUTINE SSYTRD( UPLO, N, A, LDA, D, E, TAU, WORK, LWORK, INFO )
+*
+*  -- LAPACK computational routine (version 3.7.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     December 2016
+*
+*     .. Scalar Arguments ..
+      CHARACTER          UPLO
+      INTEGER            INFO, LDA, LWORK, N
+*     ..
+*     .. Array Arguments ..
+      REAL               A( LDA, * ), D( * ), E( * ), TAU( * ),
+     $                   WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               ONE
+      PARAMETER          ( ONE = 1.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            LQUERY, UPPER
+      INTEGER            I, IINFO, IWS, J, KK, LDWORK, LWKOPT, NB,
+     $                   NBMIN, NX
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SLATRD, SSYR2K, SSYTD2, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MAX
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      INTEGER            ILAENV
+      EXTERNAL           LSAME, ILAENV
+*     ..
+*     .. Executable Statements ..
+*
+*     Test the input parameters
+*
+      INFO = 0
+      UPPER = LSAME( UPLO, 'U' )
+      LQUERY = ( LWORK.EQ.-1 )
+      IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -1
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -2
+      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
+         INFO = -4
+      ELSE IF( LWORK.LT.1 .AND. .NOT.LQUERY ) THEN
+         INFO = -9
+      END IF
+*
+      IF( INFO.EQ.0 ) THEN
+*
+*        Determine the block size.
+*
+         NB = ILAENV( 1, 'SSYTRD', UPLO, N, -1, -1, -1 )
+         LWKOPT = N*NB
+         WORK( 1 ) = LWKOPT
+      END IF
+*
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SSYTRD', -INFO )
+         RETURN
+      ELSE IF( LQUERY ) THEN
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 ) THEN
+         WORK( 1 ) = 1
+         RETURN
+      END IF
+*
+      NX = N
+      IWS = 1
+      IF( NB.GT.1 .AND. NB.LT.N ) THEN
+*
+*        Determine when to cross over from blocked to unblocked code
+*        (last block is always handled by unblocked code).
+*
+         NX = MAX( NB, ILAENV( 3, 'SSYTRD', UPLO, N, -1, -1, -1 ) )
+         IF( NX.LT.N ) THEN
+*
+*           Determine if workspace is large enough for blocked code.
+*
+            LDWORK = N
+            IWS = LDWORK*NB
+            IF( LWORK.LT.IWS ) THEN
+*
+*              Not enough workspace to use optimal NB:  determine the
+*              minimum value of NB, and reduce NB or force use of
+*              unblocked code by setting NX = N.
+*
+               NB = MAX( LWORK / LDWORK, 1 )
+               NBMIN = ILAENV( 2, 'SSYTRD', UPLO, N, -1, -1, -1 )
+               IF( NB.LT.NBMIN )
+     $            NX = N
+            END IF
+         ELSE
+            NX = N
+         END IF
+      ELSE
+         NB = 1
+      END IF
+*
+      IF( UPPER ) THEN
+*
+*        Reduce the upper triangle of A.
+*        Columns 1:kk are handled by the unblocked method.
+*
+         KK = N - ( ( N-NX+NB-1 ) / NB )*NB
+         DO 20 I = N - NB + 1, KK + 1, -NB
+*
+*           Reduce columns i:i+nb-1 to tridiagonal form and form the
+*           matrix W which is needed to update the unreduced part of
+*           the matrix
+*
+            CALL SLATRD( UPLO, I+NB-1, NB, A, LDA, E, TAU, WORK,
+     $                   LDWORK )
+*
+*           Update the unreduced submatrix A(1:i-1,1:i-1), using an
+*           update of the form:  A := A - V*W**T - W*V**T
+*
+            CALL SSYR2K( UPLO, 'No transpose', I-1, NB, -ONE, A( 1, I ),
+     $                   LDA, WORK, LDWORK, ONE, A, LDA )
+*
+*           Copy superdiagonal elements back into A, and diagonal
+*           elements into D
+*
+            DO 10 J = I, I + NB - 1
+               A( J-1, J ) = E( J-1 )
+               D( J ) = A( J, J )
+   10       CONTINUE
+   20    CONTINUE
+*
+*        Use unblocked code to reduce the last or only block
+*
+         CALL SSYTD2( UPLO, KK, A, LDA, D, E, TAU, IINFO )
+      ELSE
+*
+*        Reduce the lower triangle of A
+*
+         DO 40 I = 1, N - NX, NB
+*
+*           Reduce columns i:i+nb-1 to tridiagonal form and form the
+*           matrix W which is needed to update the unreduced part of
+*           the matrix
+*
+            CALL SLATRD( UPLO, N-I+1, NB, A( I, I ), LDA, E( I ),
+     $                   TAU( I ), WORK, LDWORK )
+*
+*           Update the unreduced submatrix A(i+ib:n,i+ib:n), using
+*           an update of the form:  A := A - V*W**T - W*V**T
+*
+            CALL SSYR2K( UPLO, 'No transpose', N-I-NB+1, NB, -ONE,
+     $                   A( I+NB, I ), LDA, WORK( NB+1 ), LDWORK, ONE,
+     $                   A( I+NB, I+NB ), LDA )
+*
+*           Copy subdiagonal elements back into A, and diagonal
+*           elements into D
+*
+            DO 30 J = I, I + NB - 1
+               A( J+1, J ) = E( J )
+               D( J ) = A( J, J )
+   30       CONTINUE
+   40    CONTINUE
+*
+*        Use unblocked code to reduce the last or only block
+*
+         CALL SSYTD2( UPLO, N-I+1, A( I, I ), LDA, D( I ), E( I ),
+     $                TAU( I ), IINFO )
+      END IF
+*
+      WORK( 1 ) = LWKOPT
+      RETURN
+*
+*     End of SSYTRD
+*
+      END
diff -uN AmberTools/src/quick/src/blas/ssytrd_sb2st.F AmberTools/src/quick/src/blas/ssytrd_sb2st.F
--- AmberTools/src/quick/src/blas/ssytrd_sb2st.F	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/ssytrd_sb2st.F	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,556 @@
+*> \brief \b SSYTRD_SB2ST reduces a real symmetric band matrix A to real symmetric tridiagonal form T
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download SSYTRD_SB2ST + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/ssytrd_sb2t.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/ssytrd_sb2t.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/ssytrd_sb2t.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE SSYTRD_SB2ST( STAGE1, VECT, UPLO, N, KD, AB, LDAB, 
+*                               D, E, HOUS, LHOUS, WORK, LWORK, INFO )
+*
+*       #if defined(_OPENMP)
+*       use omp_lib
+*       #endif
+*
+*       IMPLICIT NONE
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          STAGE1, UPLO, VECT
+*       INTEGER            N, KD, IB, LDAB, LHOUS, LWORK, INFO
+*       ..
+*       .. Array Arguments ..
+*       REAL               D( * ), E( * )
+*       REAL               AB( LDAB, * ), HOUS( * ), WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> SSYTRD_SB2ST reduces a real symmetric band matrix A to real symmetric
+*> tridiagonal form T by a orthogonal similarity transformation:
+*> Q**T * A * Q = T.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] STAGE1
+*> \verbatim
+*>          STAGE1 is CHARACTER*1
+*>          = 'N':  "No": to mention that the stage 1 of the reduction  
+*>                  from dense to band using the ssytrd_sy2sb routine
+*>                  was not called before this routine to reproduce AB. 
+*>                  In other term this routine is called as standalone. 
+*>          = 'Y':  "Yes": to mention that the stage 1 of the 
+*>                  reduction from dense to band using the ssytrd_sy2sb 
+*>                  routine has been called to produce AB (e.g., AB is
+*>                  the output of ssytrd_sy2sb.
+*> \endverbatim
+*>
+*> \param[in] VECT
+*> \verbatim
+*>          VECT is CHARACTER*1
+*>          = 'N':  No need for the Housholder representation, 
+*>                  and thus LHOUS is of size max(1, 4*N);
+*>          = 'V':  the Householder representation is needed to 
+*>                  either generate or to apply Q later on, 
+*>                  then LHOUS is to be queried and computed.
+*>                  (NOT AVAILABLE IN THIS RELEASE).
+*> \endverbatim
+*>
+*> \param[in] UPLO
+*> \verbatim
+*>          UPLO is CHARACTER*1
+*>          = 'U':  Upper triangle of A is stored;
+*>          = 'L':  Lower triangle of A is stored.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the matrix A.  N >= 0.
+*> \endverbatim
+*>
+*> \param[in] KD
+*> \verbatim
+*>          KD is INTEGER
+*>          The number of superdiagonals of the matrix A if UPLO = 'U',
+*>          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
+*> \endverbatim
+*>
+*> \param[in,out] AB
+*> \verbatim
+*>          AB is REAL array, dimension (LDAB,N)
+*>          On entry, the upper or lower triangle of the symmetric band
+*>          matrix A, stored in the first KD+1 rows of the array.  The
+*>          j-th column of A is stored in the j-th column of the array AB
+*>          as follows:
+*>          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
+*>          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
+*>          On exit, the diagonal elements of AB are overwritten by the
+*>          diagonal elements of the tridiagonal matrix T; if KD > 0, the
+*>          elements on the first superdiagonal (if UPLO = 'U') or the
+*>          first subdiagonal (if UPLO = 'L') are overwritten by the
+*>          off-diagonal elements of T; the rest of AB is overwritten by
+*>          values generated during the reduction.
+*> \endverbatim
+*>
+*> \param[in] LDAB
+*> \verbatim
+*>          LDAB is INTEGER
+*>          The leading dimension of the array AB.  LDAB >= KD+1.
+*> \endverbatim
+*>
+*> \param[out] D
+*> \verbatim
+*>          D is REAL array, dimension (N)
+*>          The diagonal elements of the tridiagonal matrix T.
+*> \endverbatim
+*>
+*> \param[out] E
+*> \verbatim
+*>          E is REAL array, dimension (N-1)
+*>          The off-diagonal elements of the tridiagonal matrix T:
+*>          E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'.
+*> \endverbatim
+*>
+*> \param[out] HOUS
+*> \verbatim
+*>          HOUS is REAL array, dimension LHOUS, that
+*>          store the Householder representation.
+*> \endverbatim
+*>
+*> \param[in] LHOUS
+*> \verbatim
+*>          LHOUS is INTEGER
+*>          The dimension of the array HOUS. LHOUS = MAX(1, dimension)
+*>          If LWORK = -1, or LHOUS=-1,
+*>          then a query is assumed; the routine
+*>          only calculates the optimal size of the HOUS array, returns
+*>          this value as the first entry of the HOUS array, and no error
+*>          message related to LHOUS is issued by XERBLA.
+*>          LHOUS = MAX(1, dimension) where
+*>          dimension = 4*N if VECT='N'
+*>          not available now if VECT='H'     
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is REAL array, dimension LWORK.
+*> \endverbatim
+*>
+*> \param[in] LWORK
+*> \verbatim
+*>          LWORK is INTEGER
+*>          The dimension of the array WORK. LWORK = MAX(1, dimension)
+*>          If LWORK = -1, or LHOUS=-1,
+*>          then a workspace query is assumed; the routine
+*>          only calculates the optimal size of the WORK array, returns
+*>          this value as the first entry of the WORK array, and no error
+*>          message related to LWORK is issued by XERBLA.
+*>          LWORK = MAX(1, dimension) where
+*>          dimension   = (2KD+1)*N + KD*NTHREADS
+*>          where KD is the blocking size of the reduction,
+*>          FACTOPTNB is the blocking used by the QR or LQ
+*>          algorithm, usually FACTOPTNB=128 is a good choice
+*>          NTHREADS is the number of threads used when
+*>          openMP compilation is enabled, otherwise =1.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument had an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date November 2017
+*
+*> \ingroup real16OTHERcomputational
+*
+*> \par Further Details:
+*  =====================
+*>
+*> \verbatim
+*>
+*>  Implemented by Azzam Haidar.
+*>
+*>  All details are available on technical report, SC11, SC13 papers.
+*>
+*>  Azzam Haidar, Hatem Ltaief, and Jack Dongarra.
+*>  Parallel reduction to condensed forms for symmetric eigenvalue problems
+*>  using aggregated fine-grained and memory-aware kernels. In Proceedings
+*>  of 2011 International Conference for High Performance Computing,
+*>  Networking, Storage and Analysis (SC '11), New York, NY, USA,
+*>  Article 8 , 11 pages.
+*>  http://doi.acm.org/10.1145/2063384.2063394
+*>
+*>  A. Haidar, J. Kurzak, P. Luszczek, 2013.
+*>  An improved parallel singular value algorithm and its implementation 
+*>  for multicore hardware, In Proceedings of 2013 International Conference
+*>  for High Performance Computing, Networking, Storage and Analysis (SC '13).
+*>  Denver, Colorado, USA, 2013.
+*>  Article 90, 12 pages.
+*>  http://doi.acm.org/10.1145/2503210.2503292
+*>
+*>  A. Haidar, R. Solca, S. Tomov, T. Schulthess and J. Dongarra.
+*>  A novel hybrid CPU-GPU generalized eigensolver for electronic structure 
+*>  calculations based on fine-grained memory aware tasks.
+*>  International Journal of High Performance Computing Applications.
+*>  Volume 28 Issue 2, Pages 196-209, May 2014.
+*>  http://hpc.sagepub.com/content/28/2/196 
+*>
+*> \endverbatim
+*>
+*  =====================================================================
+      SUBROUTINE SSYTRD_SB2ST( STAGE1, VECT, UPLO, N, KD, AB, LDAB, 
+     $                         D, E, HOUS, LHOUS, WORK, LWORK, INFO )
+*
+#if defined(_OPENMP)
+      use omp_lib
+#endif
+*
+      IMPLICIT NONE
+*
+*  -- LAPACK computational routine (version 3.8.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     November 2017
+*
+*     .. Scalar Arguments ..
+      CHARACTER          STAGE1, UPLO, VECT
+      INTEGER            N, KD, LDAB, LHOUS, LWORK, INFO
+*     ..
+*     .. Array Arguments ..
+      REAL               D( * ), E( * )
+      REAL               AB( LDAB, * ), HOUS( * ), WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      REAL               RZERO
+      REAL               ZERO, ONE
+      PARAMETER          ( RZERO = 0.0E+0,
+     $                   ZERO = 0.0E+0,
+     $                   ONE  = 1.0E+0 )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            LQUERY, WANTQ, UPPER, AFTERS1
+      INTEGER            I, M, K, IB, SWEEPID, MYID, SHIFT, STT, ST, 
+     $                   ED, STIND, EDIND, BLKLASTIND, COLPT, THED,
+     $                   STEPERCOL, GRSIZ, THGRSIZ, THGRNB, THGRID,
+     $                   NBTILES, TTYPE, TID, NTHREADS, DEBUG,
+     $                   ABDPOS, ABOFDPOS, DPOS, OFDPOS, AWPOS, 
+     $                   INDA, INDW, APOS, SIZEA, LDA, INDV, INDTAU,
+     $                   SISEV, SIZETAU, LDV, LHMIN, LWMIN
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           SSB2ST_KERNELS, SLACPY, SLASET, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MIN, MAX, CEILING, REAL
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      INTEGER            ILAENV2STAGE 
+      EXTERNAL           LSAME, ILAENV2STAGE
+*     ..
+*     .. Executable Statements ..
+*
+*     Determine the minimal workspace size required.
+*     Test the input parameters
+*
+      DEBUG   = 0
+      INFO    = 0
+      AFTERS1 = LSAME( STAGE1, 'Y' )
+      WANTQ   = LSAME( VECT, 'V' )
+      UPPER   = LSAME( UPLO, 'U' )
+      LQUERY  = ( LWORK.EQ.-1 ) .OR. ( LHOUS.EQ.-1 )
+*
+*     Determine the block size, the workspace size and the hous size.
+*
+      IB     = ILAENV2STAGE( 2, 'SSYTRD_SB2ST', VECT, N, KD, -1, -1 )
+      LHMIN  = ILAENV2STAGE( 3, 'SSYTRD_SB2ST', VECT, N, KD, IB, -1 )
+      LWMIN  = ILAENV2STAGE( 4, 'SSYTRD_SB2ST', VECT, N, KD, IB, -1 )
+*
+      IF( .NOT.AFTERS1 .AND. .NOT.LSAME( STAGE1, 'N' ) ) THEN
+         INFO = -1
+      ELSE IF( .NOT.LSAME( VECT, 'N' ) ) THEN
+         INFO = -2
+      ELSE IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -3
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -4
+      ELSE IF( KD.LT.0 ) THEN
+         INFO = -5
+      ELSE IF( LDAB.LT.(KD+1) ) THEN
+         INFO = -7
+      ELSE IF( LHOUS.LT.LHMIN .AND. .NOT.LQUERY ) THEN
+         INFO = -11
+      ELSE IF( LWORK.LT.LWMIN .AND. .NOT.LQUERY ) THEN
+         INFO = -13
+      END IF
+*
+      IF( INFO.EQ.0 ) THEN
+         HOUS( 1 ) = LHMIN
+         WORK( 1 ) = LWMIN
+      END IF
+*
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'SSYTRD_SB2ST', -INFO )
+         RETURN
+      ELSE IF( LQUERY ) THEN
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 ) THEN
+          HOUS( 1 ) = 1
+          WORK( 1 ) = 1
+          RETURN
+      END IF
+*
+*     Determine pointer position
+*
+      LDV      = KD + IB
+      SIZETAU  = 2 * N
+      SISEV    = 2 * N
+      INDTAU   = 1
+      INDV     = INDTAU + SIZETAU
+      LDA      = 2 * KD + 1
+      SIZEA    = LDA * N
+      INDA     = 1
+      INDW     = INDA + SIZEA
+      NTHREADS = 1
+      TID      = 0
+*
+      IF( UPPER ) THEN
+          APOS     = INDA + KD
+          AWPOS    = INDA
+          DPOS     = APOS + KD
+          OFDPOS   = DPOS - 1
+          ABDPOS   = KD + 1
+          ABOFDPOS = KD
+      ELSE
+          APOS     = INDA 
+          AWPOS    = INDA + KD + 1
+          DPOS     = APOS
+          OFDPOS   = DPOS + 1
+          ABDPOS   = 1
+          ABOFDPOS = 2
+
+      ENDIF
+*      
+*     Case KD=0: 
+*     The matrix is diagonal. We just copy it (convert to "real" for 
+*     real because D is double and the imaginary part should be 0) 
+*     and store it in D. A sequential code here is better or 
+*     in a parallel environment it might need two cores for D and E
+*
+      IF( KD.EQ.0 ) THEN
+          DO 30 I = 1, N
+              D( I ) = ( AB( ABDPOS, I ) )
+   30     CONTINUE
+          DO 40 I = 1, N-1
+              E( I ) = RZERO
+   40     CONTINUE
+*
+          HOUS( 1 ) = 1
+          WORK( 1 ) = 1
+          RETURN
+      END IF
+*      
+*     Case KD=1: 
+*     The matrix is already Tridiagonal. We have to make diagonal 
+*     and offdiagonal elements real, and store them in D and E.
+*     For that, for real precision just copy the diag and offdiag 
+*     to D and E while for the COMPLEX case the bulge chasing is  
+*     performed to convert the hermetian tridiagonal to symmetric 
+*     tridiagonal. A simpler coversion formula might be used, but then 
+*     updating the Q matrix will be required and based if Q is generated
+*     or not this might complicate the story. 
+*      
+      IF( KD.EQ.1 ) THEN
+          DO 50 I = 1, N
+              D( I ) = ( AB( ABDPOS, I ) )
+   50     CONTINUE
+*
+          IF( UPPER ) THEN
+              DO 60 I = 1, N-1
+                 E( I ) = ( AB( ABOFDPOS, I+1 ) )
+   60         CONTINUE
+          ELSE
+              DO 70 I = 1, N-1
+                 E( I ) = ( AB( ABOFDPOS, I ) )
+   70         CONTINUE
+          ENDIF
+*
+          HOUS( 1 ) = 1
+          WORK( 1 ) = 1
+          RETURN
+      END IF
+*
+*     Main code start here. 
+*     Reduce the symmetric band of A to a tridiagonal matrix.
+*
+      THGRSIZ   = N
+      GRSIZ     = 1
+      SHIFT     = 3
+      NBTILES   = CEILING( REAL(N)/REAL(KD) )
+      STEPERCOL = CEILING( REAL(SHIFT)/REAL(GRSIZ) )
+      THGRNB    = CEILING( REAL(N-1)/REAL(THGRSIZ) )
+*      
+      CALL SLACPY( "A", KD+1, N, AB, LDAB, WORK( APOS ), LDA )
+      CALL SLASET( "A", KD,   N, ZERO, ZERO, WORK( AWPOS ), LDA )
+*
+*
+*     openMP parallelisation start here
+*
+#if defined(_OPENMP)
+!$OMP PARALLEL PRIVATE( TID, THGRID, BLKLASTIND )
+!$OMP$         PRIVATE( THED, I, M, K, ST, ED, STT, SWEEPID ) 
+!$OMP$         PRIVATE( MYID, TTYPE, COLPT, STIND, EDIND )
+!$OMP$         SHARED ( UPLO, WANTQ, INDV, INDTAU, HOUS, WORK)
+!$OMP$         SHARED ( N, KD, IB, NBTILES, LDA, LDV, INDA )
+!$OMP$         SHARED ( STEPERCOL, THGRNB, THGRSIZ, GRSIZ, SHIFT )
+!$OMP MASTER
+#endif
+*
+*     main bulge chasing loop
+*      
+      DO 100 THGRID = 1, THGRNB
+          STT  = (THGRID-1)*THGRSIZ+1
+          THED = MIN( (STT + THGRSIZ -1), (N-1))
+          DO 110 I = STT, N-1
+              ED = MIN( I, THED )
+              IF( STT.GT.ED ) EXIT
+              DO 120 M = 1, STEPERCOL
+                  ST = STT
+                  DO 130 SWEEPID = ST, ED
+                      DO 140 K = 1, GRSIZ
+                          MYID  = (I-SWEEPID)*(STEPERCOL*GRSIZ) 
+     $                           + (M-1)*GRSIZ + K
+                          IF ( MYID.EQ.1 ) THEN
+                              TTYPE = 1
+                          ELSE
+                              TTYPE = MOD( MYID, 2 ) + 2
+                          ENDIF
+
+                          IF( TTYPE.EQ.2 ) THEN
+                              COLPT      = (MYID/2)*KD + SWEEPID
+                              STIND      = COLPT-KD+1
+                              EDIND      = MIN(COLPT,N)
+                              BLKLASTIND = COLPT
+                          ELSE
+                              COLPT      = ((MYID+1)/2)*KD + SWEEPID
+                              STIND      = COLPT-KD+1
+                              EDIND      = MIN(COLPT,N)
+                              IF( ( STIND.GE.EDIND-1 ).AND.
+     $                            ( EDIND.EQ.N ) ) THEN
+                                  BLKLASTIND = N
+                              ELSE
+                                  BLKLASTIND = 0
+                              ENDIF
+                          ENDIF
+*
+*                         Call the kernel
+*                             
+#if defined(_OPENMP) && _OPENMP >= 201307
+                          IF( TTYPE.NE.1 ) THEN      
+!$OMP TASK DEPEND(in:WORK(MYID+SHIFT-1))
+!$OMP$     DEPEND(in:WORK(MYID-1))
+!$OMP$     DEPEND(out:WORK(MYID))
+                              TID      = OMP_GET_THREAD_NUM()
+                              CALL SSB2ST_KERNELS( UPLO, WANTQ, TTYPE, 
+     $                             STIND, EDIND, SWEEPID, N, KD, IB,
+     $                             WORK ( INDA ), LDA, 
+     $                             HOUS( INDV ), HOUS( INDTAU ), LDV,
+     $                             WORK( INDW + TID*KD ) )
+!$OMP END TASK
+                          ELSE
+!$OMP TASK DEPEND(in:WORK(MYID+SHIFT-1))
+!$OMP$     DEPEND(out:WORK(MYID))
+                              TID      = OMP_GET_THREAD_NUM()
+                              CALL SSB2ST_KERNELS( UPLO, WANTQ, TTYPE, 
+     $                             STIND, EDIND, SWEEPID, N, KD, IB,
+     $                             WORK ( INDA ), LDA, 
+     $                             HOUS( INDV ), HOUS( INDTAU ), LDV,
+     $                             WORK( INDW + TID*KD ) )
+!$OMP END TASK
+                          ENDIF
+#else
+                          CALL SSB2ST_KERNELS( UPLO, WANTQ, TTYPE, 
+     $                         STIND, EDIND, SWEEPID, N, KD, IB,
+     $                         WORK ( INDA ), LDA, 
+     $                         HOUS( INDV ), HOUS( INDTAU ), LDV,
+     $                         WORK( INDW + TID*KD ) )
+#endif 
+                          IF ( BLKLASTIND.GE.(N-1) ) THEN
+                              STT = STT + 1
+                              EXIT
+                          ENDIF
+  140                 CONTINUE
+  130             CONTINUE
+  120         CONTINUE
+  110     CONTINUE
+  100 CONTINUE
+*
+#if defined(_OPENMP)
+!$OMP END MASTER
+!$OMP END PARALLEL
+#endif
+*      
+*     Copy the diagonal from A to D. Note that D is REAL thus only
+*     the Real part is needed, the imaginary part should be zero.
+*
+      DO 150 I = 1, N
+          D( I ) = ( WORK( DPOS+(I-1)*LDA ) )
+  150 CONTINUE
+*      
+*     Copy the off diagonal from A to E. Note that E is REAL thus only
+*     the Real part is needed, the imaginary part should be zero.
+*
+      IF( UPPER ) THEN
+          DO 160 I = 1, N-1
+             E( I ) = ( WORK( OFDPOS+I*LDA ) )
+  160     CONTINUE
+      ELSE
+          DO 170 I = 1, N-1
+             E( I ) = ( WORK( OFDPOS+(I-1)*LDA ) )
+  170     CONTINUE
+      ENDIF
+*
+      HOUS( 1 ) = LHMIN
+      WORK( 1 ) = LWMIN
+      RETURN
+*
+*     End of SSYTRD_SB2ST
+*
+      END
+      
Common subdirectories: AmberTools/src/quick/src/blas/tmp and AmberTools/src/quick/src/blas/tmp
diff -uN AmberTools/src/quick/src/blas/zhetrd_hb2st.F AmberTools/src/quick/src/blas/zhetrd_hb2st.F
--- AmberTools/src/quick/src/blas/zhetrd_hb2st.F	1970-01-01 09:00:00.000000000 +0900
+++ AmberTools/src/quick/src/blas/zhetrd_hb2st.F	2021-07-15 21:52:54.000000000 +0900
@@ -0,0 +1,588 @@
+*> \brief \b ZHETRD_HB2ST reduces a complex Hermitian band matrix A to real symmetric tridiagonal form T
+*
+*  =========== DOCUMENTATION ===========
+*
+* Online html documentation available at
+*            http://www.netlib.org/lapack/explore-html/
+*
+*> \htmlonly
+*> Download ZHETRD_HB2ST + dependencies
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/zhbtrd_hb2st.f">
+*> [TGZ]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/zhbtrd_hb2st.f">
+*> [ZIP]</a>
+*> <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/zhbtrd_hb2st.f">
+*> [TXT]</a>
+*> \endhtmlonly
+*
+*  Definition:
+*  ===========
+*
+*       SUBROUTINE ZHETRD_HB2ST( STAGE1, VECT, UPLO, N, KD, AB, LDAB, 
+*                               D, E, HOUS, LHOUS, WORK, LWORK, INFO )
+*
+*       #if defined(_OPENMP)
+*       use omp_lib
+*       #endif
+*
+*       IMPLICIT NONE
+*
+*       .. Scalar Arguments ..
+*       CHARACTER          STAGE1, UPLO, VECT
+*       INTEGER            N, KD, IB, LDAB, LHOUS, LWORK, INFO
+*       ..
+*       .. Array Arguments ..
+*       DOUBLE PRECISION   D( * ), E( * )
+*       COMPLEX*16         AB( LDAB, * ), HOUS( * ), WORK( * )
+*       ..
+*
+*
+*> \par Purpose:
+*  =============
+*>
+*> \verbatim
+*>
+*> ZHETRD_HB2ST reduces a complex Hermitian band matrix A to real symmetric
+*> tridiagonal form T by a unitary similarity transformation:
+*> Q**H * A * Q = T.
+*> \endverbatim
+*
+*  Arguments:
+*  ==========
+*
+*> \param[in] STAGE1
+*> \verbatim
+*>          STAGE1 is CHARACTER*1
+*>          = 'N':  "No": to mention that the stage 1 of the reduction  
+*>                  from dense to band using the zhetrd_he2hb routine
+*>                  was not called before this routine to reproduce AB. 
+*>                  In other term this routine is called as standalone. 
+*>          = 'Y':  "Yes": to mention that the stage 1 of the 
+*>                  reduction from dense to band using the zhetrd_he2hb 
+*>                  routine has been called to produce AB (e.g., AB is
+*>                  the output of zhetrd_he2hb.
+*> \endverbatim
+*>
+*> \param[in] VECT
+*> \verbatim
+*>          VECT is CHARACTER*1
+*>          = 'N':  No need for the Housholder representation, 
+*>                  and thus LHOUS is of size max(1, 4*N);
+*>          = 'V':  the Householder representation is needed to 
+*>                  either generate or to apply Q later on, 
+*>                  then LHOUS is to be queried and computed.
+*>                  (NOT AVAILABLE IN THIS RELEASE).
+*> \endverbatim
+*>
+*> \param[in] UPLO
+*> \verbatim
+*>          UPLO is CHARACTER*1
+*>          = 'U':  Upper triangle of A is stored;
+*>          = 'L':  Lower triangle of A is stored.
+*> \endverbatim
+*>
+*> \param[in] N
+*> \verbatim
+*>          N is INTEGER
+*>          The order of the matrix A.  N >= 0.
+*> \endverbatim
+*>
+*> \param[in] KD
+*> \verbatim
+*>          KD is INTEGER
+*>          The number of superdiagonals of the matrix A if UPLO = 'U',
+*>          or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
+*> \endverbatim
+*>
+*> \param[in,out] AB
+*> \verbatim
+*>          AB is COMPLEX*16 array, dimension (LDAB,N)
+*>          On entry, the upper or lower triangle of the Hermitian band
+*>          matrix A, stored in the first KD+1 rows of the array.  The
+*>          j-th column of A is stored in the j-th column of the array AB
+*>          as follows:
+*>          if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;
+*>          if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).
+*>          On exit, the diagonal elements of AB are overwritten by the
+*>          diagonal elements of the tridiagonal matrix T; if KD > 0, the
+*>          elements on the first superdiagonal (if UPLO = 'U') or the
+*>          first subdiagonal (if UPLO = 'L') are overwritten by the
+*>          off-diagonal elements of T; the rest of AB is overwritten by
+*>          values generated during the reduction.
+*> \endverbatim
+*>
+*> \param[in] LDAB
+*> \verbatim
+*>          LDAB is INTEGER
+*>          The leading dimension of the array AB.  LDAB >= KD+1.
+*> \endverbatim
+*>
+*> \param[out] D
+*> \verbatim
+*>          D is DOUBLE PRECISION array, dimension (N)
+*>          The diagonal elements of the tridiagonal matrix T.
+*> \endverbatim
+*>
+*> \param[out] E
+*> \verbatim
+*>          E is DOUBLE PRECISION array, dimension (N-1)
+*>          The off-diagonal elements of the tridiagonal matrix T:
+*>          E(i) = T(i,i+1) if UPLO = 'U'; E(i) = T(i+1,i) if UPLO = 'L'.
+*> \endverbatim
+*>
+*> \param[out] HOUS
+*> \verbatim
+*>          HOUS is COMPLEX*16 array, dimension LHOUS, that
+*>          store the Householder representation.
+*> \endverbatim
+*>
+*> \param[in] LHOUS
+*> \verbatim
+*>          LHOUS is INTEGER
+*>          The dimension of the array HOUS. LHOUS = MAX(1, dimension)
+*>          If LWORK = -1, or LHOUS=-1,
+*>          then a query is assumed; the routine
+*>          only calculates the optimal size of the HOUS array, returns
+*>          this value as the first entry of the HOUS array, and no error
+*>          message related to LHOUS is issued by XERBLA.
+*>          LHOUS = MAX(1, dimension) where
+*>          dimension = 4*N if VECT='N'
+*>          not available now if VECT='H'     
+*> \endverbatim
+*>
+*> \param[out] WORK
+*> \verbatim
+*>          WORK is COMPLEX*16 array, dimension LWORK.
+*> \endverbatim
+*>
+*> \param[in] LWORK
+*> \verbatim
+*>          LWORK is INTEGER
+*>          The dimension of the array WORK. LWORK = MAX(1, dimension)
+*>          If LWORK = -1, or LHOUS=-1,
+*>          then a workspace query is assumed; the routine
+*>          only calculates the optimal size of the WORK array, returns
+*>          this value as the first entry of the WORK array, and no error
+*>          message related to LWORK is issued by XERBLA.
+*>          LWORK = MAX(1, dimension) where
+*>          dimension   = (2KD+1)*N + KD*NTHREADS
+*>          where KD is the blocking size of the reduction,
+*>          FACTOPTNB is the blocking used by the QR or LQ
+*>          algorithm, usually FACTOPTNB=128 is a good choice
+*>          NTHREADS is the number of threads used when
+*>          openMP compilation is enabled, otherwise =1.
+*> \endverbatim
+*>
+*> \param[out] INFO
+*> \verbatim
+*>          INFO is INTEGER
+*>          = 0:  successful exit
+*>          < 0:  if INFO = -i, the i-th argument had an illegal value
+*> \endverbatim
+*
+*  Authors:
+*  ========
+*
+*> \author Univ. of Tennessee
+*> \author Univ. of California Berkeley
+*> \author Univ. of Colorado Denver
+*> \author NAG Ltd.
+*
+*> \date November 2017
+*
+*> \ingroup complex16OTHERcomputational
+*
+*> \par Further Details:
+*  =====================
+*>
+*> \verbatim
+*>
+*>  Implemented by Azzam Haidar.
+*>
+*>  All details are available on technical report, SC11, SC13 papers.
+*>
+*>  Azzam Haidar, Hatem Ltaief, and Jack Dongarra.
+*>  Parallel reduction to condensed forms for symmetric eigenvalue problems
+*>  using aggregated fine-grained and memory-aware kernels. In Proceedings
+*>  of 2011 International Conference for High Performance Computing,
+*>  Networking, Storage and Analysis (SC '11), New York, NY, USA,
+*>  Article 8 , 11 pages.
+*>  http://doi.acm.org/10.1145/2063384.2063394
+*>
+*>  A. Haidar, J. Kurzak, P. Luszczek, 2013.
+*>  An improved parallel singular value algorithm and its implementation 
+*>  for multicore hardware, In Proceedings of 2013 International Conference
+*>  for High Performance Computing, Networking, Storage and Analysis (SC '13).
+*>  Denver, Colorado, USA, 2013.
+*>  Article 90, 12 pages.
+*>  http://doi.acm.org/10.1145/2503210.2503292
+*>
+*>  A. Haidar, R. Solca, S. Tomov, T. Schulthess and J. Dongarra.
+*>  A novel hybrid CPU-GPU generalized eigensolver for electronic structure 
+*>  calculations based on fine-grained memory aware tasks.
+*>  International Journal of High Performance Computing Applications.
+*>  Volume 28 Issue 2, Pages 196-209, May 2014.
+*>  http://hpc.sagepub.com/content/28/2/196 
+*>
+*> \endverbatim
+*>
+*  =====================================================================
+      SUBROUTINE ZHETRD_HB2ST( STAGE1, VECT, UPLO, N, KD, AB, LDAB, 
+     $                         D, E, HOUS, LHOUS, WORK, LWORK, INFO )
+*
+*
+#if defined(_OPENMP)
+      use omp_lib
+#endif
+*
+      IMPLICIT NONE
+*
+*  -- LAPACK computational routine (version 3.8.0) --
+*  -- LAPACK is a software package provided by Univ. of Tennessee,    --
+*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
+*     November 2017
+*
+*     .. Scalar Arguments ..
+      CHARACTER          STAGE1, UPLO, VECT
+      INTEGER            N, KD, LDAB, LHOUS, LWORK, INFO
+*     ..
+*     .. Array Arguments ..
+      DOUBLE PRECISION   D( * ), E( * )
+      COMPLEX*16         AB( LDAB, * ), HOUS( * ), WORK( * )
+*     ..
+*
+*  =====================================================================
+*
+*     .. Parameters ..
+      DOUBLE PRECISION   RZERO
+      COMPLEX*16         ZERO, ONE
+      PARAMETER          ( RZERO = 0.0D+0,
+     $                   ZERO = ( 0.0D+0, 0.0D+0 ),
+     $                   ONE  = ( 1.0D+0, 0.0D+0 ) )
+*     ..
+*     .. Local Scalars ..
+      LOGICAL            LQUERY, WANTQ, UPPER, AFTERS1
+      INTEGER            I, M, K, IB, SWEEPID, MYID, SHIFT, STT, ST, 
+     $                   ED, STIND, EDIND, BLKLASTIND, COLPT, THED,
+     $                   STEPERCOL, GRSIZ, THGRSIZ, THGRNB, THGRID,
+     $                   NBTILES, TTYPE, TID, NTHREADS, DEBUG,
+     $                   ABDPOS, ABOFDPOS, DPOS, OFDPOS, AWPOS, 
+     $                   INDA, INDW, APOS, SIZEA, LDA, INDV, INDTAU,
+     $                   SIZEV, SIZETAU, LDV, LHMIN, LWMIN
+      DOUBLE PRECISION   ABSTMP
+      COMPLEX*16         TMP
+*     ..
+*     .. External Subroutines ..
+      EXTERNAL           ZHB2ST_KERNELS, ZLACPY, ZLASET, XERBLA
+*     ..
+*     .. Intrinsic Functions ..
+      INTRINSIC          MIN, MAX, CEILING, DBLE, REAL
+*     ..
+*     .. External Functions ..
+      LOGICAL            LSAME
+      INTEGER            ILAENV2STAGE 
+      EXTERNAL           LSAME, ILAENV2STAGE
+*     ..
+*     .. Executable Statements ..
+*
+*     Determine the minimal workspace size required.
+*     Test the input parameters
+*
+      DEBUG   = 0
+      INFO    = 0
+      AFTERS1 = LSAME( STAGE1, 'Y' )
+      WANTQ   = LSAME( VECT, 'V' )
+      UPPER   = LSAME( UPLO, 'U' )
+      LQUERY  = ( LWORK.EQ.-1 ) .OR. ( LHOUS.EQ.-1 )
+*
+*     Determine the block size, the workspace size and the hous size.
+*
+      IB     = ILAENV2STAGE( 2, 'ZHETRD_HB2ST', VECT, N, KD, -1, -1 )
+      LHMIN  = ILAENV2STAGE( 3, 'ZHETRD_HB2ST', VECT, N, KD, IB, -1 )
+      LWMIN  = ILAENV2STAGE( 4, 'ZHETRD_HB2ST', VECT, N, KD, IB, -1 )
+*
+      IF( .NOT.AFTERS1 .AND. .NOT.LSAME( STAGE1, 'N' ) ) THEN
+         INFO = -1
+      ELSE IF( .NOT.LSAME( VECT, 'N' ) ) THEN
+         INFO = -2
+      ELSE IF( .NOT.UPPER .AND. .NOT.LSAME( UPLO, 'L' ) ) THEN
+         INFO = -3
+      ELSE IF( N.LT.0 ) THEN
+         INFO = -4
+      ELSE IF( KD.LT.0 ) THEN
+         INFO = -5
+      ELSE IF( LDAB.LT.(KD+1) ) THEN
+         INFO = -7
+      ELSE IF( LHOUS.LT.LHMIN .AND. .NOT.LQUERY ) THEN
+         INFO = -11
+      ELSE IF( LWORK.LT.LWMIN .AND. .NOT.LQUERY ) THEN
+         INFO = -13
+      END IF
+*
+      IF( INFO.EQ.0 ) THEN
+         HOUS( 1 ) = LHMIN
+         WORK( 1 ) = LWMIN
+      END IF
+*
+      IF( INFO.NE.0 ) THEN
+         CALL XERBLA( 'ZHETRD_HB2ST', -INFO )
+         RETURN
+      ELSE IF( LQUERY ) THEN
+         RETURN
+      END IF
+*
+*     Quick return if possible
+*
+      IF( N.EQ.0 ) THEN
+          HOUS( 1 ) = 1
+          WORK( 1 ) = 1
+          RETURN
+      END IF
+*
+*     Determine pointer position
+*
+      LDV      = KD + IB
+      SIZETAU  = 2 * N
+      SIZEV    = 2 * N
+      INDTAU   = 1
+      INDV     = INDTAU + SIZETAU
+      LDA      = 2 * KD + 1
+      SIZEA    = LDA * N
+      INDA     = 1
+      INDW     = INDA + SIZEA
+      NTHREADS = 1
+      TID      = 0
+*
+      IF( UPPER ) THEN
+          APOS     = INDA + KD
+          AWPOS    = INDA
+          DPOS     = APOS + KD
+          OFDPOS   = DPOS - 1
+          ABDPOS   = KD + 1
+          ABOFDPOS = KD
+      ELSE
+          APOS     = INDA 
+          AWPOS    = INDA + KD + 1
+          DPOS     = APOS
+          OFDPOS   = DPOS + 1
+          ABDPOS   = 1
+          ABOFDPOS = 2
+
+      ENDIF
+*      
+*     Case KD=0: 
+*     The matrix is diagonal. We just copy it (convert to "real" for 
+*     complex because D is double and the imaginary part should be 0) 
+*     and store it in D. A sequential code here is better or 
+*     in a parallel environment it might need two cores for D and E
+*
+      IF( KD.EQ.0 ) THEN
+          DO 30 I = 1, N
+              D( I ) = DBLE( AB( ABDPOS, I ) )
+   30     CONTINUE
+          DO 40 I = 1, N-1
+              E( I ) = RZERO
+   40     CONTINUE
+*
+          HOUS( 1 ) = 1
+          WORK( 1 ) = 1
+          RETURN
+      END IF
+*      
+*     Case KD=1: 
+*     The matrix is already Tridiagonal. We have to make diagonal 
+*     and offdiagonal elements real, and store them in D and E.
+*     For that, for real precision just copy the diag and offdiag 
+*     to D and E while for the COMPLEX case the bulge chasing is  
+*     performed to convert the hermetian tridiagonal to symmetric 
+*     tridiagonal. A simpler coversion formula might be used, but then 
+*     updating the Q matrix will be required and based if Q is generated
+*     or not this might complicate the story. 
+*      
+      IF( KD.EQ.1 ) THEN
+          DO 50 I = 1, N
+              D( I ) = DBLE( AB( ABDPOS, I ) )
+   50     CONTINUE
+*
+*         make off-diagonal elements real and copy them to E
+*
+          IF( UPPER ) THEN
+              DO 60 I = 1, N - 1
+                  TMP = AB( ABOFDPOS, I+1 )
+                  ABSTMP = ABS( TMP )
+                  AB( ABOFDPOS, I+1 ) = ABSTMP
+                  E( I ) = ABSTMP
+                  IF( ABSTMP.NE.RZERO ) THEN
+                     TMP = TMP / ABSTMP
+                  ELSE
+                     TMP = ONE
+                  END IF
+                  IF( I.LT.N-1 )
+     $               AB( ABOFDPOS, I+2 ) = AB( ABOFDPOS, I+2 )*TMP
+C                  IF( WANTZ ) THEN
+C                     CALL ZSCAL( N, DCONJG( TMP ), Q( 1, I+1 ), 1 )
+C                  END IF
+   60         CONTINUE
+          ELSE
+              DO 70 I = 1, N - 1
+                 TMP = AB( ABOFDPOS, I )
+                 ABSTMP = ABS( TMP )
+                 AB( ABOFDPOS, I ) = ABSTMP
+                 E( I ) = ABSTMP
+                 IF( ABSTMP.NE.RZERO ) THEN
+                    TMP = TMP / ABSTMP
+                 ELSE
+                    TMP = ONE
+                 END IF
+                 IF( I.LT.N-1 )
+     $              AB( ABOFDPOS, I+1 ) = AB( ABOFDPOS, I+1 )*TMP
+C                 IF( WANTQ ) THEN
+C                    CALL ZSCAL( N, TMP, Q( 1, I+1 ), 1 )
+C                 END IF
+   70         CONTINUE
+          ENDIF
+*
+          HOUS( 1 ) = 1
+          WORK( 1 ) = 1
+          RETURN
+      END IF
+*
+*     Main code start here. 
+*     Reduce the hermitian band of A to a tridiagonal matrix.
+*
+      THGRSIZ   = N
+      GRSIZ     = 1
+      SHIFT     = 3
+      NBTILES   = CEILING( REAL(N)/REAL(KD) )
+      STEPERCOL = CEILING( REAL(SHIFT)/REAL(GRSIZ) )
+      THGRNB    = CEILING( REAL(N-1)/REAL(THGRSIZ) )
+*      
+      CALL ZLACPY( "A", KD+1, N, AB, LDAB, WORK( APOS ), LDA )
+      CALL ZLASET( "A", KD,   N, ZERO, ZERO, WORK( AWPOS ), LDA )
+*
+*
+*     openMP parallelisation start here
+*
+#if defined(_OPENMP)
+!$OMP PARALLEL PRIVATE( TID, THGRID, BLKLASTIND )
+!$OMP$         PRIVATE( THED, I, M, K, ST, ED, STT, SWEEPID ) 
+!$OMP$         PRIVATE( MYID, TTYPE, COLPT, STIND, EDIND )
+!$OMP$         SHARED ( UPLO, WANTQ, INDV, INDTAU, HOUS, WORK)
+!$OMP$         SHARED ( N, KD, IB, NBTILES, LDA, LDV, INDA )
+!$OMP$         SHARED ( STEPERCOL, THGRNB, THGRSIZ, GRSIZ, SHIFT )
+!$OMP MASTER
+#endif
+*
+*     main bulge chasing loop
+*      
+      DO 100 THGRID = 1, THGRNB
+          STT  = (THGRID-1)*THGRSIZ+1
+          THED = MIN( (STT + THGRSIZ -1), (N-1))
+          DO 110 I = STT, N-1
+              ED = MIN( I, THED )
+              IF( STT.GT.ED ) EXIT
+              DO 120 M = 1, STEPERCOL
+                  ST = STT
+                  DO 130 SWEEPID = ST, ED
+                      DO 140 K = 1, GRSIZ
+                          MYID  = (I-SWEEPID)*(STEPERCOL*GRSIZ) 
+     $                           + (M-1)*GRSIZ + K
+                          IF ( MYID.EQ.1 ) THEN
+                              TTYPE = 1
+                          ELSE
+                              TTYPE = MOD( MYID, 2 ) + 2
+                          ENDIF
+
+                          IF( TTYPE.EQ.2 ) THEN
+                              COLPT      = (MYID/2)*KD + SWEEPID
+                              STIND      = COLPT-KD+1
+                              EDIND      = MIN(COLPT,N)
+                              BLKLASTIND = COLPT
+                          ELSE
+                              COLPT      = ((MYID+1)/2)*KD + SWEEPID
+                              STIND      = COLPT-KD+1
+                              EDIND      = MIN(COLPT,N)
+                              IF( ( STIND.GE.EDIND-1 ).AND.
+     $                            ( EDIND.EQ.N ) ) THEN
+                                  BLKLASTIND = N
+                              ELSE
+                                  BLKLASTIND = 0
+                              ENDIF
+                          ENDIF
+*
+*                         Call the kernel
+*                             
+#if defined(_OPENMP) &&  _OPENMP >= 201307
+
+                          IF( TTYPE.NE.1 ) THEN      
+!$OMP TASK DEPEND(in:WORK(MYID+SHIFT-1))
+!$OMP$     DEPEND(in:WORK(MYID-1))
+!$OMP$     DEPEND(out:WORK(MYID))
+                              TID      = OMP_GET_THREAD_NUM()
+                              CALL ZHB2ST_KERNELS( UPLO, WANTQ, TTYPE, 
+     $                             STIND, EDIND, SWEEPID, N, KD, IB,
+     $                             WORK ( INDA ), LDA, 
+     $                             HOUS( INDV ), HOUS( INDTAU ), LDV,
+     $                             WORK( INDW + TID*KD ) )
+!$OMP END TASK
+                          ELSE
+!$OMP TASK DEPEND(in:WORK(MYID+SHIFT-1))
+!$OMP$     DEPEND(out:WORK(MYID))
+                              TID      = OMP_GET_THREAD_NUM()
+                              CALL ZHB2ST_KERNELS( UPLO, WANTQ, TTYPE, 
+     $                             STIND, EDIND, SWEEPID, N, KD, IB,
+     $                             WORK ( INDA ), LDA, 
+     $                             HOUS( INDV ), HOUS( INDTAU ), LDV,
+     $                             WORK( INDW + TID*KD ) )
+!$OMP END TASK
+                          ENDIF
+#else
+                          CALL ZHB2ST_KERNELS( UPLO, WANTQ, TTYPE, 
+     $                         STIND, EDIND, SWEEPID, N, KD, IB,
+     $                         WORK ( INDA ), LDA, 
+     $                         HOUS( INDV ), HOUS( INDTAU ), LDV,
+     $                         WORK( INDW + TID*KD ) )
+#endif 
+                          IF ( BLKLASTIND.GE.(N-1) ) THEN
+                              STT = STT + 1
+                              EXIT
+                          ENDIF
+  140                 CONTINUE
+  130             CONTINUE
+  120         CONTINUE
+  110     CONTINUE
+  100 CONTINUE
+*
+#if defined(_OPENMP)
+!$OMP END MASTER
+!$OMP END PARALLEL
+#endif
+*      
+*     Copy the diagonal from A to D. Note that D is REAL thus only
+*     the Real part is needed, the imaginary part should be zero.
+*
+      DO 150 I = 1, N
+          D( I ) = DBLE( WORK( DPOS+(I-1)*LDA ) )
+  150 CONTINUE
+*      
+*     Copy the off diagonal from A to E. Note that E is REAL thus only
+*     the Real part is needed, the imaginary part should be zero.
+*
+      IF( UPPER ) THEN
+          DO 160 I = 1, N-1
+             E( I ) = DBLE( WORK( OFDPOS+I*LDA ) )
+  160     CONTINUE
+      ELSE
+          DO 170 I = 1, N-1
+             E( I ) = DBLE( WORK( OFDPOS+(I-1)*LDA ) )
+  170     CONTINUE
+      ENDIF
+*
+      HOUS( 1 ) = LHMIN
+      WORK( 1 ) = LWMIN
+      RETURN
+*
+*     End of ZHETRD_HB2ST
+*
+      END
+      
diff -ru test/qmmm_DFTB/dftb3/nma-h2o-box/Run.nma-spcfw-15.md test/qmmm_DFTB/dftb3/nma-h2o-box/Run.nma-spcfw-15.md
--- test/qmmm_DFTB/dftb3/nma-h2o-box/Run.nma-spcfw-15.md	2019-08-01 21:30:10.000000000 +0900
+++ test/qmmm_DFTB/dftb3/nma-h2o-box/Run.nma-spcfw-15.md	2023-08-22 20:05:38.000000000 +0900
@@ -9,6 +9,10 @@
     set sander = $TESTsander
 endif

+if( ! $?DO_PARALLEL ) then
+    setenv DO_PARALLEL " "
+endif
+
 ../../../check_slko_files.x DFTB3
 if( $status > 0) then
   exit(0)
@@ -48,7 +52,7 @@
 rm -f $output

 touch dummy
-$sander -O -p $prmtop -c $inpcrd -o $output < dummy || goto error
+$DO_PARALLEL $sander -O -p $prmtop -c $inpcrd -o $output < dummy || goto error

 # remove info about number of threads from output as this may vary
 grep -v 'num_threads' $output > tmp
diff -ru test/velocity_write/Run.vel2 test/velocity_write/Run.vel2
--- test/velocity_write/Run.vel2	2022-01-29 01:49:02.000000000 +0900
+++ test/velocity_write/Run.vel2	2023-08-22 19:50:55.000000000 +0900
@@ -22,7 +22,7 @@

 # Exact diff for sander:
 tol_arg=''
-if [ -z "`$sander --version | grep sander`" ] ; then
+if [ -z "`$DO_PARALLEL $sander --version | grep sander`" ] ; then
   # Allow minor roundoff for pmemd:
   tol_arg='-a 0.002'
 fi
diff -ru AmberTools/test/bar_pbsa/Run.bar_pbsa AmberTools/test/bar_pbsa/Run.bar_pbsa
--- AmberTools/test/bar_pbsa/Run.bar_pbsa	2022-01-29 01:48:58.000000000 +0900
+++ AmberTools/test/bar_pbsa/Run.bar_pbsa	2023-09-13 15:40:59.000000000 +0900
@@ -1,5 +1,11 @@
 #!/bin/sh

+SKIP_PYTHON=`grep "SKIP_PYTHON=yes" $AMBERHOME/config.h`
+if [ "$SKIP_PYTHON" != "" ]; then
+      echo "No python modules. Skipping..."
+      exit 0
+fi
+
 numprocs=1
 if [ -n "${DO_PARALLEL}" ] ; then
    numprocs=`echo $DO_PARALLEL | awk -f ../numprocs.awk `
diff -ru cmake-packaging/top-level-test-makefile cmake-packaging/top-level-test-makefile
--- cmake-packaging/top-level-test-makefile	2023-10-06 17:38:24.000000000 +0900
+++ cmake-packaging/top-level-test-makefile	2023-10-13 11:55:12.000000000 +0900
@@ -14,7 +14,12 @@
 	@echo "  Use 'test.serial', 'test.parallel, 'test.cuda.serial' or 'test.cuda.parallel'"
 
 test.serial:
-	-(cd AmberTools/test && $(MAKE) test)
+	-@(if [ "$(SKIP_PYTHON)" = "no" ] ; then \
+		cd AmberTools/test && $(MAKE) test; \
+	else \
+		cd AmberTools/test && $(MAKE) test.nopython; \
+	fi ;\
+	)
 	@(if [ -n "$(BUILDAMBER)" ] ; then \
 		cd test && $(MAKE) test; \
 		echo ""; \
diff -ru test/nfe/groups test/nfe/groups
--- test/nfe/groups	2019-08-01 21:30:10.000000000 +0900
+++ test/nfe/groups	2023-10-22 17:27:52.481185503 +0900
@@ -1,4 +1,4 @@
--O -i mdin.1 -c inpcrd.1 -o mdout.1 -p prmtop -x mdcrd.1 -r restrt.1 -inf /dev/null
--O -i mdin.2 -c inpcrd.2 -o mdout.2 -p prmtop -x mdcrd.2 -r restrt.2 -inf /dev/null
--O -i mdin.3 -c inpcrd.3 -o mdout.3 -p prmtop -x mdcrd.3 -r restrt.3 -inf /dev/null
--O -i mdin.4 -c inpcrd.4 -o mdout.4 -p prmtop -x mdcrd.4 -r restrt.4 -inf /dev/null
+-O -i mdin.1 -c inpcrd.1 -o mdout.1 -p prmtop -x mdcrd.1 -r restrt.1 -inf reminfo.1
+-O -i mdin.2 -c inpcrd.2 -o mdout.2 -p prmtop -x mdcrd.2 -r restrt.2 -inf reminfo.2
+-O -i mdin.3 -c inpcrd.3 -o mdout.3 -p prmtop -x mdcrd.3 -r restrt.3 -inf reminfo.3
+-O -i mdin.4 -c inpcrd.4 -o mdout.4 -p prmtop -x mdcrd.4 -r restrt.4 -inf reminfo.4
diff -ru test/nfe/bbmd/Run.sander.sh test/nfe/bbmd/Run.sander.sh
--- test/nfe/bbmd/Run.sander.sh	2022-04-09 10:11:47.000000000 +0900
+++ test/nfe/bbmd/Run.sander.sh	2023-10-22 17:42:11.037540650 +0900
@@ -26,7 +26,7 @@
 # remove the junk
 #

-/bin/rm -rf ${JUNK} junk.*
+/bin/rm -rf ${JUNK} junk.* reminfo.?

 #
 # prepare files
--- test/nfe/bbmd/Run.pmemd.sh	2022-04-09 10:11:47.000000000 +0900
+++ test/nfe/bbmd/Run.pmemd.sh	2023-10-22 17:42:23.873664628 +0900
@@ -26,7 +26,7 @@
 # remove the junk
 #
 
-/bin/rm -rf ${JUNK} junk.*
+/bin/rm -rf ${JUNK} junk.* reminfo.?
 
 #
 # prepare files
--- test/nfe/abremd/Run.sander.sh	2022-04-09 10:11:47.000000000 +0900
+++ test/nfe/abremd/Run.sander.sh	2023-10-22 17:46:53.040292264 +0900
@@ -26,7 +26,7 @@
 # remove the junk
 #
 
-/bin/rm -rf ${JUNK} junk.*
+/bin/rm -rf ${JUNK} junk.* reminfo.?
 
 #
 # prepare files
--- test/nfe/abremd/Run.pmemd.sh	2022-04-09 10:11:47.000000000 +0900
+++ test/nfe/abremd/Run.pmemd.sh	2023-10-22 17:47:04.885407642 +0900
@@ -26,7 +26,7 @@
 # remove the junk
 #
 
-/bin/rm -rf ${JUNK} junk.*
+/bin/rm -rf ${JUNK} junk.* reminfo.?
 
 #
 # prepare files
--- test/nfe/mwabmd/Run.sander.sh	2022-04-09 10:11:47.000000000 +0900
+++ test/nfe/mwabmd/Run.sander.sh	2023-10-22 17:48:01.086954803 +0900
@@ -26,7 +26,7 @@
 # remove the junk
 #
 
-/bin/rm -rf ${JUNK} junk.*
+/bin/rm -rf ${JUNK} junk.* reminfo.?
 
 #
 # prepare files
--- test/nfe/mwabmd/Run.pmemd.sh	2022-04-09 10:11:47.000000000 +0900
+++ test/nfe/mwabmd/Run.pmemd.sh	2023-10-22 17:48:12.677067642 +0900
@@ -26,7 +26,7 @@
 # remove the junk
 #
 
-/bin/rm -rf ${JUNK} junk.*
+/bin/rm -rf ${JUNK} junk.* reminfo.?
 
 #
 # prepare files
--- test/nfe/premd/Run.sander.sh	2022-04-09 10:11:47.000000000 +0900
+++ test/nfe/premd/Run.sander.sh	2023-10-22 17:49:10.225627927 +0900
@@ -15,7 +15,7 @@
 # remove the junk
 #
 
-/bin/rm -rf ${JUNK} junk.*
+/bin/rm -rf ${JUNK} junk.* reminfo.?
 
 #
 # prepare files
--- test/nfe/premd/Run.pmemd.sh	2022-04-09 10:11:47.000000000 +0900
+++ test/nfe/premd/Run.pmemd.sh	2023-10-22 17:49:21.079733596 +0900
@@ -15,7 +15,7 @@
 # remove the junk
 #
 
-/bin/rm -rf ${JUNK} junk.*
+/bin/rm -rf ${JUNK} junk.* reminfo.?
 
 #
 # prepare files
*** ./cmake/WhichTools.cmake	2023-12-04 13:51:32.000000000 +0900
--- ./cmake/WhichTools.cmake	2023-12-04 13:51:51.000000000 +0900
***************
*** 31,41 ****
  reduce
  sebomd
  emil
  kmmd
  ndiff-2.00
- gem.pmemd
  xray
  
  #	cpptraj:
  cpptraj
  ambpdb
--- 31,40 ----
*** ./AmberTools/test/test_at_parallel.sh	2023-12-04 13:57:36.000000000 +0900
--- ./AmberTools/test/test_at_parallel.sh	2023-12-04 13:58:00.000000000 +0900
***************
*** 12,22 ****
  check_environment `dirname $dir` parallel
  
  mkdir -p ${logdir}
  (make -k               test.parallel2 2>&1) | tee ${logfile}
  (make -k -C ../../test test.parallel.at 2>&1) | tee -a ${logfile}
! (make -k -C ../../test test.parallel.gem.pmemd 2>&1) | tee -a ${logfile}
  (make finished.parallel 2>&1) | tee -a ${logfile}
  
  passed_count=`grep PASS ${logfile} | wc -l`
  questionable_count=`grep "FAILURE:" ${logfile} | wc -l`
  questionable_ignored_count=`grep -e "FAILURE: (ignored)" ${logfile} | wc -l`
--- 12,22 ----
  check_environment `dirname $dir` parallel
  
  mkdir -p ${logdir}
  (make -k               test.parallel2 2>&1) | tee ${logfile}
  (make -k -C ../../test test.parallel.at 2>&1) | tee -a ${logfile}
! #(make -k -C ../../test test.parallel.gem.pmemd 2>&1) | tee -a ${logfile}
  (make finished.parallel 2>&1) | tee -a ${logfile}
  
  passed_count=`grep PASS ${logfile} | wc -l`
  questionable_count=`grep "FAILURE:" ${logfile} | wc -l`
  questionable_ignored_count=`grep -e "FAILURE: (ignored)" ${logfile} | wc -l`
*** ./AmberTools/test/test_at_serial.sh	2023-12-04 13:56:56.000000000 +0900
--- ./AmberTools/test/test_at_serial.sh	2023-12-04 13:57:22.000000000 +0900
***************
*** 16,26 ****
     (make -k               test.serial.nopython 2>&1) | tee ${logfile}
     (make -k -C ../../test test.serial.nopython 2>&1) | tee -a ${logfile}
  else
     (make -k               test.serial 2>&1) | tee ${logfile}
     (make -k -C ../../test test.serial 2>&1) | tee -a ${logfile}
!    (make -k -C ../../test test.serial.gem.pmemd 2>&1) | tee -a ${logfile}
  fi
  (make finished.serial 2>&1) | tee -a ${logfile}
  
  passed_count=`grep PASS ${logfile} | wc -l`
  questionable_count=`grep "FAILURE:" ${logfile} | wc -l`
--- 16,26 ----
     (make -k               test.serial.nopython 2>&1) | tee ${logfile}
     (make -k -C ../../test test.serial.nopython 2>&1) | tee -a ${logfile}
  else
     (make -k               test.serial 2>&1) | tee ${logfile}
     (make -k -C ../../test test.serial 2>&1) | tee -a ${logfile}
! #   (make -k -C ../../test test.serial.gem.pmemd 2>&1) | tee -a ${logfile}
  fi
  (make finished.serial 2>&1) | tee -a ${logfile}
  
  passed_count=`grep PASS ${logfile} | wc -l`
  questionable_count=`grep "FAILURE:" ${logfile} | wc -l`
*** ./AmberTools/src/quick/cmake/WhichTools.cmake	2023-12-04 13:54:20.000000000 +0900
--- ./AmberTools/src/quick/cmake/WhichTools.cmake	2023-12-04 13:54:45.000000000 +0900
***************
*** 30,40 ****
  #   miscellaneous:
  reduce
  sebomd
  emil
  ndiff-2.00
- gem.pmemd
  xray
  
  #	cpptraj:
  cpptraj
  ambpdb
--- 30,39 ----
